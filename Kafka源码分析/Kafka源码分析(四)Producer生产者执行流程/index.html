<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"yuanxw.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":5,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="代码的入口main方法中Producer类是一个多线程，在main中对producerThread进行start。表示开始了这个线程，Producer类中的run方法被获得被执行。">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka源码分析(四)Producer生产者执行流程">
<meta property="og:url" content="https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)Producer%E7%94%9F%E4%BA%A7%E8%80%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="代码的入口main方法中Producer类是一个多线程，在main中对producerThread进行start。表示开始了这个线程，Producer类中的run方法被获得被执行。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanxw.github.io/images/kafak_source/chapter4/image.png">
<meta property="og:image" content="https://yuanxw.github.io/images/kafak_source/chapter4/image1.png">
<meta property="og:image" content="https://yuanxw.github.io/images/kafak_source/chapter4/image2.png">
<meta property="article:published_time" content="2025-07-03T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-03T17:04:20.946Z">
<meta property="article:author" content="Panda Yuan">
<meta property="article:tag" content="Kafka">
<meta property="article:tag" content="Kafka源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanxw.github.io/images/kafak_source/chapter4/image.png">


<link rel="canonical" href="https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)Producer%E7%94%9F%E4%BA%A7%E8%80%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)Producer%E7%94%9F%E4%BA%A7%E8%80%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","path":"Kafka源码分析/Kafka源码分析(四)Producer生产者执行流程/","title":"Kafka源码分析(四)Producer生产者执行流程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Kafka源码分析(四)Producer生产者执行流程 | 我的博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.9.0/mermaid.min.js","integrity":"sha256-Cz7UN0EXNjgV2u/a38wg/3BNfdRRO1XtgDq93L2GqJg="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>



  <script src="/js/third-party/pace.js" defer></script>


  




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/3.0.1/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)Producer%E7%94%9F%E4%BA%A7%E8%80%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"}</script>
  <script src="/js/third-party/quicklink.js" defer></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="我的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9B%9B-Producer%E7%94%9F%E4%BA%A7%E8%80%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">Kafka源码分析(四)Producer生产者执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Producer%E8%8E%B7%E5%8F%96%E5%85%83%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">1.2.</span> <span class="nav-text">二、Producer获取元数据流程图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">三、源代码分析</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Panda Yuan"
      src="/images/gongfu_panda.jpg">
  <p class="site-author-name" itemprop="name">Panda Yuan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanxw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanxw" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanxiongw@126.com" title="E-Mail → mailto:yuanxiongw@126.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)Producer%E7%94%9F%E4%BA%A7%E8%80%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gongfu_panda.jpg">
      <meta itemprop="name" content="Panda Yuan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Kafka源码分析(四)Producer生产者执行流程 | 我的博客">
      <meta itemprop="description" content="代码的入口main方法中Producer类是一个多线程，在main中对producerThread进行start。表示开始了这个线程，Producer类中的run方法被获得被执行。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kafka源码分析(四)Producer生产者执行流程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-07-04T00:00:00+08:00">2025-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-04 01:04:20" itemprop="dateModified" datetime="2025-09-04T01:04:20+08:00">2025-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">代码的入口main方法中Producer类是一个多线程，在main中对producerThread进行start。表示开始了这个线程，Producer类中的run方法被获得被执行。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Kafka源码分析-四-Producer生产者执行流程"><a href="#Kafka源码分析-四-Producer生产者执行流程" class="headerlink" title="Kafka源码分析(四)Producer生产者执行流程"></a>Kafka源码分析(四)Producer生产者执行流程</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><ul>
<li>代码的入口main方法中Producer类是一个多线程，在main中对producerThread进行start。表示开始了这个线程，Producer类中的run方法被获得被执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConsumerProducerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否是异步：如果参数个数为0，或者第一个参数不是&quot;sync&quot;，则是异步。生产环境一般是异步的数据处理。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAsync</span> <span class="operator">=</span> args.length == <span class="number">0</span> || !args[<span class="number">0</span>].trim().equalsIgnoreCase(<span class="string">&quot;sync&quot;</span>);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(KafkaProperties.TOPIC, isAsync);</span><br><span class="line">        producerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(KafkaProperties.TOPIC);</span><br><span class="line">        consumerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、Producer获取元数据流程图"><a href="#二、Producer获取元数据流程图" class="headerlink" title="二、Producer获取元数据流程图"></a>二、Producer获取元数据流程图</h2><ul>
<li>Producer流程图</li>
</ul>
<p><img src="/images/kafak_source/chapter4/image.png" alt="image.png"></p>
<ul>
<li><p>获取元素流程图</p>
<p>  <img src="/images/kafak_source/chapter4/image1.png" alt="image.png"></p>
</li>
<li><p>Broker和Partition关系图</p>
<p>  <img src="/images/kafak_source/chapter4/image2.png" alt="image.png"></p>
</li>
</ul>
<pre>
<code class="mermaid">
sequenceDiagram
autonumber
Producer -&gt;&gt; Producer: run()方法
Producer -&gt;&gt; KafkaProducer:send()
KafkaProducer -&gt;&gt; KafkaProducer: 执行拦截器
Note right of KafkaProducer : Producer唤醒sender线程等待元数据更新
KafkaProducer -&gt;&gt; KafkaProducer: 从服务端获取metadata数据
	KafkaProducer -&gt;&gt; Metadata: 将topic添加到metadata列表，如果列表中不存在topic，则把属性needUpdate设置为：true
	KafkaProducer -&gt;&gt; KafkaProducer: 从缓存中获取metadata数据，如果存在已经存在缓存的数据，直接返回流程结束
  loop topic主题分区数量：partitionsCount
      KafkaProducer -&gt;&gt; Metadata: 属性needUpdate设置为：true
      KafkaProducer --&gt;&gt; Sender: 唤醒sender线程
      KafkaProducer -&gt;&gt; Metadata: 等待元数据更新，直到当前版本大于我们所知道的最后一个版本，或者等待超时
  end
  
loop Sender线程while true死循环
			Note right of NetworkClient: 获取并验证apiVersion版本：handleInitiateApiVersionRequests()] 
			Sender -&gt;&gt; NetworkClient: 当Producer线程把needUpdate设置为true时，&lt;br&#x2F;&gt;说明需要更新metadata信息
			NetworkClient -&gt;&gt; NetworkClient: 第一次初始化网络连接：initiateConnect
			NetworkClient -&gt;&gt; NetworkClient: 网络连接已经完成后，注册版本添加一个write写的事件
			NetworkClient -&gt;&gt; NetworkClient : handleInitiateApiVersionRequests()处理apiVersion请求。
			NetworkClient -&gt;&gt; NetworkClient : 再次循环handleApiVersionsResponse()成功校验apiVersion版本，并修改连接状态为ready
			Note right of NetworkClient: 元数据获取
			NetworkClient -&gt;&gt; NetworkClient : 构建获取元数据请求参数sendInternalMetadataRequest
			NetworkClient -&gt;&gt; NetworkClient : 处理返回值handleCompletedMetadataResponse更新元素数据metadata对象，版本号+1
			NetworkClient --&gt;&gt; Producer: notifyAll，唤醒Producer主线程
			Sender -&gt;&gt; Sender: 获取已准备好发送数据的分区请求
			Sender -&gt;&gt; Sender: 判断节点有没有准备好，并移除没有准备的节点
			Sender -&gt;&gt; NetworkClient: 如果没有建立连接 -&gt; 初始化网络连接
			NetworkClient -&gt;&gt; Selector: 建立连接注册的OP_CONNECT事件
			Sender -&gt;&gt; Sender: 准备待发送请求的数据
			Sender -&gt;&gt; NetworkClient: 执行网络请求poll
			NetworkClient -&gt;&gt; NetworkClient: 封装要拉取元数据的请求
			NetworkClient -&gt;&gt; NetworkClient: 处理返回请求的操作，包括：&lt;br&#x2F;&gt;处理被中止的发送请求、&lt;br&#x2F;&gt;处理已完成的发送请求、&lt;br&#x2F;&gt;处理从Broker接收到的响应、&lt;br&#x2F;&gt;处理连接断开事件、&lt;br&#x2F;&gt;建立新连接、&lt;br&#x2F;&gt;处理API版本协商请求、&lt;br&#x2F;&gt;处理超时请求
			NetworkClient -&gt;&gt; NetworkClient: 执行回调函数
			
	end	
	
KafkaProducer -&gt;&gt; KafkaProducer: 对消息key和value进行序列化
KafkaProducer -&gt;&gt; KafkaProducer: 根据分区策略获取消息发送的分区
%% 默认分区策略（DefaultPartitioner.java）
%% 获得topic的分区的数量
%% 如果没有指定key，则生成一个随机数，正整数，然后取模获得分区号。
%% 有指定key，把key的字节数组用hash算法生成一个整数，然后取模获得分区号。
KafkaProducer -&gt;&gt; KafkaProducer: 获取序列化后的消息大小并验证大小是否超过默认1M限制
KafkaProducer -&gt;&gt; KafkaProducer: 绑定拦截器和回调函数
KafkaProducer -&gt;&gt; KafkaProducer: 消息添加到Accumulator中，Accumulator负责将消息分成多个批次，并将消息发送到Kafka集群
KafkaProducer -&gt;&gt; KafkaProducer: 如果Accumulator中缓存的消息数量已满或已创建新的批次，则唤醒sender线程
KafkaProducer -&gt;&gt; KafkaProducer: 返回RecordMetadataFuture，用于获取消息发送结果
</code>
</pre>

<h2 id="三、源代码分析"><a href="#三、源代码分析" class="headerlink" title="三、源代码分析"></a>三、源代码分析</h2><ul>
<li><p>Producer 主线程</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaProducer&lt;Integer, String&gt; producer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Boolean isAsync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者构造函数</span></span><br><span class="line"><span class="comment">     * topic: 主题名称</span></span><br><span class="line"><span class="comment">     * isAsync: 是否异步发送</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isAsync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(String topic, Boolean isAsync)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 连接kafka集群地址，这里使用默认配置：localhost:9092</span></span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, KafkaProperties.KAFKA_SERVER_URL + <span class="string">&quot;:&quot;</span> + KafkaProperties.KAFKA_SERVER_PORT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// client.id: 客户端ID，用于标识当前生产者实例</span></span><br><span class="line">        props.put(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;DemoProducer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key.serializer: key序列化器，这里使用IntegerSerializer</span></span><br><span class="line">        <span class="comment">// value.serializer: value序列化器，这里使用StringSerializer</span></span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.IntegerSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// KafkaProducer实例化, 传入配置信息</span></span><br><span class="line">        producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line">        <span class="built_in">this</span>.topic = topic;</span><br><span class="line">        <span class="built_in">this</span>.isAsync = isAsync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">messageNo</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">messageStr</span> <span class="operator">=</span> <span class="string">&quot;Message_&quot;</span> + messageNo;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (isAsync) &#123; <span class="comment">// Send asynchronously</span></span><br><span class="line">                producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic,</span><br><span class="line">                    messageNo,</span><br><span class="line">                    messageStr), <span class="keyword">new</span> <span class="title class_">DemoCallBack</span>(startTime, messageNo, messageStr));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Send synchronously</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic,</span><br><span class="line">                        messageNo,</span><br><span class="line">                        messageStr)).get();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Sent message: (&quot;</span> + messageNo + <span class="string">&quot;, &quot;</span> + messageStr + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++messageNo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KafkaProducer.send() 发送消息之前，先将消息拦截器拦截</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title function_">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> &#123;</span><br><span class="line">    <span class="comment">// 发送消息之前，先将消息拦截器拦截</span></span><br><span class="line">    <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="built_in">this</span>.interceptors == <span class="literal">null</span> ? record : <span class="built_in">this</span>.interceptors.onSend(record);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> doSend(interceptedRecord, callback);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>KafkaProducer.doSend() 发送消息</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title function_">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> &#123;</span><br><span class="line">    <span class="type">TopicPartition</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从服务端获取元数据：maxBlockTimeMs：最大阻塞时间，默认60s</span></span><br><span class="line">        <span class="type">ClusterAndWaitTime</span> <span class="variable">clusterAndWaitTime</span> <span class="operator">=</span> waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">        <span class="comment">// remainingWaitMs（剩余可用时间） = maxBlockTimeMs（最大阻塞时间） - clusterAndWaitTime.waitedOnMetadataMs(上次获取元数据耗时)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">remainingWaitMs</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">        <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> clusterAndWaitTime.cluster;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 对消息key和value进行序列化</span></span><br><span class="line">        <span class="type">byte</span>[] serializedKey;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serializedKey = keySerializer.serialize(record.topic(), record.key());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(<span class="string">&quot;Can&#x27;t convert key of class &quot;</span> + record.key().getClass().getName() +</span><br><span class="line">                    <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                    <span class="string">&quot; specified in key.serializer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] serializedValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serializedValue = valueSerializer.serialize(record.topic(), record.value());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(<span class="string">&quot;Can&#x27;t convert value of class &quot;</span> + record.value().getClass().getName() +</span><br><span class="line">                    <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                    <span class="string">&quot; specified in value.serializer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 根据分区策略获取消息发送的分区</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 获取序列化后的消息大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">serializedSize</span> <span class="operator">=</span> Records.LOG_OVERHEAD + Record.recordSize(serializedKey, serializedValue);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 验证消息大小是否超出限制，默认1M</span></span><br><span class="line">        ensureValidRecordSize(serializedSize);</span><br><span class="line">        tp = <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), partition);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> record.timestamp() == <span class="literal">null</span> ? time.milliseconds() : record.timestamp();</span><br><span class="line">        log.trace(<span class="string">&quot;Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;&quot;</span>, record, callback, record.topic(), partition);</span><br><span class="line">        <span class="comment">// producer callback will make sure to call both &#x27;callback&#x27; and interceptor callback</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 绑定拦截器和回调函数</span></span><br><span class="line">        <span class="type">Callback</span> <span class="variable">interceptCallback</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptors == <span class="literal">null</span> ? callback : <span class="keyword">new</span> <span class="title class_">InterceptorCallback</span>&lt;&gt;(callback, <span class="built_in">this</span>.interceptors, tp);</span><br><span class="line">        <span class="comment">// 消息添加到Accumulator中，Accumulator负责将消息分成多个批次，并将消息发送到Kafka集群</span></span><br><span class="line">        RecordAccumulator.<span class="type">RecordAppendResult</span> <span class="variable">result</span> <span class="operator">=</span> accumulator.append(tp, timestamp, serializedKey, serializedValue, interceptCallback, remainingWaitMs);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果Accumulator中缓存的消息数量已满或已创建新的批次，则唤醒sender线程</span></span><br><span class="line">        <span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch&quot;</span>, record.topic(), partition);</span><br><span class="line">            <span class="built_in">this</span>.sender.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回RecordMetadataFuture，用于获取消息发送结果</span></span><br><span class="line">        <span class="keyword">return</span> result.future;</span><br><span class="line">        <span class="comment">// handling exceptions and record the errors;</span></span><br><span class="line">        <span class="comment">// for API exceptions return them in the future,</span></span><br><span class="line">        <span class="comment">// for other exceptions throw directly</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ApiException e) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Exception occurred during message send:&quot;</span>, e);</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>)</span><br><span class="line">            callback.onCompletion(<span class="literal">null</span>, e);</span><br><span class="line">        <span class="built_in">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureFailure</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BufferExhaustedException e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.errors.record();</span><br><span class="line">        <span class="built_in">this</span>.metrics.sensor(<span class="string">&quot;buffer-exhausted-records&quot;</span>).record();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// we notify interceptor about all exceptions, since onSend is called before anything else in this method</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从服务端获取元数据<code>waitOnMetadata</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wait for cluster metadata including partitions for the given topic to be available.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic The topic we want metadata for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> partition A specific partition expected to exist in metadata, or null if there&#x27;s no preference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxWaitMs The maximum time in ms for waiting on the metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The cluster containing topic metadata and the amount of time we waited in ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ClusterAndWaitTime <span class="title function_">waitOnMetadata</span><span class="params">(String topic, Integer partition, <span class="type">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 将主题添加到元数据主题列表（如果尚不存在）并重置过期时间和needUpdate设置为true</span></span><br><span class="line">    metadata.add(topic);</span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> metadata.fetch();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">partitionsCount</span> <span class="operator">=</span> cluster.partitionCountForTopic(topic);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果我们有缓存的metadata数据，并且消息的分区未定义或在已知分区范围内，则返回缓存的metadata数据</span></span><br><span class="line">    <span class="keyword">if</span> (partitionsCount != <span class="literal">null</span> &amp;&amp; (partition == <span class="literal">null</span> || partition &lt; partitionsCount))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClusterAndWaitTime</span>(cluster, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> time.milliseconds();</span><br><span class="line">    <span class="comment">// 剩余可用时间，默认值为maxWaitMs，最多可以等待时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">remainingWaitMs</span> <span class="operator">=</span> maxWaitMs;</span><br><span class="line">    <span class="type">long</span> elapsed;</span><br><span class="line">    <span class="comment">// Issue metadata requests until we have metadata for the topic or maxWaitTimeMs is exceeded.</span></span><br><span class="line">    <span class="comment">// In case we already have cached metadata for the topic, but the requested partition is greater</span></span><br><span class="line">    <span class="comment">// than expected, issue an update request only once. This is necessary in case the metadata</span></span><br><span class="line">    <span class="comment">// is stale and the number of partitions for this topic has increased in the meantime.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Requesting metadata update for topic &#123;&#125;.&quot;</span>, topic);</span><br><span class="line">        <span class="comment">// needUpdate设置为true，返回更新前的当前版本</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> metadata.requestUpdate();</span><br><span class="line">        <span class="comment">// 唤醒sender线程</span></span><br><span class="line">        sender.wakeup();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            metadata.awaitUpdate(version, remainingWaitMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException ex) &#123;</span><br><span class="line">            <span class="comment">// Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>(<span class="string">&quot;Failed to update metadata after &quot;</span> + maxWaitMs + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次获取集群的元数据信息</span></span><br><span class="line">        cluster = metadata.fetch();</span><br><span class="line">        <span class="comment">// 计算拉取metadata数据耗时</span></span><br><span class="line">        elapsed = time.milliseconds() - begin;</span><br><span class="line">        <span class="comment">// 如果拉取metadata数据耗时超过了最大阻塞时间，则抛出超时异常</span></span><br><span class="line">        <span class="keyword">if</span> (elapsed &gt;= maxWaitMs)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>(<span class="string">&quot;Failed to update metadata after &quot;</span> + maxWaitMs + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果获取到metadata数据，topic没有授权，则抛出TopicAuthorizationException</span></span><br><span class="line">        <span class="keyword">if</span> (cluster.unauthorizedTopics().contains(topic))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TopicAuthorizationException</span>(topic);</span><br><span class="line">        <span class="comment">// 计算剩余可用时间</span></span><br><span class="line">        remainingWaitMs = maxWaitMs - elapsed;</span><br><span class="line">        <span class="comment">// 如果topic的分区数量未知，则继续等待</span></span><br><span class="line">        partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">    &#125; <span class="keyword">while</span> (partitionsCount == <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (partition != <span class="literal">null</span> &amp;&amp; partition &gt;= partitionsCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KafkaException</span>(</span><br><span class="line">                String.format(<span class="string">&quot;Invalid partition given with record: %d is not in the range [0...%d).&quot;</span>, partition, partitionsCount));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回集群元数据和耗时时间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClusterAndWaitTime</span>(cluster, elapsed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Sender线程在run()方法死循环</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run a single iteration of sending</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now</span></span><br><span class="line"><span class="comment"> *            The current POSIX time in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前集群metadata信息</span></span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> metadata.fetch();</span><br><span class="line">    <span class="comment">// 获取已准备好发送数据的分区请求</span></span><br><span class="line">    RecordAccumulator.<span class="type">ReadyCheckResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.accumulator.ready(cluster, now);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有任何分区的 leader 尚不清楚，则强制元数据更新。第一次执行topic，不会走</span></span><br><span class="line">    <span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// The set of topics with unknown leader contains topics with leader election pending as well as</span></span><br><span class="line">        <span class="comment">// topics which may have expired. Add the topic again to metadata to ensure it is included</span></span><br><span class="line">        <span class="comment">// and request metadata update, since there are messages to send to the topic.</span></span><br><span class="line">        <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</span><br><span class="line">            <span class="built_in">this</span>.metadata.add(topic);</span><br><span class="line">        <span class="built_in">this</span>.metadata.requestUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断节点有没有准备好，并移除没有准备的节点</span></span><br><span class="line">    <span class="comment">// remove any nodes we aren&#x27;t ready to send to</span></span><br><span class="line">    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</span><br><span class="line">    <span class="type">long</span> <span class="variable">notReadyTimeout</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">            iter.remove();</span><br><span class="line">            notReadyTimeout = Math.min(notReadyTimeout, <span class="built_in">this</span>.client.connectionDelay(node, now));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建批次请求</span></span><br><span class="line">    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="built_in">this</span>.accumulator.drain(cluster,</span><br><span class="line">                                                                     result.readyNodes,</span><br><span class="line">                                                                     <span class="built_in">this</span>.maxRequestSize,</span><br><span class="line">                                                                     now);</span><br><span class="line">    <span class="comment">// 保证消息顺序，第一次执行guaranteeMessageOrder为false，不会走</span></span><br><span class="line">    <span class="keyword">if</span> (guaranteeMessageOrder) &#123;</span><br><span class="line">        <span class="comment">// Mute all the partitions drained</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (RecordBatch batch : batchList)</span><br><span class="line">                <span class="built_in">this</span>.accumulator.mutePartition(batch.topicPartition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查超时的批次，第一次执行没expiredBatches为空</span></span><br><span class="line">    List&lt;RecordBatch&gt; expiredBatches = <span class="built_in">this</span>.accumulator.abortExpiredBatches(<span class="built_in">this</span>.requestTimeout, now);</span><br><span class="line">    <span class="comment">// 更新超时批次的错误计数</span></span><br><span class="line">    <span class="keyword">for</span> (RecordBatch expiredBatch : expiredBatches)</span><br><span class="line">        <span class="built_in">this</span>.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);</span><br><span class="line">    </span><br><span class="line">    sensors.updateProduceRequestMetrics(batches);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If we have any nodes that are ready to send + have sendable data, poll with 0 timeout so this can immediately</span></span><br><span class="line">    <span class="comment">// loop and try sending more data. Otherwise, the timeout is determined by nodes that have partitions with data</span></span><br><span class="line">    <span class="comment">// that isn&#x27;t yet sendable (e.g. lingering, backing off). Note that this specifically does not include nodes</span></span><br><span class="line">    <span class="comment">// with sendable data that aren&#x27;t ready to send since they would cause busy looping.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">pollTimeout</span> <span class="operator">=</span> Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</span><br><span class="line">    <span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Nodes with data ready to send: &#123;&#125;&quot;</span>, result.readyNodes);</span><br><span class="line">        <span class="comment">// 如果有已经准备好的节点，超时间隔为0，立即发送请求</span></span><br><span class="line">        pollTimeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备待发送请求的数据</span></span><br><span class="line">    sendProduceRequests(batches, now);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行网络请求</span></span><br><span class="line">    <span class="comment">// if some partitions are already ready to be sent, the select time would be 0;</span></span><br><span class="line">    <span class="comment">// otherwise if some partition already has some data accumulated but not ready yet,</span></span><br><span class="line">    <span class="comment">// the select time will be the time difference between now and its linger expiry time;</span></span><br><span class="line">    <span class="comment">// otherwise the select time will be the time difference between now and the metadata expiry time;</span></span><br><span class="line">    <span class="built_in">this</span>.client.poll(pollTimeout, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取已准备好发送数据的分区请求ready</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReadyCheckResult <span class="title function_">ready</span><span class="params">(Cluster cluster, <span class="type">long</span> nowMs)</span> &#123;</span><br><span class="line">    Set&lt;Node&gt; readyNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nextReadyCheckDelayMs</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    Set&lt;String&gt; unknownLeaderTopics = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存已经耗尽，并且线程阻塞等待buffer，则所有partition都可以发送</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exhausted</span> <span class="operator">=</span> <span class="built_in">this</span>.free.queued() &gt; <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有队列，获取每个partition的leader节点，如果leader节点不存在，则说明该partition的leader节点未知，</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; entry : <span class="built_in">this</span>.batches.entrySet()) &#123;</span><br><span class="line">        <span class="type">TopicPartition</span> <span class="variable">part</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        Deque&lt;RecordBatch&gt; deque = entry.getValue();</span><br><span class="line">    </span><br><span class="line">        <span class="type">Node</span> <span class="variable">leader</span> <span class="operator">=</span> cluster.leaderFor(part);</span><br><span class="line">        <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="literal">null</span> &amp;&amp; !deque.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// This is a partition for which leader is not known, but messages are available to send.</span></span><br><span class="line">                <span class="comment">// Note that entries are currently not removed from batches when deque is empty.</span></span><br><span class="line">                unknownLeaderTopics.add(part.topic());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!readyNodes.contains(leader) &amp;&amp; !muted.contains(part)) &#123;</span><br><span class="line">                <span class="comment">// 从队列头部获取第一个批次，如果批不为null，则判断是否可以发送，如果可以发送，则添加到readyNodes集合中</span></span><br><span class="line">                <span class="type">RecordBatch</span> <span class="variable">batch</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line">                <span class="keyword">if</span> (batch != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * batch.attempts重试的次数</span></span><br><span class="line"><span class="comment">                     * batch.lastAttemptMs上次重试的时间</span></span><br><span class="line"><span class="comment">                     * batch.retryBackoffMs重试的间隔时间</span></span><br><span class="line"><span class="comment">                     * nowMs当前时间</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">backingOff</span> <span class="operator">=</span> batch.attempts &gt; <span class="number">0</span> &amp;&amp; batch.lastAttemptMs + retryBackoffMs &gt; nowMs;</span><br><span class="line">                    <span class="comment">// waitedTimeMs（已经等待的时间） = nowMs当前时间 - batch.lastAttemptMs上次重试的时间</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">waitedTimeMs</span> <span class="operator">=</span> nowMs - batch.lastAttemptMs;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// timeToWaitMs最多等待的时间 = backingOff是否处于重试状态？重试间隔时间：lingerMs等待时间，默认为：0</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">timeToWaitMs</span> <span class="operator">=</span> backingOff ? retryBackoffMs : lingerMs;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// timeLeftMs剩余等待的时间 = timeToWaitMs（最多等待的时间） - waitedTimeMs（已经等待的时间）</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">timeLeftMs</span> <span class="operator">=</span> Math.max(timeToWaitMs - waitedTimeMs, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">//full是否已满 = 队列中有多个批次 || 当前批次已满</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">full</span> <span class="operator">=</span> deque.size() &gt; <span class="number">1</span> || batch.isFull();</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// expired是否已过期 = waitedTimeMs（已经等待的时间） &gt;= timeToWaitMs（最多等待的时间）</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">expired</span> <span class="operator">=</span> waitedTimeMs &gt;= timeToWaitMs;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// sendable是否可以发送 = 队列中有多个批次或者当前批次已满 || 等待时间已过 || 内存耗尽 || 关闭 || 正在flush</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">sendable</span> <span class="operator">=</span> full || expired || exhausted || closed || flushInProgress();</span><br><span class="line">                    <span class="keyword">if</span> (sendable &amp;&amp; !backingOff) &#123;</span><br><span class="line">                        readyNodes.add(leader);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Note that this results in a conservative estimate since an un-sendable partition may have</span></span><br><span class="line">                        <span class="comment">// a leader that will later be found to have sendable data. However, this is good enough</span></span><br><span class="line">                        <span class="comment">// since we&#x27;ll just wake up and then sleep again for the remaining time.</span></span><br><span class="line">                        nextReadyCheckDelayMs = Math.min(timeLeftMs, nextReadyCheckDelayMs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReadyCheckResult</span>(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断节点有没有准备好，并移除没有准备的节点</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 判断节点有没有准备好，并移除没有准备的节点</span></span><br><span class="line">    <span class="comment">// remove any nodes we aren&#x27;t ready to send to</span></span><br><span class="line">    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</span><br><span class="line">    <span class="type">long</span> <span class="variable">notReadyTimeout</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">            iter.remove();</span><br><span class="line">            notReadyTimeout = Math.min(notReadyTimeout, <span class="built_in">this</span>.client.connectionDelay(node, now));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Begin connecting to the given node, return true if we are already connected and ready to send to that node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node The node to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now The current timestamp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if we are ready to send to the given node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">ready</span><span class="params">(Node node, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot connect to empty node &quot;</span> + node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isReady(node, now))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (connectionStates.canConnect(node.idString(), now))</span><br><span class="line">        <span class="comment">// 初始化网络连接</span></span><br><span class="line">        initiateConnect(node, now);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化连接，如果连接失败，则会尝试重试。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initiateConnect</span><span class="params">(Node node, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">nodeConnectionId</span> <span class="operator">=</span> node.idString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Initiating connection to node &#123;&#125; at &#123;&#125;:&#123;&#125;.&quot;</span>, node.id(), node.host(), node.port());</span><br><span class="line">        <span class="comment">// 修改状态为正在连接</span></span><br><span class="line">        <span class="built_in">this</span>.connectionStates.connecting(nodeConnectionId, now);</span><br><span class="line">        <span class="comment">// 尝试连接</span></span><br><span class="line">        selector.connect(nodeConnectionId,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(node.host(), node.port()),</span><br><span class="line">                         <span class="built_in">this</span>.socketSendBuffer,</span><br><span class="line">                         <span class="built_in">this</span>.socketReceiveBuffer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">/* attempt failed, we&#x27;ll try again after the backoff */</span></span><br><span class="line">        connectionStates.disconnected(nodeConnectionId, now);</span><br><span class="line">        <span class="comment">/* maybe the problem is our metadata, update it */</span></span><br><span class="line">        metadataUpdater.requestUpdate();</span><br><span class="line">        log.debug(<span class="string">&quot;Error connecting to node &#123;&#125; at &#123;&#125;:&#123;&#125;:&quot;</span>, node.id(), node.host(), node.port(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String id, InetSocketAddress address, <span class="type">int</span> sendBufferSize, <span class="type">int</span> receiveBufferSize)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channels.containsKey(id))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;There is already a connection for id &quot;</span> + id);</span><br><span class="line">    <span class="comment">// 获取SocketChannel.open()</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">    <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 获取socket</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> socketChannel.socket();</span><br><span class="line">    socket.setKeepAlive(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置发送缓冲区大小、接收缓冲区大小</span></span><br><span class="line">    <span class="keyword">if</span> (sendBufferSize != Selectable.USE_DEFAULT_BUFFER_SIZE)</span><br><span class="line">        socket.setSendBufferSize(sendBufferSize);</span><br><span class="line">    <span class="keyword">if</span> (receiveBufferSize != Selectable.USE_DEFAULT_BUFFER_SIZE)</span><br><span class="line">        socket.setReceiveBufferSize(receiveBufferSize);</span><br><span class="line">    <span class="comment">// 设置TcpNoDelay属性为true，用于控制 TCP 连接中数据包的发送方式。</span></span><br><span class="line">    <span class="comment">// 默认情况下，TCP 使用 Nagle 算法 来减少网络中的小数据包数量，从而提高网络利用率。</span></span><br><span class="line">    <span class="comment">// 然而，这种方式可能会增加延迟，特别是在需要快速响应的应用中</span></span><br><span class="line">    socket.setTcpNoDelay(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">boolean</span> connected;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试连接服务器，有可能连接成功：true，也有可能连接失败:false</span></span><br><span class="line">        connected = socketChannel.connect(address);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnresolvedAddressException e) &#123;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Can&#x27;t resolve address: &quot;</span> + address, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SocketChannel.register()注册到Selector，并设置OP_CONNECT事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> socketChannel.register(nioSelector, SelectionKey.OP_CONNECT);</span><br><span class="line">    KafkaChannel channel;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据SocketChannel创建KafkaChannel</span></span><br><span class="line">        channel = channelBuilder.buildChannel(id, key, maxReceiveSize);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            key.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Channel could not be created for socket &quot;</span> + socketChannel, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把key和channel绑定，并设置附件为channel</span></span><br><span class="line">    key.attach(channel);</span><br><span class="line">    <span class="comment">// 缓存channel</span></span><br><span class="line">    <span class="built_in">this</span>.channels.put(id, channel);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (connected) &#123;</span><br><span class="line">        <span class="comment">// OP_CONNECT won&#x27;t trigger for immediately connected channels</span></span><br><span class="line">        log.debug(<span class="string">&quot;Immediately connected to node &#123;&#125;&quot;</span>, channel.id());</span><br><span class="line">        immediatelyConnectedKeys.add(key);</span><br><span class="line">        <span class="comment">// 取消前面注册的OP_CONNECT事件</span></span><br><span class="line">        key.interestOps(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建批次请求</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建批次请求</span></span><br><span class="line">Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="built_in">this</span>.accumulator.drain(cluster,</span><br><span class="line">                                                                 result.readyNodes,</span><br><span class="line">                                                                 <span class="built_in">this</span>.maxRequestSize,</span><br><span class="line">                                                                 now);</span><br><span class="line">                                                                     </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现按照NodeId进行分组，把相同NodeId的batch分到一组中，返回Map&lt;NodeId, List&lt;RecordBatch&gt;&gt;</span></span><br><span class="line"><span class="comment"> * Drain all the data for the given nodes and collate them into a list of batches that will fit within the specified</span></span><br><span class="line"><span class="comment"> * size on a per-node basis. This method attempts to avoid choosing the same topic-node over and over.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cluster The current cluster metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes The list of node to drain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxSize The maximum number of bytes to drain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now The current unix time in milliseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A list of &#123;<span class="doctag">@link</span> RecordBatch&#125; for each node specified with total size less than the requested maxSize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, List&lt;RecordBatch&gt;&gt; <span class="title function_">drain</span><span class="params">(Cluster cluster,</span></span><br><span class="line"><span class="params">                                             Set&lt;Node&gt; nodes,</span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> maxSize,</span></span><br><span class="line"><span class="params">                                             <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    </span><br><span class="line">    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;PartitionInfo&gt; parts = cluster.partitionsForNode(node.id());</span><br><span class="line">        List&lt;RecordBatch&gt; ready = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/* to make starvation less likely this loop doesn&#x27;t start at 0 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> drainIndex = drainIndex % parts.size();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">PartitionInfo</span> <span class="variable">part</span> <span class="operator">=</span> parts.get(drainIndex);</span><br><span class="line">            <span class="type">TopicPartition</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(part.topic(), part.partition());</span><br><span class="line">            <span class="comment">// Only proceed if the partition has no in-flight batches.</span></span><br><span class="line">            <span class="keyword">if</span> (!muted.contains(tp)) &#123;</span><br><span class="line">                Deque&lt;RecordBatch&gt; deque = getDeque(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(part.topic(), part.partition()));</span><br><span class="line">                <span class="keyword">if</span> (deque != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">                        <span class="type">RecordBatch</span> <span class="variable">first</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line">                        <span class="keyword">if</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">backoff</span> <span class="operator">=</span> first.attempts &gt; <span class="number">0</span> &amp;&amp; first.lastAttemptMs + retryBackoffMs &gt; now;</span><br><span class="line">                            <span class="comment">// Only drain the batch if it is not during backoff period.</span></span><br><span class="line">                            <span class="keyword">if</span> (!backoff) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (size + first.sizeInBytes() &gt; maxSize &amp;&amp; !ready.isEmpty()) &#123;</span><br><span class="line">                                    <span class="comment">// there is a rare case that a single batch size is larger than the request size due</span></span><br><span class="line">                                    <span class="comment">// to compression; in this case we will still eventually send this batch in a single</span></span><br><span class="line">                                    <span class="comment">// request</span></span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="type">RecordBatch</span> <span class="variable">batch</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">                                    batch.close();</span><br><span class="line">                                    size += batch.sizeInBytes();</span><br><span class="line">                                    ready.add(batch);</span><br><span class="line">                                    batch.drainedMs = now;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.drainIndex = (<span class="built_in">this</span>.drainIndex + <span class="number">1</span>) % parts.size();</span><br><span class="line">        &#125; <span class="keyword">while</span> (start != drainIndex);</span><br><span class="line">        batches.put(node.id(), ready);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> batches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行网络请求</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do actual reads and writes to sockets.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout The maximum amount of time to wait (in ms) for responses if there are none immediately,</span></span><br><span class="line"><span class="comment"> *                must be non-negative. The actual timeout will be the minimum of timeout, request timeout and</span></span><br><span class="line"><span class="comment"> *                metadata timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now The current time in milliseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The list of responses received</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">// 封装要拉取元数据的请求</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">metadataTimeout</span> <span class="operator">=</span> metadataUpdater.maybeUpdate(now);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error during I/O&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理已完成请求的操作</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">updatedNow</span> <span class="operator">=</span> <span class="built_in">this</span>.time.milliseconds();</span><br><span class="line">    List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    handleAbortedSends(responses);</span><br><span class="line">    handleCompletedSends(responses, updatedNow);</span><br><span class="line">    handleCompletedReceives(responses, updatedNow);</span><br><span class="line">    handleDisconnections(responses, updatedNow);</span><br><span class="line">    handleConnections();</span><br><span class="line">    handleInitiateApiVersionRequests(updatedNow);</span><br><span class="line">    handleTimedOutRequests(responses, updatedNow);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// invoke callbacks</span></span><br><span class="line">    <span class="keyword">for</span> (ClientResponse response : responses) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.onComplete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Uncaught error in request completion:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新元数据信息</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maybeUpdate</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">     <span class="comment">// 是否要更新metadata信息，当Producer线程把needUpdate设置为true时，说明需要更新metadata信息</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">timeToNextMetadataUpdate</span> <span class="operator">=</span> metadata.timeToNextUpdate(now);</span><br><span class="line">     <span class="type">long</span> <span class="variable">waitForMetadataFetch</span> <span class="operator">=</span> <span class="built_in">this</span>.metadataFetchInProgress ? requestTimeoutMs : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="type">long</span> <span class="variable">metadataTimeout</span> <span class="operator">=</span> Math.max(timeToNextMetadataUpdate, waitForMetadataFetch);</span><br><span class="line">     <span class="keyword">if</span> (metadataTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> metadataTimeout;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// Beware that the behavior of this method and the computation of timeouts for poll() are</span></span><br><span class="line">     <span class="comment">// highly dependent on the behavior of leastLoadedNode.</span></span><br><span class="line">     <span class="comment">// 获取请求最少的Node节点</span></span><br><span class="line">     <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> leastLoadedNode(now);</span><br><span class="line">     <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;Give up sending metadata request since no node is available&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> maybeUpdate(now, node);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Add a metadata request to the list of sends if we can make one</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">maybeUpdate</span><span class="params">(<span class="type">long</span> now, Node node)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">nodeConnectionId</span> <span class="operator">=</span> node.idString();</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span> (canSendRequest(nodeConnectionId)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.metadataFetchInProgress = <span class="literal">true</span>;</span><br><span class="line">         MetadataRequest.Builder metadataRequest;</span><br><span class="line">         <span class="keyword">if</span> (metadata.needMetadataForAllTopics())</span><br><span class="line">             metadataRequest = MetadataRequest.Builder.allTopics();</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             metadataRequest = <span class="keyword">new</span> <span class="title class_">MetadataRequest</span>.Builder(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(metadata.topics()));</span><br><span class="line">    </span><br><span class="line">         log.debug(<span class="string">&quot;Sending metadata request &#123;&#125; to node &#123;&#125;&quot;</span>, metadataRequest, node.id());</span><br><span class="line">         sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now);</span><br><span class="line">         <span class="keyword">return</span> requestTimeoutMs;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// If there&#x27;s any connection establishment underway, wait until it completes. This prevents</span></span><br><span class="line">     <span class="comment">// the client from unnecessarily connecting to additional nodes while a previous connection</span></span><br><span class="line">     <span class="comment">// attempt has not been completed.</span></span><br><span class="line">     <span class="keyword">if</span> (isAnyNodeConnecting()) &#123;</span><br><span class="line">         <span class="comment">// Strictly the timeout we should return here is &quot;connect timeout&quot;, but as we don&#x27;t</span></span><br><span class="line">         <span class="comment">// have such application level configuration, using reconnect backoff instead.</span></span><br><span class="line">         <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span> (connectionStates.canConnect(nodeConnectionId, now)) &#123;</span><br><span class="line">         <span class="comment">// we don&#x27;t have a connection to this node right now, make one</span></span><br><span class="line">         log.debug(<span class="string">&quot;Initialize connection to node &#123;&#125; for sending metadata request&quot;</span>, node.id());</span><br><span class="line">         initiateConnect(node, now);</span><br><span class="line">         <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// connected, but can&#x27;t send more OR connecting</span></span><br><span class="line">     <span class="comment">// In either case, we just need to wait for a network event to let us know the selected</span></span><br><span class="line">     <span class="comment">// connection might be usable again.</span></span><br><span class="line">     <span class="keyword">return</span> Long.MAX_VALUE;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li><p>发送Meatadata元数据请求</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendInternalMetadataRequest</span><span class="params">(MetadataRequest.Builder builder,</span></span><br><span class="line"><span class="params">                                          String nodeConnectionId, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">     <span class="type">ClientRequest</span> <span class="variable">clientRequest</span> <span class="operator">=</span> newClientRequest(nodeConnectionId, builder, now, <span class="literal">true</span>);</span><br><span class="line">     doSend(clientRequest, <span class="literal">true</span>, now);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSend</span><span class="params">(ClientRequest clientRequest, <span class="type">boolean</span> isInternalRequest, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">nodeId</span> <span class="operator">=</span> clientRequest.destination();</span><br><span class="line">     <span class="keyword">if</span> (!isInternalRequest) &#123;</span><br><span class="line">         <span class="comment">// If this request came from outside the NetworkClient, validate</span></span><br><span class="line">         <span class="comment">// that we can send data.  If the request is internal, we trust</span></span><br><span class="line">         <span class="comment">// that that internal code has done this validation.  Validation</span></span><br><span class="line">         <span class="comment">// will be slightly different for some internal requests (for</span></span><br><span class="line">         <span class="comment">// example, ApiVersionsRequests can be sent prior to being in</span></span><br><span class="line">         <span class="comment">// READY state.)</span></span><br><span class="line">         <span class="keyword">if</span> (!canSendRequest(nodeId))</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Attempt to send a request to node &quot;</span> + nodeId + <span class="string">&quot; which is not ready.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">AbstractRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     AbstractRequest.Builder&lt;?&gt; builder = clientRequest.requestBuilder();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">NodeApiVersions</span> <span class="variable">versionInfo</span> <span class="operator">=</span> nodeApiVersions.get(nodeId);</span><br><span class="line">         <span class="comment">// Note: if versionInfo is null, we have no server version information. This would be</span></span><br><span class="line">         <span class="comment">// the case when sending the initial ApiVersionRequest which fetches the version</span></span><br><span class="line">         <span class="comment">// information itself.  It is also the case when discoverBrokerVersions is set to false.</span></span><br><span class="line">         <span class="keyword">if</span> (versionInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (discoverBrokerVersions &amp;&amp; log.isTraceEnabled())</span><br><span class="line">                 log.trace(<span class="string">&quot;No version information found when sending message of type &#123;&#125; to node &#123;&#125;. &quot;</span> +</span><br><span class="line">                         <span class="string">&quot;Assuming version &#123;&#125;.&quot;</span>, clientRequest.apiKey(), nodeId, builder.version());</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="type">short</span> <span class="variable">version</span> <span class="operator">=</span> versionInfo.usableVersion(clientRequest.apiKey());</span><br><span class="line">             builder.setVersion(version);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// The call to build may also throw UnsupportedVersionException, if there are essential</span></span><br><span class="line">         <span class="comment">// fields that cannot be represented in the chosen version.</span></span><br><span class="line">         request = builder.build();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (UnsupportedVersionException e) &#123;</span><br><span class="line">         <span class="comment">// If the version is not supported, skip sending the request over the wire.</span></span><br><span class="line">         <span class="comment">// Instead, simply add it to the local queue of aborted requests.</span></span><br><span class="line">         log.debug(<span class="string">&quot;Version mismatch when attempting to send &#123;&#125; to &#123;&#125;&quot;</span>,</span><br><span class="line">                 clientRequest.toString(), clientRequest.destination(), e);</span><br><span class="line">         <span class="type">ClientResponse</span> <span class="variable">clientResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientResponse</span>(clientRequest.makeHeader(),</span><br><span class="line">                 clientRequest.callback(), clientRequest.destination(), now, now,</span><br><span class="line">                 <span class="literal">false</span>, e, <span class="literal">null</span>);</span><br><span class="line">         abortedSends.add(clientResponse);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">RequestHeader</span> <span class="variable">header</span> <span class="operator">=</span> clientRequest.makeHeader();</span><br><span class="line">     <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">latestClientVersion</span> <span class="operator">=</span> ProtoUtils.latestVersion(clientRequest.apiKey().id);</span><br><span class="line">         <span class="keyword">if</span> (header.apiVersion() == latestClientVersion) &#123;</span><br><span class="line">             log.trace(<span class="string">&quot;Sending &#123;&#125; to node &#123;&#125;.&quot;</span>, request, nodeId);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;Using older server API v&#123;&#125; to send &#123;&#125; to node &#123;&#125;.&quot;</span>,</span><br><span class="line">                 header.apiVersion(), request, nodeId);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Send</span> <span class="variable">send</span> <span class="operator">=</span> request.toSend(nodeId, header);</span><br><span class="line">     <span class="type">InFlightRequest</span> <span class="variable">inFlightRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InFlightRequest</span>(</span><br><span class="line">             header,</span><br><span class="line">             clientRequest.createdTimeMs(),</span><br><span class="line">             clientRequest.destination(),</span><br><span class="line">             clientRequest.callback(),</span><br><span class="line">             clientRequest.expectResponse(),</span><br><span class="line">             isInternalRequest,</span><br><span class="line">             send,</span><br><span class="line">             now);</span><br><span class="line">     <span class="built_in">this</span>.inFlightRequests.add(inFlightRequest);</span><br><span class="line">     selector.send(inFlightRequest.send);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Queue the given request for sending in the subsequent &#123;<span class="doctag">@link</span> #poll(long)&#125; calls</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> send The request to send</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Send send)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">connectionId</span> <span class="operator">=</span> send.destination();</span><br><span class="line">     <span class="keyword">if</span> (closingChannels.containsKey(connectionId))</span><br><span class="line">         <span class="built_in">this</span>.failedSends.add(connectionId);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="type">KafkaChannel</span> <span class="variable">channel</span> <span class="operator">=</span> channelOrFail(connectionId, <span class="literal">false</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             channel.setSend(send);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">             <span class="built_in">this</span>.failedSends.add(connectionId);</span><br><span class="line">             close(channel, <span class="literal">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSend</span><span class="params">(Send send)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">this</span>.send != <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Attempt to begin a send operation with prior send operation still in progress.&quot;</span>);</span><br><span class="line">     <span class="built_in">this</span>.send = send;</span><br><span class="line">     <span class="built_in">this</span>.transportLayer.addInterestOps(SelectionKey.OP_WRITE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Kafka/" rel="tag"># Kafka</a>
              <a href="/tags/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># Kafka源码分析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)Sender%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96metadata%E6%95%B0%E6%8D%AE/" rel="prev" title="Kafka源码分析(三)Sender线程获取metadata数据">
                  <i class="fa fa-angle-left"></i> Kafka源码分析(三)Sender线程获取metadata数据
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Panda Yuan</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
