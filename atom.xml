<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  
  
  <link href="https://yuanxw.github.io/atom.xml" rel="self"/>
  
  <link href="https://yuanxw.github.io/"/>
  <updated>2025-09-03T15:22:51.570Z</updated>
  <id>https://yuanxw.github.io/</id>
  
  <author>
    <name>Panda Yuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM虚拟机详解(十四)**垃圾回收相关概念</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E5%9B%9B)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E5%9B%9B)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2023-02-13T16:00:00.000Z</published>
    <updated>2025-09-03T15:22:51.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-十四-垃圾回收相关概念"><a href="#JVM虚拟机详解-十四-垃圾回收相关概念" class="headerlink" title="JVM虚拟机详解(十四)垃圾回收相关概念"></a>JVM虚拟机详解(十四)<strong>垃圾回收相关概念</strong></h2><h3 id="1-System-gc"><a href="#1-System-gc" class="headerlink" title="1. System.gc()"></a>1. <strong>System.gc()</strong></h3><ul><li><p><strong>理解</strong></p><ul><li><p>在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p></li><li><p>JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()代码演示是否出发GC操作</p></li><li><p>代码演示是否出发GC操作</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.gc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * System.gc()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-03-07 10:41:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGC</span>();</span><br><span class="line">        <span class="comment">// 提醒JVM进行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 强制调用 失去引用对象的finalize()</span></span><br><span class="line">        <span class="comment">//System.runFinalization();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;...SystemGC.finalize()方法被执行!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...SystemGC.finalize()方法被执行!!!</span><br></pre></td></tr></table></figure></li><li><p><strong>手动GC来理解不可达对象的回收</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.gc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加上参数：  -XX:+PrintGCDetails -Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-03-07 10:53:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesGC</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//10MB</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  触发YoungGC的时候，已经被回收了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不会被回收，因为它还存放在局部变量表索引为1的槽中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * localvarGC5中的数组已经被回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC5</span><span class="params">()</span> &#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesGC</span>();</span><br><span class="line">        <span class="comment">// 通过在main方法调用这几个方法进行测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;...LocalVariablesGC.localvarGC-1()&quot;</span>);</span><br><span class="line">        local.localvarGC1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;...LocalVariablesGC.localvarGC-2()&quot;);</span></span><br><span class="line"><span class="comment">//        local.localvarGC2();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;...LocalVariablesGC.localvarGC-3()&quot;);</span></span><br><span class="line"><span class="comment">//        local.localvarGC3();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;...LocalVariablesGC.localvarGC-4()&quot;);</span></span><br><span class="line"><span class="comment">//        local.localvarGC4();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;...LocalVariablesGC.localvarGC-5()&quot;);</span></span><br><span class="line"><span class="comment">//        local.localvarGC5();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行结果：</p><ul><li>执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收</li></ul>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...LocalVariablesGC.localvarGC<span class="literal">-1</span>()</span><br><span class="line">**[<span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">10728</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">10976</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), <span class="number">0.0052388</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br><span class="line">[<span class="type">Full</span> <span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">10728</span><span class="type">K</span>-&gt;<span class="number">0</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] [<span class="type">ParOldGen</span>: <span class="number">248</span><span class="type">K</span>-&gt;<span class="number">10868</span><span class="type">K</span>(<span class="number">175104</span><span class="type">K</span>)] <span class="number">10976</span><span class="type">K</span>-&gt;<span class="number">10868</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), [<span class="type">Metaspace</span>: <span class="number">3228</span><span class="type">K</span>-&gt;<span class="number">3228</span><span class="type">K</span>(<span class="number">1056768</span><span class="type">K</span>)], <span class="number">0.0040694</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.02</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>]** </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">76288</span>K, used <span class="number">655</span>K [<span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line">  <span class="type">eden</span> <span class="type">space</span> <span class="number">65536</span><span class="type">K</span>, <span class="number">1</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000fab00000</span>,<span class="number">0</span><span class="type">x00000000faba3ee8</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>)</span><br><span class="line">  <span class="type">from</span> <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>)</span><br><span class="line">  <span class="type">to</span>   <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line"> <span class="type">ParOldGen</span>       <span class="type">total</span> <span class="number">175104</span><span class="type">K</span>, <span class="type">used</span> <span class="number">10868</span><span class="type">K</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line">  <span class="type">object</span> <span class="type">space</span> <span class="number">175104</span><span class="type">K</span>, <span class="number">6</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>,<span class="number">0</span><span class="type">x00000000f0a9d270</span>,<span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line"> <span class="type">Metaspace</span>       <span class="type">used</span> <span class="number">3235</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">4500</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">4864</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1056768</span><span class="type">K</span></span><br><span class="line">  <span class="type">class</span> <span class="type">space</span>    <span class="type">used</span> <span class="number">350</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">388</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">512</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1048576</span><span class="type">K</span></span><br></pre></td></tr></table></figure><ul><li>由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收</li></ul>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...LocalVariablesGC.localvarGC<span class="literal">-2</span>()</span><br><span class="line">**[<span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">840</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">848</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), <span class="number">0.0007219</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br><span class="line">[<span class="type">Full</span> <span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">840</span><span class="type">K</span>-&gt;<span class="number">0</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] [<span class="type">ParOldGen</span>: <span class="number">8</span><span class="type">K</span>-&gt;<span class="number">628</span><span class="type">K</span>(<span class="number">175104</span><span class="type">K</span>)] <span class="number">848</span><span class="type">K</span>-&gt;<span class="number">628</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), [<span class="type">Metaspace</span>: <span class="number">3229</span><span class="type">K</span>-&gt;<span class="number">3229</span><span class="type">K</span>(<span class="number">1056768</span><span class="type">K</span>)], <span class="number">0.0034734</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>]** </span><br><span class="line">Heap</span><br><span class="line"></span><br><span class="line"> PSYoungGen      total <span class="number">76288</span>K, used <span class="number">655</span>K [<span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line">  <span class="type">eden</span> <span class="type">space</span> <span class="number">65536</span><span class="type">K</span>, <span class="number">1</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000fab00000</span>,<span class="number">0</span><span class="type">x00000000faba3ee8</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>)</span><br><span class="line">  <span class="type">from</span> <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>)</span><br><span class="line">  <span class="type">to</span>   <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line"> <span class="type">ParOldGen</span>       <span class="type">total</span> <span class="number">175104</span><span class="type">K</span>, <span class="type">used</span> <span class="number">628</span><span class="type">K</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line">  <span class="type">object</span> <span class="type">space</span> <span class="number">175104</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>,<span class="number">0</span><span class="type">x00000000f009d260</span>,<span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line"> <span class="type">Metaspace</span>       <span class="type">used</span> <span class="number">3235</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">4500</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">4864</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1056768</span><span class="type">K</span></span><br><span class="line">  <span class="type">class</span> <span class="type">space</span>    <span class="type">used</span> <span class="number">350</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">388</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">512</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1048576</span><span class="type">K</span></span><br></pre></td></tr></table></figure><ul><li>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收</li></ul>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...LocalVariablesGC.localvarGC<span class="literal">-3</span>()</span><br><span class="line">**[<span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">10736</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">10976</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), <span class="number">0.0051980</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.01</span> <span class="type">secs</span>] </span><br><span class="line">[<span class="type">Full</span> <span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">10736</span><span class="type">K</span>-&gt;<span class="number">0</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] [<span class="type">ParOldGen</span>: <span class="number">240</span><span class="type">K</span>-&gt;<span class="number">10868</span><span class="type">K</span>(<span class="number">175104</span><span class="type">K</span>)] <span class="number">10976</span><span class="type">K</span>-&gt;<span class="number">10868</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), [<span class="type">Metaspace</span>: <span class="number">3229</span><span class="type">K</span>-&gt;<span class="number">3229</span><span class="type">K</span>(<span class="number">1056768</span><span class="type">K</span>)], <span class="number">0.0039932</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.05</span> <span class="type">sys</span>=<span class="number">0.06</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>]** </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">76288</span>K, used <span class="number">655</span>K [<span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line">  <span class="type">eden</span> <span class="type">space</span> <span class="number">65536</span><span class="type">K</span>, <span class="number">1</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000fab00000</span>,<span class="number">0</span><span class="type">x00000000faba3ee8</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>)</span><br><span class="line">  <span class="type">from</span> <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>)</span><br><span class="line">  <span class="type">to</span>   <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line"> <span class="type">ParOldGen</span>       <span class="type">total</span> <span class="number">175104</span><span class="type">K</span>, <span class="type">used</span> <span class="number">10868</span><span class="type">K</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line">  <span class="type">object</span> <span class="type">space</span> <span class="number">175104</span><span class="type">K</span>, <span class="number">6</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>,<span class="number">0</span><span class="type">x00000000f0a9d270</span>,<span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line"> <span class="type">Metaspace</span>       <span class="type">used</span> <span class="number">3235</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">4500</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">4864</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1056768</span><span class="type">K</span></span><br><span class="line">  <span class="type">class</span> <span class="type">space</span>    <span class="type">used</span> <span class="number">350</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">388</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">512</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1048576</span><span class="type">K</span></span><br></pre></td></tr></table></figure><ul><li><p>1、来看看字节码：实例方法局部变量表第一个变量肯定是 this</p><p>  Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p><p>  A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看，value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向<code>new byte[10 * 1024 * 1024]</code>实例了。</p></li><li><p>局部变量除了方法范围就是失效了，堆中的字节数组铁定被回收</p></li></ul>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...LocalVariablesGC.localvarGC<span class="literal">-5</span>()</span><br><span class="line">[<span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">10728</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">10944</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), <span class="number">0.0050946</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.01</span> <span class="type">secs</span>] </span><br><span class="line">[<span class="type">Full</span> <span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">10728</span><span class="type">K</span>-&gt;<span class="number">0</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] [<span class="type">ParOldGen</span>: <span class="number">216</span><span class="type">K</span>-&gt;<span class="number">10868</span><span class="type">K</span>(<span class="number">175104</span><span class="type">K</span>)] <span class="number">10944</span><span class="type">K</span>-&gt;<span class="number">10868</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), [<span class="type">Metaspace</span>: <span class="number">3229</span><span class="type">K</span>-&gt;<span class="number">3229</span><span class="type">K</span>(<span class="number">1056768</span><span class="type">K</span>)], <span class="number">0.0043706</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.13</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br><span class="line">[<span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">0</span><span class="type">K</span>-&gt;<span class="number">0</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] <span class="number">10868</span><span class="type">K</span>-&gt;<span class="number">10868</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), <span class="number">0.0002125</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br><span class="line">[<span class="type">Full</span> <span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">0</span><span class="type">K</span>-&gt;<span class="number">0</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] [<span class="type">ParOldGen</span>: <span class="number">10868</span><span class="type">K</span>-&gt;<span class="number">628</span><span class="type">K</span>(<span class="number">175104</span><span class="type">K</span>)] <span class="number">10868</span><span class="type">K</span>-&gt;<span class="number">628</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), [<span class="type">Metaspace</span>: <span class="number">3229</span><span class="type">K</span>-&gt;<span class="number">3229</span><span class="type">K</span>(<span class="number">1056768</span><span class="type">K</span>)], <span class="number">0.0042302</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">76288</span>K, used <span class="number">655</span>K [<span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line">  <span class="type">eden</span> <span class="type">space</span> <span class="number">65536</span><span class="type">K</span>, <span class="number">1</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000fab00000</span>,<span class="number">0</span><span class="type">x00000000faba3ee8</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>)</span><br><span class="line">  <span class="type">from</span> <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line">  <span class="type">to</span>   <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>)</span><br><span class="line"> <span class="type">ParOldGen</span>       <span class="type">total</span> <span class="number">175104</span><span class="type">K</span>, <span class="type">used</span> <span class="number">628</span><span class="type">K</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line">  <span class="type">object</span> <span class="type">space</span> <span class="number">175104</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>,<span class="number">0</span><span class="type">x00000000f009d260</span>,<span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line"> <span class="type">Metaspace</span>       <span class="type">used</span> <span class="number">3235</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">4500</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">4864</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1056768</span><span class="type">K</span></span><br><span class="line">  <span class="type">class</span> <span class="type">space</span>    <span class="type">used</span> <span class="number">350</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">388</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">512</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1048576</span><span class="type">K</span></span><br></pre></td></tr></table></figure>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...LocalVariablesGC.localvarGC<span class="literal">-4</span>()</span><br><span class="line">[<span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">840</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] <span class="number">15483</span><span class="type">K</span>-&gt;<span class="number">848</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), <span class="number">0.0007100</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br><span class="line">[<span class="type">Full</span> <span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">840</span><span class="type">K</span>-&gt;<span class="number">0</span><span class="type">K</span>(<span class="number">76288</span><span class="type">K</span>)] [<span class="type">ParOldGen</span>: <span class="number">8</span><span class="type">K</span>-&gt;<span class="number">628</span><span class="type">K</span>(<span class="number">175104</span><span class="type">K</span>)] <span class="number">848</span><span class="type">K</span>-&gt;<span class="number">628</span><span class="type">K</span>(<span class="number">251392</span><span class="type">K</span>), [<span class="type">Metaspace</span>: <span class="number">3229</span><span class="type">K</span>-&gt;<span class="number">3229</span><span class="type">K</span>(<span class="number">1056768</span><span class="type">K</span>)], <span class="number">0.0041518</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">76288</span>K, used <span class="number">655</span>K [<span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line">  <span class="type">eden</span> <span class="type">space</span> <span class="number">65536</span><span class="type">K</span>, <span class="number">1</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000fab00000</span>,<span class="number">0</span><span class="type">x00000000faba3ee8</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>)</span><br><span class="line">  <span class="type">from</span> <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000feb00000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>)</span><br><span class="line">  <span class="type">to</span>   <span class="type">space</span> <span class="number">10752</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x00000000ff580000</span>,<span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line"> <span class="type">ParOldGen</span>       <span class="type">total</span> <span class="number">175104</span><span class="type">K</span>, <span class="type">used</span> <span class="number">628</span><span class="type">K</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>, <span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line">  <span class="type">object</span> <span class="type">space</span> <span class="number">175104</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000f0000000</span>,<span class="number">0</span><span class="type">x00000000f009d260</span>,<span class="number">0</span><span class="type">x00000000fab00000</span>)</span><br><span class="line"> <span class="type">Metaspace</span>       <span class="type">used</span> <span class="number">3235</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">4500</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">4864</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1056768</span><span class="type">K</span></span><br><span class="line">  <span class="type">class</span> <span class="type">space</span>    <span class="type">used</span> <span class="number">350</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">388</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">512</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1048576</span><span class="type">K</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-内存溢出和内存泄漏"><a href="#2-内存溢出和内存泄漏" class="headerlink" title="2.内存溢出和内存泄漏"></a>2.<strong>内存溢出和内存泄漏</strong></h3><ul><li><p>什么是<strong>内存溢出？</strong></p><ol><li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li><li>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li><li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li><li>Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</li></ol></li><li><p><strong>内存溢出（OOM）原因分析</strong></p><ul><li><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ol><li>Java虚拟机的堆内存设置不够。<ul><li>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</li></ul></li><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）<ul><li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现<strong>OutOfMemoryError</strong>也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“<strong>java.lang.OutOfMemoryError:PermGen space</strong>“。</li><li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“<strong>java.lang.OutofMemoryError:Metaspace</strong>“。直接内存不足，也会导致<strong>OOM</strong>。</li></ul></li></ol></li><li><p>抛出<strong>OutofMemoryError</strong>之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如：在引用机制分析中，涉及到JVM会去尝试<strong>回收软引用指向的对象</strong>等。</li><li>在**java.nio.Bits.reserveMemory()**方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li></ul></li><li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出<strong>OutofMemoryError</strong>。</li></ul></li></ul></li><li><p>什么是<strong>内存泄漏？</strong></p><ol><li>也称作“存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</strong></li><li>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</li><li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。</li><li>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li></ol><p>  <img src="/images/jvm_virtual_machine/chapter14/image.png" alt="Untitled"></p><p>  Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p><ul><li><p><strong>举例</strong></p><ul><li>单例模式</li></ul><p>  单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p><ul><li>一些提供close的资源未关闭导致内存泄漏</li></ul><p>  数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p></li></ul></li></ul><h3 id="3-Stop-The-World"><a href="#3-Stop-The-World" class="headerlink" title="3.Stop The World"></a>3.<strong>Stop The World</strong></h3>]]></content>
    
    
    <summary type="html">在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(十三)垃圾回收算法</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%B8%89)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%B8%89)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</id>
    <published>2023-02-12T16:00:00.000Z</published>
    <updated>2025-09-03T15:23:42.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-十三-垃圾回收算法"><a href="#JVM虚拟机详解-十三-垃圾回收算法" class="headerlink" title="JVM虚拟机详解(十三)垃圾回收算法"></a>JVM虚拟机详解(十三)垃圾回收算法</h2><h3 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1. 什么是垃圾"></a>1. <strong>什么是垃圾</strong></h3><p><img src="/images/jvm_virtual_machine/chapter13/image.png" alt="Untitled"></p><p>从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。</p><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><ul><li><p><strong>什么是垃圾？</strong></p><ol><li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li><li>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</li><li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li></ol></li><li><p><strong>为什么需要GC？</strong></p><ul><li><strong>想要学习GC，首先需要理解为什么需要GC？</strong><ol><li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li><li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</li><li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li></ol></li></ul></li><li><p><strong>早期垃圾回收</strong></p><ol><li><p>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> <span class="title class_">cmBaseGroupBridge</span>（）；</span><br><span class="line">  <span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line">  <span class="keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）</span><br><span class="line">  delete pBridge；</span><br></pre></td></tr></table></figure></li><li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p></li><li><p>有了垃圾回收机制后，上述代码极有可能变成这样</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge=<span class="keyword">new</span> <span class="title class_">cmBaseGroupBridge</span>(); </span><br><span class="line">  pBridge-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol><li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</li></ol><h3 id="2-Java-垃圾回收机制"><a href="#2-Java-垃圾回收机制" class="headerlink" title="2.Java 垃圾回收机制"></a>2.<strong>Java 垃圾回收机制</strong></h3><ul><li><p><strong>自动内存管理</strong></p><ul><li><strong>官网介绍：</strong><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide, Release 8 (oracle.com)</a></li></ul></li><li><p><strong>自动内存管理的优点</strong></p><ol><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</li><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li></ol></li><li><p><strong>关于自动内存管理的担忧</strong></p><ol><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li><li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li></ol></li><li><p><strong>GC主要关注的区域</strong></p><p>  GC主要关注于 方法区 和堆中的垃圾收集</p><p>  <img src="/images/jvm_virtual_machine/chapter13/image1.png" alt="Untitled"></p><p>  垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收</p><ul><li>其中，Java堆是垃圾收集器的工作重点</li></ul><p>  从次数上讲：</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul></li></ul><h3 id="3-垃圾回收相关算法"><a href="#3-垃圾回收相关算法" class="headerlink" title="3.垃圾回收相关算法"></a>3.<strong>垃圾回收相关算法</strong></h3><ul><li><p><strong>引用计数算法</strong></p><ol><li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</strong></li><li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li><li>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</li></ol><ul><li><strong>引用计数算法-原理</strong><ul><li>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</li><li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li><li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li><li>缺点：<ol><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li></ol></li></ul></li><li><strong>循环引用</strong><ul><li>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏****</li></ul></li></ul><p>  <img src="/images/jvm_virtual_machine/chapter13/image2.png" alt="Untitled"></p><ul><li>验证Java是否采用的是引用计数算法</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.gc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 引用计数算法测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-03-05 16:44:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">15093</span><span class="type">K</span>-&gt;<span class="number">808</span><span class="type">K</span>(<span class="number">94208</span><span class="type">K</span>)] <span class="number">15093</span><span class="type">K</span>-&gt;<span class="number">816</span><span class="type">K</span>(<span class="number">310272</span><span class="type">K</span>), <span class="number">0.0010090</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br><span class="line">[<span class="type">Full</span> <span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">808</span><span class="type">K</span>-&gt;<span class="number">0</span><span class="type">K</span>(<span class="number">94208</span><span class="type">K</span>)] [<span class="type">ParOldGen</span>: <span class="number">8</span><span class="type">K</span>-&gt;<span class="number">627</span><span class="type">K</span>(<span class="number">216064</span><span class="type">K</span>)] <span class="number">816</span><span class="type">K</span>-&gt;<span class="number">627</span><span class="type">K</span>(<span class="number">310272</span><span class="type">K</span>), [<span class="type">Metaspace</span>: <span class="number">3226</span><span class="type">K</span>-&gt;<span class="number">3226</span><span class="type">K</span>(<span class="number">1056768</span><span class="type">K</span>)], <span class="number">0.0038155</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">94208</span>K, used <span class="number">809</span>K [<span class="number">0</span><span class="type">x0000000756f80000</span>, <span class="number">0</span><span class="type">x000000075d880000</span>, <span class="number">0</span><span class="type">x00000007c0000000</span>)</span><br><span class="line">  <span class="type">eden</span> <span class="type">space</span> <span class="number">80896</span><span class="type">K</span>, <span class="number">1</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x0000000756f80000</span>,<span class="number">0</span><span class="type">x000000075704a548</span>,<span class="number">0</span><span class="type">x000000075be80000</span>)</span><br><span class="line">  <span class="type">from</span> <span class="type">space</span> <span class="number">13312</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x000000075be80000</span>,<span class="number">0</span><span class="type">x000000075be80000</span>,<span class="number">0</span><span class="type">x000000075cb80000</span>)</span><br><span class="line">  <span class="type">to</span>   <span class="type">space</span> <span class="number">13312</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x000000075cb80000</span>,<span class="number">0</span><span class="type">x000000075cb80000</span>,<span class="number">0</span><span class="type">x000000075d880000</span>)</span><br><span class="line"> <span class="type">ParOldGen</span>       <span class="type">total</span> <span class="number">216064</span><span class="type">K</span>, <span class="type">used</span> <span class="number">627</span><span class="type">K</span> [<span class="number">0</span><span class="type">x0000000684e00000</span>, <span class="number">0</span><span class="type">x0000000692100000</span>, <span class="number">0</span><span class="type">x0000000756f80000</span>)</span><br><span class="line">  <span class="type">object</span> <span class="type">space</span> <span class="number">216064</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x0000000684e00000</span>,<span class="number">0</span><span class="type">x0000000684e9cc80</span>,<span class="number">0</span><span class="type">x0000000692100000</span>)</span><br><span class="line"> <span class="type">Metaspace</span>       <span class="type">used</span> <span class="number">3233</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">4496</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">4864</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1056768</span><span class="type">K</span></span><br><span class="line">  <span class="type">class</span> <span class="type">space</span>    <span class="type">used</span> <span class="number">350</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">388</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">512</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1048576</span><span class="type">K</span></span><br></pre></td></tr></table></figure><p>  我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">GC</span> (<span class="type">System.gc</span>()) [<span class="type">PSYoungGen</span>: <span class="number">15093</span><span class="type">K</span>-&gt;<span class="number">808</span><span class="type">K</span>(<span class="number">94208</span><span class="type">K</span>)] <span class="number">15093</span><span class="type">K</span>-&gt;<span class="number">816</span><span class="type">K</span>(<span class="number">310272</span><span class="type">K</span>), <span class="number">0.0010090</span> <span class="type">secs</span>] [<span class="type">Times</span>: <span class="type">user</span>=<span class="number">0.00</span> <span class="type">sys</span>=<span class="number">0.00</span>, <span class="type">real</span>=<span class="number">0.00</span> <span class="type">secs</span>] </span><br></pre></td></tr></table></figure><p>   如果使用引用计数算法，那么这两个对象会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p><p>  <img src="/images/jvm_virtual_machine/chapter13/image3.png" alt="Untitled"></p></li><li><p><strong>可达性分析算法</strong></p><ul><li><strong>概念：</strong><ul><li><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong><ol><li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li></ol></li></ul></li><li><strong>可达性分析实现思路</strong><ul><li><p>所谓”GCRoots”根集合就是一组必须活跃的引用</p></li><li><p>其基本思路如下：</p><ol><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ol><p>  <img src="/images/jvm_virtual_machine/chapter13/image4.png" alt="Untitled"></p></li></ul></li></ul></li><li><p><strong>标记-清除算法</strong></p><ul><li><p><strong>垃圾清除阶段</strong></p><ul><li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是<ol><li>标记-清除算法（Mark-Sweep）</li><li>复制算法（Copying）</li><li>标记-压缩算法（Mark-Compact）</li></ol></li><li>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</li></ul></li><li><p><strong>执行过程</strong></p><ul><li>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</li><li><strong>标记</strong>：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般是在对象的Header中记录为可达对象。<ul><li><strong>标记的是引用的对象，不是垃圾！！</strong></li></ul></li><li><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter13/image5.png" alt="Untitled">  </p></li><li><p><strong>标记-清除算法的缺点</strong></p><ol><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ol></li><li><p><strong>注意：何为清除？</strong></p><ul><li>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</li><li>关于空闲列表是在为对象分配内存的时候提过：<ul><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个空闲列表</li><li>采用空闲列表分配内存</li></ul></li></ul></li></ul></li><li><p><strong>GC Roots可以是哪些？</strong></p><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（StringTable）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter13/image6.png" alt="Untitled"></p><ul><li><strong>注意</strong><ol><li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li><li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li></ol></li></ul></li></ul></li><li><p><strong>清除阶段：复制算法</strong></p><ul><li><p><strong>背景</strong></p><ul><li>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</li></ul></li><li><p><strong>核心思想</strong></p><ul><li>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter13/image7.png" alt="Untitled"></p><ul><li>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter13/image8.png" alt="Untitled">  </p></li><li><p><strong>优点</strong></p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul></li><li><p><strong>缺点</strong></p><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul></li><li><p><strong>注意</strong></p><ul><li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</li><li>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter13/image9.png" alt="Untitled"></p></li></ul></li></ul><h3 id="4-对象的-finalization-机制"><a href="#4-对象的-finalization-机制" class="headerlink" title="4.对象的 finalization 机制"></a>4.<strong>对象的 finalization 机制</strong></h3><ul><li><p>概述</p><ul><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</li><li>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li></ul></li><li><p><strong>对象销毁前的回调函数：finalize()</strong></p><ul><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</li><li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li></ul></li><li><p><strong>注意事项：</strong></p><p>  永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在finalize（）时可能会导致对象复活。</li><li>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul><li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul></li><li>一个糟糕的finalize（）会严重影响Gc的性能。</li></ul></li><li><p><strong>生存还是死亡？</strong></p><ul><li><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态。</strong></p><ol><li>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：<ol><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li></ol></li><li>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</li></ol></li><li><p><strong>具体过程</strong></p><p>  判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ul><li><p>如果对象objA到GC Roots没有引用链，则进行第一次标记。</p></li><li><p>进行筛选，判断此对象是否有必要执行finalize（）方法</p><ul><li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li><li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter13/image10.png" alt="Untitled"></p></li></ul></li><li><p><strong>代码演示 finalize() 方法可复活对象</strong></p><ul><li>我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this</li><li>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.gc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-03-05 17:54:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;</span><br><span class="line">    <span class="comment">//类变量，属于 GC Root</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法只能被调用一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        <span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();<span class="comment">//调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------第一次gc操作------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------第二次gc操作------------&quot;</span>);</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span></span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后运行结果</li></ul>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用当前类重写的finalize()方法</span><br><span class="line"><span class="literal">-----------------</span>第一次<span class="built_in">gc</span>操作<span class="literal">------------</span></span><br><span class="line">obj is still alive</span><br><span class="line"><span class="literal">-----------------</span>第二次<span class="built_in">gc</span>操作<span class="literal">------------</span></span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-MAT与JProfiler的GC-Roots溯源"><a href="#5-MAT与JProfiler的GC-Roots溯源" class="headerlink" title="5.MAT与JProfiler的GC Roots溯源"></a>5.<strong>MAT与JProfiler的GC Roots溯源</strong></h3><ul><li><p><strong>MAT</strong></p><ul><li><p><strong>介绍</strong></p><ul><li>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li><li>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li><li>下载地址：<a href="http://www.eclipse.org/mat/">Eclipse Memory Analyzer Open Source Project | The Eclipse Foundation</a></li></ul></li><li><p>获取dump文件</p><ul><li><strong>命令行使用 jmap</strong></li></ul>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\yuanxw&gt;jps</span><br><span class="line"><span class="number">13376</span> Jps</span><br><span class="line"><span class="number">16176</span> RefCountGC</span><br><span class="line"><span class="number">5856</span></span><br><span class="line"><span class="number">16824</span> Launcher</span><br><span class="line"><span class="number">16700</span> Main</span><br><span class="line"></span><br><span class="line">C:\Users\yuanxw&gt;jmap <span class="literal">-dump</span>:format=b,live,file=refcountgc.bin <span class="number">16176</span></span><br><span class="line">Dumping heap to C:\Users\yuanxw\refcountgc.bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><ul><li>打开后，我们就可以看到有哪些可以作为GC Roots的对象</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter13/image11.png" alt="Untitled"></p></li></ul></li><li><p><strong>JProfiler</strong></p><ul><li><p><strong>JProfiler的GC Roots溯源</strong></p><ul><li>在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<strong>GC Roots 溯源</strong></li><li>下面我们使用使用 JProfiler 进行 GC Roots 溯源演示</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter13/image12.png" alt="Untitled"></p><p>  - </p></li><li><p><strong>如何判断什么原因造成OOM</strong></p><ul><li>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存溢出排查</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * 这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid7196.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">7705267</span> bytes in <span class="number">0.009</span> secs]</span><br><span class="line">count = <span class="number">6</span></span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.peppa.gc.HeapOOM.&lt;init&gt;(HeapOOM.java:<span class="number">10</span>)</span><br><span class="line">at com.peppa.gc.HeapOOM.main(HeapOOM.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>  我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</p><p>  <img src="/images/jvm_virtual_machine/chapter13/image13.png" alt="Untitled"></p><p>  然后我们通过线程，还能够定位到哪里出现OOM</p><p>  <img src="/images/jvm_virtual_machine/chapter13/image14.png" alt="Untitled"></p></li></ul></li><li><p><strong>清除阶段：标记-整理算法</strong></p><ul><li><p><strong>背景</strong></p><ul><li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</li><li>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li></ul></li><li><p><strong>执行过程</strong></p><ul><li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p></li><li><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p><p>  <img src="/images/jvm_virtual_machine/chapter13/image15.png" alt="Untitled"></p></li></ul></li><li><p><strong>标清和标整的区别</strong></p><ul><li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</li><li>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</li><li>标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li></ul></li><li><p><strong>标整的优缺点</strong></p><ul><li><strong>优点</strong><ol><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ol></li><li><strong>缺点</strong><ol><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ol></li></ul></li></ul></li><li><p><strong>垃圾回收算法小结</strong></p><ul><li><p><strong>对比三种清除阶段的算法</strong></p><ol><li>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</li><li>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</li></ol><table><thead><tr><th></th><th><strong>标记清除</strong></th><th><strong>标记整理</strong></th><th><strong>复制</strong></th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table></li><li><p><strong>分代收集算法</strong></p><ul><li>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</li><li>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</li><li>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul></li><li><p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p><p>  在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li><p><strong>年轻代（Young Gen）</strong></p><p>  年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>  这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p></li><li><p><strong>老年代（Tenured Gen）</strong></p><p>  老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>  这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>compact阶段的开销与存活对象的数据成正比。</li></ul></li></ul><p>  以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p><p>  分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p></li></ul></li><li><p><strong>增量收集算法</strong></p><ul><li><p><strong>概述</strong></p><ul><li>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</li></ul></li><li><p><strong>增量收集算法基本思想</strong></p><ul><li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</li><li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</li></ul></li><li><p><strong>增量收集算法的缺点</strong></p><ul><li>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</li></ul></li><li><p><strong>分区算法</strong></p><ul><li><p>概述</p><ol><li>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li><li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ol><p>  <img src="/images/jvm_virtual_machine/chapter13/image16.png" alt="Untitled"></p></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(十二)StringTable(字符串常量池)</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%BA%8C)StringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%BA%8C)StringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/</id>
    <published>2023-02-11T16:00:00.000Z</published>
    <updated>2025-09-03T15:22:02.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-十二-StringTable-字符串常量池"><a href="#JVM虚拟机详解-十二-StringTable-字符串常量池" class="headerlink" title="JVM虚拟机详解(十二)StringTable(字符串常量池)"></a>JVM虚拟机详解(十二)StringTable(字符串常量池)</h2><h3 id="1-StringTable-字符串常量池"><a href="#1-StringTable-字符串常量池" class="headerlink" title="1. StringTable(字符串常量池)"></a>1. StringTable(字符串常量池)</h3><ul><li><p><strong>String的基本特性</strong></p><ul><li>String：字符串，使用一对 ”” 引起来表示</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;peppa&quot;</span> ;   <span class="comment">// 字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);     <span class="comment">// new 对象的方式</span></span><br></pre></td></tr></table></figure><ul><li>string声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li><li>String在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li></ul></li><li><p><strong>为什么JDK9改变了结构</strong></p><p>  String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p><p>  我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1&#x2F;Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p><p>  结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value</span><br></pre></td></tr></table></figure><p>  同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p></li><li><p><strong>String的不可变性</strong></p><ul><li>String：代表不可变的字符序列。简称：不可变性。<ol><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ol></li><li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li></ul></li><li><p><strong>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//判断地址：true  --&gt; false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s1);<span class="comment">//</span></span><br><span class="line">    System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  字节码指令</p><ul><li>取字符串 “abc” 时，使用的是同一个符号引用：#2</li><li>取字符串 “hello” 时，使用的是另一个符号引用：#3</li></ul></li><li><p><strong>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    s2 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    System.out.println(s2);<span class="comment">//abcdef</span></span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">    System.out.println(s2);<span class="comment">//mbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>一道笔试题</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringExer</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExer</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容****</p></li></ul><h3 id="2-String-的底层结构"><a href="#2-String-的底层结构" class="headerlink" title="2.String 的底层结构"></a>2.<strong>String 的底层结构</strong></h3><ul><li><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p><ol><li>String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</li><li>使用-XX:StringTablesize可设置StringTable的长度</li><li>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li><li>在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li>在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</li></ol></li><li><p><strong>String 的内存分配</strong></p><ol><li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li><li>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。<ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;atguigu.com&quot;;</code></li><li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈</li></ul></li><li>Java 6及以前，字符串常量池存放在永久代</li><li>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内<ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li></ul></li><li>Java8元空间，字符串常量在堆</li></ol><p>  <img src="/images/jvm_virtual_machine/chapter12/image.png" alt="Untitled"></p><p>  <img src="/images/jvm_virtual_machine/chapter12/image1.png" alt="Untitled">  </p></li><li><p><strong>StringTable 为什么要调整？</strong></p><ol><li>为什么要调整位置？<ul><li>永久代的默认空间大小比较小</li><li>永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li><li>堆中空间足够大，字符串可被及时回收</li></ul></li><li>在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li><li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li></ol><p>  <strong>官方文档</strong>:<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p><p>  <strong>代码示例：</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.strings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m -Xms10m -Xmx10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=10m -Xms10m -Xmx10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用Set保持着常量池引用，避免full gc回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//在short可以取值的范围内足以让10MB的PermSize或heap产生OOM了。</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  输出结果：字符串真的在堆中（JDK8）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.HashMap.resize(HashMap.java:<span class="number">704</span>)</span><br><span class="line">at java.util.HashMap.putVal(HashMap.java:<span class="number">663</span>)</span><br><span class="line">at java.util.HashMap.put(HashMap.java:<span class="number">612</span>)</span><br><span class="line">at java.util.HashSet.add(HashSet.java:<span class="number">220</span>)</span><br><span class="line">at com.peppa.strings.StringTest3.main(StringTest3.java:<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>String 的基本操作</strong></p><p>  Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.strings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();<span class="comment">//2051</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2052</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2303</span></span><br><span class="line">        <span class="comment">//如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分析字符串常量池的变化-案例1：</p><p>  1、程序启动时已经加载了 <code>*2051*</code>个字符串常量</p><p>  <img src="/images/jvm_virtual_machine/chapter12/image2.png" alt="Untitled"></p><p>  2、加载了一个换行符（println），所以多了一个</p><p>  <img src="/images/jvm_virtual_machine/chapter12/image3.png" alt="Untitled"></p><p>  3、之后的字符串”1” 到 “10”不会再次加载</p><p>  <img src="/images/jvm_virtual_machine/chapter12/image4.png" alt="Untitled"></p></li><li><p>分析字符串常量池的变化-案例2：</p><ul><li>官方示例代码</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方示例代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//line 3</span></span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();<span class="comment">//line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">    &#125;<span class="comment">//line 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> &#123;<span class="comment">//line 6</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析运行时内存（foo() 方法是实例方法，其实图中少了一个 this 局部变量）</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter12/image5.png" alt="Untitled"></p></li></ul></li></ul><h3 id="3-字符串拼接操作"><a href="#3-字符串拼接操作" class="headerlink" title="3.字符串拼接操作"></a>3.<strong>字符串拼接操作</strong></h3><ul><li><p><strong>字符串拼接操作</strong></p><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul></li><li><p><strong>常量与常量的拼接结果在常量池，原理是编译期优化</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">     * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc</span></span><br><span class="line"><span class="number">2</span>: astore_1</span><br><span class="line"><span class="number">3</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc</span></span><br><span class="line"><span class="number">5</span>: astore_2</span><br><span class="line"><span class="number">6</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">9</span>: aload_1</span><br><span class="line"><span class="number">10</span>: aload_2</span><br><span class="line"><span class="number">11</span>: if_acmpne     <span class="number">18</span></span><br><span class="line"><span class="number">14</span>: iconst_1</span><br><span class="line"><span class="number">15</span>: <span class="keyword">goto</span>          <span class="number">19</span></span><br><span class="line"><span class="number">18</span>: iconst_0</span><br><span class="line"><span class="number">19</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="number">22</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">25</span>: aload_1</span><br><span class="line"><span class="number">26</span>: aload_2</span><br><span class="line"><span class="number">27</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/String.equals:(Ljava/lang/Object;)Z</span></span><br><span class="line"><span class="number">30</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="number">33</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>  IDEA 反编译 class 文件后，来看这个问题</p><p>  <img src="/images/jvm_virtual_machine/chapter12/image6.png" alt="Untitled"></p></li><li><p><strong>拼接前后，只要其中有一个是变量，结果就在堆中</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">    <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">    <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从上述的结果我们可以知道：</p><p>  从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类</p><p>  如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果</p><p>  而调用intern方法，则会判断字符串常量池中是否存在JavaEEhadoop值，如果存在则返回常量池中的值，否者就在常量池中创建</p></li><li><p><strong>底层原理</strong></p><ul><li><p>拼接操作的底层其实使用了StringBuilder</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">    ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">    ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/images/jvm_virtual_machine/chapter12/image7.png" alt="Untitled"></p></li><li><p>字符串拼接操作不一定使用的是StringBuilder</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">14</span> &lt;a&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">15</span> &lt;b&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> ldc #<span class="number">16</span> &lt;ab&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line"><span class="number">9</span> ldc #<span class="number">16</span> &lt;ab&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">13</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">16</span> aload_3</span><br><span class="line"><span class="number">17</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">19</span> if_acmpne <span class="number">26</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">22</span> iconst_1</span><br><span class="line"><span class="number">23</span> <span class="keyword">goto</span> <span class="number">27</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">26</span> iconst_0</span><br><span class="line"><span class="number">27</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">30</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>拼接操作和append性能对比</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> highLevel)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src += <span class="string">&quot;a&quot;</span>; <span class="comment">// 每次循环都会创建一个StringBuilder对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> highLevel)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p><p>  结论：</p><ul><li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li></ul><p>  好处</p><ul><li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li><li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li><li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li></ul><p>  改进的空间</p><ul><li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li><li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li></ul></li></ul></li><li><p><strong>intern()的使用</strong></p><ul><li><ul><li><strong>intern() 方法的说明</strong></li></ul></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><ol><li><p>intern是一个native方法，调用的是底层C的方法</p></li><li><p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）</p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：</p><p> <code>String myInfo = new string(&quot;I love atguigu&quot;).intern();</code></p></li><li><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p><p> <code>(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</code></p></li><li><p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p></li></ol></li><li><p><strong>new String() 的说明</strong></p><ul><li><p><strong>new String(“ab”)会创建几个对象？</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment"> *     一个对象是：new关键字在堆空间创建的</span></span><br><span class="line"><span class="comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字节码指令</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="number">4</span> ldc #<span class="number">3</span> &lt;ab&gt;</span><br><span class="line"><span class="number">6</span> invokespecial #<span class="number">4</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>  <code>0 new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象</p><p>  <code>4 ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）  </p></li><li><p><strong>new String(“a”) + new String(“b”) 会创建几个对象？</strong></p><ul><li>代码</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span></span><br><span class="line"><span class="comment"> *  对象1：new StringBuilder()</span></span><br><span class="line"><span class="comment"> *  对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment"> *  对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment"> *  对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment"> *  对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  深入剖析： StringBuilder的toString():</span></span><br><span class="line"><span class="comment"> *      对象6 ：new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  字节码指令</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line"><span class="number">10</span>: dup</span><br><span class="line"><span class="number">11</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String a</span></span><br><span class="line"><span class="number">13</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="number">16</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">19</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line"><span class="number">22</span>: dup</span><br><span class="line"><span class="number">23</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String b</span></span><br><span class="line"><span class="number">25</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="number">28</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">31</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line"><span class="number">34</span>: astore_1</span><br><span class="line"><span class="number">35</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>  我们创建了6个对象</p><ul><li>对象1：new StringBuilder()</li><li>对象2：new String(“a”)</li><li>对象3：常量池的 a</li><li>对象4：new String(“b”)</li><li>对象5：常量池的 b</li><li>对象6：toString中会创建一个 new String(“ab”)<ul><li>调用toString方法，不会在常量池中生成ab</li></ul></li></ul></li></ul></li><li><p><strong>intern的使用：JDK6和JDK7</strong></p><ul><li><p><strong>JDK6中</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// 在常量池中已经有了</span></span><br><span class="line">s.intern(); <span class="comment">// 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s == s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s3.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>  输出结果</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><p>为什么对象会不一样呢？</p><blockquote><p>一个是new创建的对象，一个是常量池中的对象，显然不是同一个</p></blockquote></li></ul></li><li><p>如果是下面这样的，那么就是true</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s = s.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  而对于下面的来说，因为 s3变量记录的地址是 new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是JDK6的关系，然后执行 s3.intern()后，就会在常量池中生成 “11”，最后 s4用的就是s3的地址</p><blockquote><p>为什么最后输出的 s3 &#x3D;&#x3D; s4 会为false呢？这是因为在JDK6中创建了一个新的对象 “11”，也就是有了新的地址， s2 &#x3D; 新地址而在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象</p></blockquote></li><li><p><strong>JDK7中</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s == s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s3.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  <img src="/images/jvm_virtual_machine/chapter12/image8.png" alt="Untitled"></p></li></ul></li><li><p><strong>扩展</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * StringIntern.java中练习的拓展：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s5 是从字符串常量池中取回来的引用，当然和 s4 相等</span></span><br><span class="line">        System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>总结string的intern（）的使用：</p><p>  JDK1.6中，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此<strong>对象复制一份</strong>，放入串池，并返回串池中的对象地址</li></ul><p>  JDK1.7起，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<strong>对象的引用地址</strong>复制一份，放入串池，并返回串池中的引用地址</li></ul></li><li><p>练习：</p><p>  <img src="/images/jvm_virtual_machine/chapter12/image9.png" alt="Untitled"></p><ul><li>在JDK6中，在字符串常量池中创建一个字符串 “ab”</li><li>在JDK8中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到 串池中。</li><li>所以上述结果，在JDK6中是：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>在JDK8中是</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  <img src="/images/jvm_virtual_machine/chapter12/image10.png" alt="Untitled"></p><p>  针对下面这题，在JDK6和8中表现的是一样的</p><p>  <img src="/images/jvm_virtual_machine/chapter12/image11.png" alt="Untitled"></p></li></ul><h3 id="4-StringTable的垃圾回收"><a href="#4-StringTable的垃圾回收" class="headerlink" title="4.StringTable的垃圾回收"></a>4.<strong>StringTable的垃圾回收</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.strings;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;488K(4608K)] 4096K-&gt;664K(15872K), <span class="number">0.0011215</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 4608K, used 3577K [<span class="number">0x00000000ffb00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 4096K, <span class="number">75</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffe04688</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">95</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff7a020</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 11264K, used 176K [<span class="number">0x00000000ff000000</span>, <span class="number">0x00000000ffb00000</span>, <span class="number">0x00000000ffb00000</span>)</span><br><span class="line">  object space 11264K, <span class="number">1</span>% used [<span class="number">0x00000000ff000000</span>,<span class="number">0x00000000ff02c000</span>,<span class="number">0x00000000ffb00000</span>)</span><br><span class="line"> Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 350K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">20011</span> =    <span class="number">160088</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :     <span class="number">13304</span> =    <span class="number">319296</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :     <span class="number">13304</span> =    <span class="number">568608</span> bytes, avg  <span class="number">42.740</span></span><br><span class="line">Total footprint         :           =   <span class="number">1047992</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">0.665</span></span><br><span class="line">Variance of bucket size :     <span class="number">0.666</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">0.816</span></span><br><span class="line">Maximum bucket size     :         <span class="number">6</span></span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :     <span class="number">57042</span> =   <span class="number">1369008</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :     <span class="number">57042</span> =   <span class="number">3253608</span> bytes, avg  <span class="number">57.039</span></span><br><span class="line">Total footprint         :           =   <span class="number">5102720</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">0.950</span></span><br><span class="line">Variance of bucket size :     <span class="number">0.750</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">0.866</span></span><br><span class="line">Maximum bucket size     :         <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="5-G1-中的-String-去重操作"><a href="#5-G1-中的-String-去重操作" class="headerlink" title="5.G1 中的 String 去重操作"></a>5.<strong>G1 中的 String 去重操作</strong></h3><p>官方：<a href="http://openjdk.java.net/jeps/192">JEP 192: String Deduplication in G1 (java.net)</a></p><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p><ul><li><p><strong>描述</strong></p><ul><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>堆存活数据集合里面string对象占了25%</li><li>堆存活数据集合里面重复的string对象有13.5%</li><li>string对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）&#x3D; true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。</li></ul></li><li><p><strong>String 去重的的实现</strong></p><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li></ol></li><li><p><strong>命令行选项</strong></p><ol><li>UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li><li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li></ol></li></ul>]]></content>
    
    
    <summary type="html">String：字符串，使用一对 ”” 引起来表示</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(十)对象的实例化内存布局与访问定位</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81)%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81)%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</id>
    <published>2023-02-09T16:00:00.000Z</published>
    <updated>2025-09-03T15:19:50.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-十-对象的实例化内存布局与访问定位"><a href="#JVM虚拟机详解-十-对象的实例化内存布局与访问定位" class="headerlink" title="JVM虚拟机详解(十)对象的实例化内存布局与访问定位"></a>JVM虚拟机详解(十)对象的实例化内存布局与访问定位</h2><h3 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1. 创建对象"></a>1. 创建对象</h3><p><img src="/images/jvm_virtual_machine/chapter10/image1.png" alt="Untitled"></p><ul><li><p><strong>对象创建方式</strong></p><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li><li>使用序列化：序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul></li><li><p><strong>创建对象的步骤</strong></p><ol><li><p><strong>判断对象对应的类是否加载、链接、初始化</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>       <span class="number">1</span>     <span class="number">1</span>   obj   Ljava/lang/Object;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br></pre></td></tr></table></figure><p> 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p></li><li><p><strong>为对象分配内存</strong></p><ol><li>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li><li>如果内存规整：采用指针碰撞分配内存<ul><li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</li><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</li><li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li><li>标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域</li></ul></li><li><strong>如果内存不规整</strong><ul><li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</li><li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</li><li>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</li><li>标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li></ul></li></ol></li><li><p><strong>处理并发问题</strong></p><ul><li>采用CAS+失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）</li><li>在Eden区给每个线程分配一块区域</li></ul></li><li><p><strong>初始化分配到的空间</strong></p><ul><li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li><li>给对象属性赋值的顺序：<ol><li>属性的默认值初始化</li><li>显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li><li>构造器初始化</li></ol></li></ul></li><li><p><strong>置对象的对象头</strong></p><p> 将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p></li></ol><p>  6.<strong>执行init方法进行初始化</strong></p><ol><li>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</li><li>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</li></ol><p>  <strong>从字节码角度看 init 方法</strong></p><p>  源代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.area;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  字节码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">4</span>: aload_0</span><br><span class="line"><span class="number">5</span>: sipush        <span class="number">1001</span></span><br><span class="line"><span class="number">8</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field id:I</span></span><br><span class="line"><span class="number">11</span>: aload_0</span><br><span class="line"><span class="number">12</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String 匿名客户</span></span><br><span class="line"><span class="number">14</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field name:Ljava/lang/String;</span></span><br><span class="line"><span class="number">17</span>: aload_0</span><br><span class="line"><span class="number">18</span>: <span class="keyword">new</span>           #<span class="number">5</span>                  <span class="comment">// class com/peppa/area/Account</span></span><br><span class="line"><span class="number">21</span>: dup</span><br><span class="line"><span class="number">22</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method com/peppa/area/Account.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">25</span>: putfield      #<span class="number">7</span>                  <span class="comment">// Field acct:Lcom/peppa/area/Account;</span></span><br><span class="line"><span class="number">28</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>init() 方法的字节码指令：<ul><li>属性的默认值初始化：<code>id = 1001;</code></li><li>显示初始化&#x2F;代码块初始化：<code>name = &quot;匿名客户&quot;;</code></li><li>构造器初始化：<code>acct = new Account();</code></li></ul></li></ul><h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. <strong>对象的内存布局</strong></h3><ul><li><p><strong>对象的内存布局思维导图</strong></p><p>  <img src="/images/jvm_virtual_machine/chapter10/image1.png" alt="Untitled"></p></li><li><p><strong>对象头</strong></p><ul><li>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针<ul><li><em>如果是数组，还需要记录数组的长度</em></li></ul></li><li><strong>运行时元数据</strong><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul></li><li><strong>类型指针</strong><ul><li>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</li></ul></li></ul></li><li><p><strong>图解内存布局</strong></p></li></ul><p>  <img src="/images/jvm_virtual_machine/chapter10/image2.png" alt="Untitled"></p><ul><li><strong>对象的访问定位</strong><ul><li><p><strong>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</strong></p><p>  定位，通过栈上reference访问</p><p>  <img src="/images/jvm_virtual_machine/chapter10/image3.png" alt="Untitled"></p></li><li><p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p><ul><li><p><strong>句柄访问</strong></p><ol><li>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低</li><li>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li></ol><p>  <img src="/images/jvm_virtual_machine/chapter10/image4.png" alt="Untitled"></p></li></ul></li><li><p><strong>直接指针（HotSpot采用）</strong></p><ol><li><p>优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p></li><li><p>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</p><p> <img src="/images/jvm_virtual_machine/chapter10/image5.png" alt="Untitled"></p></li></ol></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(十)对象的实例化内存布局与访问定位</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%B8%80)%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8EExecution%20Engine/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%B8%80)%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8EExecution%20Engine/</id>
    <published>2023-02-09T16:00:00.000Z</published>
    <updated>2025-09-03T15:20:32.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-十一-执行引擎Execution-Engine"><a href="#JVM虚拟机详解-十一-执行引擎Execution-Engine" class="headerlink" title="JVM虚拟机详解(十一)执行引擎Execution Engine"></a>JVM虚拟机详解(十一)执行引擎Execution Engine</h2><h3 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1. 执行引擎概述"></a>1. <strong>执行引擎概述</strong></h3><ul><li><p>概述</p><ul><li>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</li><li>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter11/image.png" alt="Untitled"></p><p>  JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p><p>  <img src="/images/jvm_virtual_machine/chapter11/image1.png" alt="Untitled"></p><p>  那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。  </p></li><li><p><strong>执行引擎的工作流程</strong></p><ul><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter11/image2.png" alt="Untitled"></p><p>  从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p></li></ul><h3 id="2-Java代码编译和执行过程"><a href="#2-Java代码编译和执行过程" class="headerlink" title="2.Java代码编译和执行过程"></a>2.<strong>Java代码编译和执行过程</strong></h3><ul><li><p><strong>编译和执行过程</strong></p><ul><li><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><ul><li><p>前面橙色部分是生成字节码文件的过程，和JVM无关</p></li><li><p>后面蓝色和绿色才是JVM需要考虑的过程</p><p>  <img src="/images/jvm_virtual_machine/chapter11/image3.png" alt="Untitled"></p></li></ul></li><li><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p></li></ul><p>  <img src="/images/jvm_virtual_machine/chapter11/image4.png" alt="Untitled"></p><ul><li>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter11/image5.png" alt="Untitled"></p><ul><li>我们用一个总的图，来说说 解释器和编译器</li></ul></li></ul><p><img src="/images/jvm_virtual_machine/chapter11/image6.png" alt="Untitled"></p><ul><li><p><strong>什么是解释器（Interpreter）</strong></p><p>  当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p></li><li><p><strong>什么是JIT编译器</strong></p><ul><li>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</li></ul></li><li><p><strong>为什么Java是半编译半解释型语言</strong></p><p>  JDK1.e时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p>  翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</p></li><li><p><strong>机器码、指令、汇编语言</strong></p><ul><li><p><strong>机器码</strong></p><p>  各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p><p>  机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p><p>  用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p><p>  机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p></li><li><p><strong>指令</strong></p><p>  由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p><p>  指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p><p>  由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p></li><li><p><strong>指令集</strong></p><p>  不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p><ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul></li><li><p><strong>汇编语言</strong></p><p>  由于指令的可读性还是太差，于是人们又发明了汇编语言。</p><p>  在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><blockquote><p><em>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</em></p></blockquote></li></ul></li></ul><h3 id="3-高级语言"><a href="#3-高级语言" class="headerlink" title="3.高级语言"></a>3.<strong>高级语言</strong></h3><ul><li><p>高级计算机语言</p><p>  为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。</p><p>  高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p></li></ul><p><img src="/images/jvm_virtual_machine/chapter11/image7.png" alt="Untitled"></p><p>高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++</p><ul><li><p><strong>C、C++源程序执行过程</strong></p><p>  编译过程又可以分成两个阶段：编译和汇编。</p><p>  编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p><p>  汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p><p>  <img src="/images/jvm_virtual_machine/chapter11/image8.png" alt="Untitled"></p></li><li><p><strong>字节码</strong></p><p>  字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>  字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p><p>  字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><ul><li>字节码典型的应用为：Java bytecode</li></ul></li><li><p><strong>解释器</strong></p><p>  JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><p>  <img src="/images/jvm_virtual_machine/chapter11/image9.png" alt="Untitled"></p><p>  为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的</p><p>  解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>  当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p></li><li><p><strong>解释器分类</strong></p><p>  在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><p>  字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p><p>  而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p><p>  在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li><li><p><strong>现状</strong></p><p>  由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。</p><p>  为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p><p>  不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p></li></ul><h3 id="4-JIT编译器"><a href="#4-JIT编译器" class="headerlink" title="4.JIT编译器"></a>4.<strong>JIT编译器</strong></h3><ul><li><p><strong>Java代码的执行分类</strong></p><ol><li>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</li><li>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</li><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</li></ol></li><li><p><strong>为啥我们还需要解释器呢？</strong></p><ol><li>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</li><li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li></ol></li><li><p><strong>首先明确两点：</strong></p><ol><li>当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li><li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li></ol><p>  <strong>所以：</strong></p><ol><li>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li><li>在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</li><li>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li></ol><p>  <strong>案例</strong></p><p>  注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>  在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队</p><p>  <img src="/images/jvm_virtual_machine/chapter11/image10.png" alt="Untitled">  </p></li><li><p><strong>JIT编译器相关概念</strong></p><ol><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。</li><li>也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li></ol><p>  <strong>典型的编译器：</strong></p><ol><li>前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li><li>JIT编译器：HotSpot VM的C1、C2编译器。</li><li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ol></li><li><p><strong>热点代码及探测方式</strong></p><ol><li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li><li>关于那些需要被编译为本地代码的字节码，也被称之为**“热点代码”<strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出</strong>深度优化**，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li><li>一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。</li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li><li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。<ol><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ol></li></ol></li><li><p><strong>方法调用计数器</strong></p><ol><li><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p></li><li><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p></li><li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本</p><ul><li>如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul><li>如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li>如果未超过阈值，则使用解释器对字节码文件解释执行</li></ul></li></ul><p> <img src="/images/jvm_virtual_machine/chapter11/image11.png" alt="Untitled"></p></li></ol></li><li><p><strong>热度衰减</strong></p><ol><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ol></li><li><p><strong>回边计数器</strong></p><p>  它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><p>  <img src="/images/jvm_virtual_machine/chapter11/image12.png" alt="Untitled"></p></li><li><p><strong>HotSpotVM 可以设置程序执行方法</strong></p><p>  缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>Xint：完全采用解释器模式执行程序；</li><li>Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter11/image13.png" alt="Untitled">  </p></li><li><p><strong>HotSpotVM JIT 分类</strong></p><p>  在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ol><li>client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li></ul></li><li>server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul><li>C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）</li></ul></li></ol></li><li><p><strong>C1和C2编译器不同的优化策略</strong></p><ol><li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ol></li><li><p><strong>分层编译策略</strong></p><ol><li>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</li><li>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</li><li>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</li><li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li></ol></li><li><p><strong>Graal 编译器</strong></p><ul><li>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</li><li>编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用<ul><li>XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</li></ul></li></ul></li><li><p><strong>AOT编译器</strong></p><ol><li><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p></li><li><p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p></li><li><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。</p><p> .java -&gt; .class -&gt; (使用jaotc) -&gt; .so</p></li></ol></li><li><p><strong>AOT编译器编译器的优缺点</strong></p><p>  <strong>最大的好处：</strong></p><ol><li>Java虚拟机加载已经预编译成二进制库，可以直接执行。</li><li>不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li></ol><p>  <strong>缺点：</strong></p><ol><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ol></li><li><p><strong>最后</strong></p><ul><li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li><li>编译效果短短几年时间就追评了G2编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li></ul></li></ul>]]></content>
    
    
    <summary type="html">执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器。执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(四)**运行时数据区概述及线程</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%9B%9B)%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%9B%9B)%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-02-09T16:00:00.000Z</published>
    <updated>2025-09-03T15:25:05.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-四-运行时数据区概述及线程"><a href="#JVM虚拟机详解-四-运行时数据区概述及线程" class="headerlink" title="JVM虚拟机详解(四)运行时数据区概述及线程"></a>JVM虚拟机详解(四)<strong>运行时数据区概述及线程</strong></h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="/images/jvm_virtual_machine/chapter4/image.png" alt="Untitled"></p><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><p><img src="/images/jvm_virtual_machine/chapter4/image1.png" alt="Untitled"></p><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p><img src="/images/jvm_virtual_machine/chapter4/image2.png" alt="Untitled"></p><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p><blockquote><p><em>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</em></p></blockquote><ul><li><p><strong>运行时数据区的完整图</strong></p><p>  <img src="/images/jvm_virtual_machine/chapter4/image3.png" alt="Untitled"></p><p>  Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>  灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter4/image4.png" alt="Untitled"></p></li></ul><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><ul><li><strong>JVM 线程</strong><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol></li><li><strong>JVM 系统线程</strong><ul><li>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</li><li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：<ol><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol></li></ul></li></ul>]]></content>
    
    
    <summary type="html">当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(九)方法区**Method Area</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B9%9D)%E6%96%B9%E6%B3%95%E5%8C%BAMethod%20Area/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B9%9D)%E6%96%B9%E6%B3%95%E5%8C%BAMethod%20Area/</id>
    <published>2023-02-08T16:00:00.000Z</published>
    <updated>2025-09-03T15:18:45.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-九-方法区Method-Area"><a href="#JVM虚拟机详解-九-方法区Method-Area" class="headerlink" title="JVM虚拟机详解(九)方法区Method Area"></a>JVM虚拟机详解(九)方法区<strong>Method Area</strong></h2><h3 id="1-栈、堆、方法区的交互关系"><a href="#1-栈、堆、方法区的交互关系" class="headerlink" title="1. 栈、堆、方法区的交互关系"></a>1. <strong>栈、堆、方法区的交互关系</strong></h3><ul><li><p><strong>从线程共享与否的角度来看</strong></p><ul><li>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter9/image.png" alt="Untitled"></p><ul><li><p>从线程共享与否的角度来看</p><p>  ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p></li></ul><p>  <img src="/images/jvm_virtual_machine/chapter9/image1.png" alt="Untitled">  </p></li><li><p><strong>栈、堆、方法区的交互关系</strong></p><ul><li>下面就涉及了对象的访问定位</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter9/image2.png" alt="Untitled"></p><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul></li><li><p><strong>方法区的理解</strong></p><ul><li>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。所以，方法区看作是一块独立于Java堆的内存空间。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter9/image3.png" alt="Untitled"></p><p>  方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul></li><li><p><strong>HotSpot中方法区的演进</strong></p><p>  在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><ul><li>JDK 1.8后，元空间存放在堆外内存中</li></ul><p>  本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。</p><p>  <em>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</em></p><p>  <img src="/images/jvm_virtual_machine/chapter9/image4.png" alt="Untitled"></p><p>  而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image5.png" alt="Untitled"></p><p>  元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p><p>  永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>  根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常  </p></li><li><p><strong>设置方法区大小与OOM</strong></p><ul><li>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</li></ul></li><li><p><strong>jdk7及以前</strong></p><ul><li><p>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</p></li><li><p>XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</p></li><li><p>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image6.png" alt="Untitled"></p></li><li><p><strong>JDK8以后</strong></p><p>  元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>  默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p><p>  与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><ul><li>XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</li></ul><p>  如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p></li></ul></li><li><p><strong>如何解决这些OOM</strong></p><ul><li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）<ul><li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ul></li></ul><h3 id="2-方法区的内部结构"><a href="#2-方法区的内部结构" class="headerlink" title="2.方法区的内部结构"></a>2.<strong>方法区的内部结构</strong></h3><ul><li><p>关系图</p><p>  《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p></li></ul><p><img src="/images/jvm_virtual_machine/chapter9/image7.png" alt="Untitled"></p><p><img src="/images/jvm_virtual_machine/chapter9/image8.png" alt="Untitled"></p><ul><li><p><strong>类型信息</strong></p><p>  对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul></li><li><p><strong>域信息</strong></p><p>  JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>  域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p></li><li><p><strong>方法（Method）信息</strong></p><p>  JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p></blockquote></li><li><p><strong>non-final的类变量</strong></p><p>  静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>  类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.area;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * non-final的类变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-02-12 18:42:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// hello!</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>  如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p></li><li><p><strong>全局常量：static final</strong></p><ol><li>全局常量就是使用 static final 进行修饰</li><li>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</li></ol><p>  查看上面代码，这部分的字节码指令</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>  可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。****</p></li></ul><h3 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3.常量池"></a>3.<strong>常量池</strong></h3><ul><li><p><strong>常量池概述</strong></p><ul><li><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p>  <img src="/images/jvm_virtual_machine/chapter9/image9.png" alt="Untitled"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul></li></ul></li><li><p><strong>常量池</strong></p><p>  一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image10.png" alt="Untitled"></p></li><li><p><strong>为什么需要常量池</strong></p><p>  一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。</p><p>  比如：如下的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。</li><li>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li><li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li></ol></li><li><p><strong>常量池中有啥？</strong></p><ol><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ol><p>  例如下面这段代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.area;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  将会被翻译成如下字节码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>: astore_1</span><br><span class="line"><span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常量池总结</strong></p><p>  常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p></li></ul><h3 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4.运行时常量池"></a>4.<strong>运行时常量池</strong></h3><ul><li><p><strong>运行时常量池</strong></p><ol><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。（运行时常量池就是常量池在程序运行时的称呼）</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。<ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</li></ul></li><li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</li></ol></li><li><p><strong>方法区的使用举例</strong></p><ul><li><p>代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.area;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字节码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.peppa.area.MethodAreaDemo</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">25</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">26.</span>#<span class="number">27</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">30</span>            <span class="comment">// com/peppa/area/MethodAreaDemo</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">31</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">8</span> = Utf8               Code</span><br><span class="line">   #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">12</span> = Utf8               Lcom/peppa/area/MethodAreaDemo;</span><br><span class="line">  #<span class="number">13</span> = Utf8               main</span><br><span class="line">  #<span class="number">14</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">15</span> = Utf8               args</span><br><span class="line">  #<span class="number">16</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">17</span> = Utf8               x</span><br><span class="line">  #<span class="number">18</span> = Utf8               I</span><br><span class="line">  #<span class="number">19</span> = Utf8               y</span><br><span class="line">  #<span class="number">20</span> = Utf8               a</span><br><span class="line">  #<span class="number">21</span> = Utf8               b</span><br><span class="line">  #<span class="number">22</span> = Utf8               MethodParameters</span><br><span class="line">  #<span class="number">23</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">24</span> = Utf8               MethodAreaDemo.java</span><br><span class="line">  #<span class="number">25</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">26</span> = Class              #<span class="number">32</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">27</span> = NameAndType        #<span class="number">33</span>:#<span class="number">34</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">28</span> = Class              #<span class="number">35</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">36</span>:#<span class="number">37</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">30</span> = Utf8               com/peppa/area/MethodAreaDemo</span><br><span class="line">  #<span class="number">31</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">32</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">33</span> = Utf8               out</span><br><span class="line">  #<span class="number">34</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">35</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">36</span> = Utf8               println</span><br><span class="line">  #<span class="number">37</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.peppa.area.MethodAreaDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/peppa/area/MethodAreaDemo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: sipush        <span class="number">500</span></span><br><span class="line">         <span class="number">3</span>: istore_1</span><br><span class="line">         <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: iload_2</span><br><span class="line">         <span class="number">9</span>: idiv</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: bipush        <span class="number">50</span></span><br><span class="line">        <span class="number">13</span>: istore        <span class="number">4</span></span><br><span class="line">        <span class="number">15</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">21</span>: iadd</span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">25</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">26</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">4</span>      <span class="number">22</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">7</span>      <span class="number">19</span>     <span class="number">2</span>     y   I</span><br><span class="line">           <span class="number">11</span>      <span class="number">15</span>     <span class="number">3</span>     a   I</span><br><span class="line">           <span class="number">15</span>      <span class="number">11</span>     <span class="number">4</span>     b   I</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>图解字节码指令执行流程</strong></p><p>  <img src="/images/jvm_virtual_machine/chapter9/image11.png" alt="Untitled"></p><p>  首先现将操作数500放入到操作数栈中</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image12.png" alt="Untitled"></p><p>  然后存储到局部变量表中</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image13.png" alt="Untitled"></p><p>  然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image14.png" alt="Untitled"></p><p>  将500 和 100 进行一个除法运算，在把结果入栈</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image15.png" alt="Untitled"></p><p>  在最后就是输出流，需要调用运行时常量池的常量</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image16.png" alt="Untitled"></p><p>  最后调用invokevirtual（虚方法调用），然后返回</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image17.png" alt="Untitled"></p><p>  返回时</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image18.png" alt="Untitled"></p><p>  程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p><p>  <strong>符号引用 –&gt; 直接引用：</strong></p><ol><li>上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li><li>如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</li></ol></li></ul><h3 id="5-方法区的演进细节"><a href="#5-方法区的演进细节" class="headerlink" title="5.方法区的演进细节"></a>5.<strong>方法区的演进细节</strong></h3><ul><li><p><strong>永久代演进过程</strong></p><ul><li>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</li></ul></li><li><p>Hotspot中方法区的变化：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JDK1<span class="number">.6</span>及以前  有永久代（permanent generation），静态变量存储在永久代上</span><br><span class="line">JDK1<span class="number">.7</span>       有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</span><br><span class="line">JDK1<span class="number">.8</span>       无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</span><br></pre></td></tr></table></figure></li><li><p><strong>JDK6</strong></p><p>  方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image19.png" alt="Untitled"></p></li><li><p><strong>JDK7</strong></p><p>  方法区由永久代实现，使用 JVM 虚拟机内存</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image20.png" alt="Untitled"></p></li><li><p>JDK8</p><p>  元空间大小只受物理内存影响</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image21.png" alt="Untitled"></p></li><li><p><strong>永久代为什么要被元空间替代？</strong></p><blockquote><p>官方文档：<a href="http://openjdk.java.net/jeps/122">JEP 122: Remove the Permanent Generation (java.net)</a></p></blockquote><ul><li>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</li><li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li><li>这项改动是很有必要的，原因有：<ol><li>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低<strong>Full GC</strong><ol><li>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li><li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li></ol></li></ol></li></ul></li><li><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p><ul><li>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</li><li>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</li></ul></li><li><p><strong>方法区的垃圾回收</strong></p><ul><li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p></li><li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p></li><li><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p></li><li><p>先来说说方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong>。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p></li><li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p></li></ul></li><li><p><strong>类卸载</strong></p><ul><li>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：<ul><li><strong>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</strong></li><li><strong>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</strong></li><li><strong>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</strong></li></ul></li><li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用**<code>-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading</code>**查看类加载和卸载信息</li><li><strong>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力</strong>，以保证不会对方法区造成过大的内存压力。</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter9/image22.png" alt="Untitled"></p></li></ul><h3 id="6-直接内存-Direct-Memory"><a href="#6-直接内存-Direct-Memory" class="headerlink" title="6.直接内存 Direct Memory"></a>6.<strong>直接内存 Direct Memory</strong></h3><ul><li><p><strong>直接内存概述</strong></p><ol><li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li><li>直接内存是在Java堆外的、直接向系统申请的内存区间。</li><li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li><li>通常，访问直接内存的速度会优于Java堆。即读写性能高。</li><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ol></li><li><p>使用下列代码，直接分配本地内存空间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>; <span class="comment">// 1GB</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br></pre></td></tr></table></figure><ul><li><strong>非直接缓存区和缓存区</strong></li></ul><p>NIO的方式使用了缓存区的概念</p><p><img src="/images/jvm_virtual_machine/chapter9/image23.png" alt="Untitled"></p><ul><li><p><strong>存在的问题</strong></p><p>  也可能导致outofMemoryError异常</p><p>  由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 缺点</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul><p>  直接内存大小可以通过MaxDirectMemorySize设置</p><p>  如果不指定，默认与堆的最大值-xmx参数值一致</p><p>  <img src="/images/jvm_virtual_machine/chapter9/image24.png" alt="Untitled"></p></li></ul>]]></content>
    
    
    <summary type="html">方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(八)堆Heap</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%85%AB)%E5%A0%86Heap/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%85%AB)%E5%A0%86Heap/</id>
    <published>2023-02-07T16:00:00.000Z</published>
    <updated>2025-09-03T15:17:12.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-八-堆Heap"><a href="#JVM虚拟机详解-八-堆Heap" class="headerlink" title="JVM虚拟机详解(八)堆Heap"></a>JVM虚拟机详解(八)堆Heap</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul><li>概述<ul><li>Java 虚拟机有一个堆，它在所有 Java 虚拟机线程之间共享。堆是运行时数据区域，从中分配所有类实例和数组的内存。</li><li>在虚拟机启动时创建堆。对象的堆存储由自动存储管理系统(称为垃圾收集器)回收; 对象永远不会显式释放。Java 虚拟机没有特定类型的自动存储管理系统，可以根据实现者的系统需求选择存储管理技术。堆的大小可以是固定的，也可以根据计算的需要进行扩展，如果不需要更大的堆，还可以进行收缩。堆的内存不需要是连续的。</li><li><em>一个 Java 虚拟机实现可以提供程序员或用户对堆的初始大小的控制，以及，如果堆可以动态扩展或收缩，对堆的最大和最小大小的控制。</em></li><li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</li><li>《Java虚拟机规范》中对Java堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）• 从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li><li>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。<ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul></li><li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li></ul></li><li><strong>下列异常情况与堆相关联:</strong><ul><li>如果计算需要比自动存储管理系统所能提供的更多的堆，那么 Java 虚拟机将抛出 OutOfMemoryError 错误。</li></ul></li><li>默认堆大小：<ul><li>Xms：初始大小内存，默认为物理内存64&#x2F;1，等价于-XX:InitialHeapSize</li><li>Xmx：最大分配内存，默认为物理内存的4&#x2F;1，等价于：-XXMaxHeapSize</li></ul></li></ul><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.6">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p><p><img src="/Untitled.png" alt="Untitled"></p><p><img src="/Untitled%201.png" alt="Untitled"></p><ul><li><p><strong>堆内存细分</strong></p><p>  现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p><ol><li>Java7 及之前堆内存逻辑上分为三部分：新生代+老年代+永久区<ul><li>Young Generation Space 新生代 Young&#x2F;New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Old generation space 老年代 Old&#x2F;Tenure</li><li>Permanent Space 永久区 Perm</li></ul></li><li>Java 8及之后堆内存逻辑上分为三部分：新生代+老年代+元空间</li></ol><ul><li>Young Generation Space 新生代，又被划分为Eden区和Survivor区</li><li>Old generation space 老年代</li><li>Meta Space 元空间 Meta</li></ul><p>  <img src="/Untitled%202.png" alt="Untitled"></p></li></ul><p>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</p><p><img src="/Untitled%203.png" alt="Untitled"></p><h3 id="2-JVisualVM可视化查看堆内存"><a href="#2-JVisualVM可视化查看堆内存" class="headerlink" title="2.JVisualVM可视化查看堆内存"></a>2.<strong>JVisualVM可视化查看堆内存</strong></h3><p>运行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、双击jdk目录下的这个文件</p><p><img src="/Untitled%204.png" alt="Untitled"></p><p>2、工具 -&gt; 插件 -&gt; 安装Visual GC插件</p><p><img src="/Untitled%205.png" alt="Untitled"></p><p>3、运行上面的代码</p><h3 id="3-设置堆内存大小与OOM"><a href="#3-设置堆内存大小与OOM" class="headerlink" title="3.设置堆内存大小与OOM"></a>3.<strong>设置堆内存大小与OOM</strong></h3><ul><li><p><strong>设置堆内存</strong></p><ol><li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。</p><ul><li><strong>Xms</strong>用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**</li><li><strong>Xmx</strong>则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</li></ul></li><li><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</p></li><li><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p><ul><li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li><li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li></ul></li><li><p>默认情况下:</p><ul><li>初始内存大小：物理电脑内存大小&#x2F;64</li><li>最大内存大小：物理电脑内存大小&#x2F;4</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *  -X：是jvm运行参数</span></span><br><span class="line"><span class="comment"> *  ms：memory start</span></span><br><span class="line"><span class="comment"> * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-11 14:33:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机试图使用的最大堆内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms:&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">-Xms:303M</span><br><span class="line">-Xmx:4482M</span><br></pre></td></tr></table></figure></li></ol></li><li><p>如何查看堆内存的内存分配情况</p><ul><li><p><code>jps  -&gt;  staat -gc  进程id</code></p><p>  参数说明：</p><ul><li>SOC: S0区总共容量</li><li>S1C: S1区总共容量</li><li>S0U: S0区使用的量</li><li>S1U: S1区使用的量</li><li>EC: 伊甸园区总共容量</li><li>EU: 伊甸园区使用的量</li><li>OC: 老年代总共容量</li><li>OU: 老年代使用的量</li></ul><p>  <img src="/Untitled%206.png" alt="Untitled"></p><p>  <code>-XX:+PrintGCDetails</code></p><p>  <img src="/Untitled%207.png" alt="Untitled"></p></li></ul></li><li><p><strong>OutOfMemory</strong>测试</p></li></ul><p>添加参数：Xms600m -Xmx600m -XX:+PrintGCDetails</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\bin\java.exe -Xms600m -Xmx600m -XX:+PrintGCDetails <span class="string">&quot;-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2021.3.1\lib\idea_rt.jar=4979:D:\Program Files\JetBrains\IntelliJ IDEA 2021.3.1\bin&quot;</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\charsets.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\deploy.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\cldrdata.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\dnsns.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\jaccess.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\jfxrt.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\localedata.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\nashorn.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\sunec.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\sunjce_provider.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\sunmscapi.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\sunpkcs11.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\ext\zipfs.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\javaws.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\jce.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\jfr.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\jfxswt.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\jsse.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\management-agent.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\plugin.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\resources.jar;D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\jre\lib\rt.jar;E:\workspace\IdeaWork\other\peppa-platform\peppa-jvm\target\classes com.peppa.heap.OutOfMemoryTest</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 152578K-&gt;25384K(179200K)] 152578K-&gt;145202K(588800K), <span class="number">0.0190912</span> secs] [Times: user=<span class="number">0.05</span> sys=<span class="number">0.08</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 178893K-&gt;25336K(179200K)] 298711K-&gt;297740K(588800K), <span class="number">0.0233429</span> secs] [Times: user=<span class="number">0.05</span> sys=<span class="number">0.06</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 25336K-&gt;0K(179200K)] [ParOldGen: 272404K-&gt;297589K(409600K)] 297740K-&gt;297589K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], <span class="number">0.0556161</span> secs] [Times: user=<span class="number">0.28</span> sys=<span class="number">0.00</span>, real=<span class="number">0.05</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 153530K-&gt;37888K(179200K)] [ParOldGen: 297589K-&gt;409208K(409600K)] 451120K-&gt;447096K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], <span class="number">0.0254560</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.05</span>, real=<span class="number">0.03</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 153506K-&gt;152578K(179200K)] [ParOldGen: 409208K-&gt;409208K(409600K)] 562714K-&gt;561786K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], <span class="number">0.0175328</span> secs] [Times: user=<span class="number">0.11</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 152578K-&gt;152578K(179200K)] [ParOldGen: 409208K-&gt;409190K(409600K)] 561786K-&gt;561768K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], <span class="number">0.0235650</span> secs] [Times: user=<span class="number">0.11</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 179200K, used 153600K [<span class="number">0x00000000f3800000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 153600K, <span class="number">100</span>% used [<span class="number">0x00000000f3800000</span>,<span class="number">0x00000000fce00000</span>,<span class="number">0x00000000fce00000</span>)</span><br><span class="line">  from space 25600K, <span class="number">0</span>% used [<span class="number">0x00000000fe700000</span>,<span class="number">0x00000000fe700000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 25600K, <span class="number">0</span>% used [<span class="number">0x00000000fce00000</span>,<span class="number">0x00000000fce00000</span>,<span class="number">0x00000000fe700000</span>)</span><br><span class="line"> ParOldGen       total 409600K, used 409194K [<span class="number">0x00000000da800000</span>, <span class="number">0x00000000f3800000</span>, <span class="number">0x00000000f3800000</span>)</span><br><span class="line">  object space 409600K, <span class="number">99</span>% used [<span class="number">0x00000000da800000</span>,<span class="number">0x00000000f379abf0</span>,<span class="number">0x00000000f3800000</span>)</span><br><span class="line"> Metaspace       used 3260K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 353K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: **Java heap space**</span><br><span class="line">at com.peppa.heap.OutOfMemoryTest.main(OutOfMemoryTest.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="4-年轻代与老年代"><a href="#4-年轻代与老年代" class="headerlink" title="4.年轻代与老年代"></a>4.<strong>年轻代与老年代</strong></h3><ul><li><p>存储对象划分：</p><ul><li>存储在JVM中的Java对象可以被划分为两类：<ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速，生命周期短的，及时回收即可。</li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul></li><li>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</li><li>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</li></ul><p>  <img src="/Untitled%208.png" alt="Untitled"></p><p>  下面这参数开发中一般不会调：</p><p>  <img src="/Untitled%209.png" alt="Untitled"></p><ul><li>配置新生代与老年代在堆结构的占比<ul><li>默认**-XX:NewRatio**&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</li><li>可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</li></ul></li></ul><ol><li>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，</li><li>当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8</li><li>几乎所有的Java对象都是在Eden区被new出来的。</li><li>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li><li>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</li></ol><p>  <img src="/Untitled%2010.png" alt="Untitled"></p></li></ul><h3 id="5-图解对象分配过程"><a href="#5-图解对象分配过程" class="headerlink" title="5.图解对象分配过程"></a>5.<strong>图解对象分配过程</strong></h3><ul><li><p><strong>概念</strong></p><p>  为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><p>  可以设置参数：-Xx:MaxTenuringThreshold&#x3D; N进行设置  </p></li><li><p><strong>图解过程</strong></p><p>  我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC &#x2F; Minor GC操作</p><p>  <img src="/Untitled%2011.png" alt="Untitled"></p><p>  当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p><p>  同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><p>  <img src="/Untitled%2012.png" alt="Untitled"></p><p>  我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中</p><p>  <img src="/Untitled%2013.png" alt="Untitled"></p></li><li><p><strong>幸存区区满了后？</strong></p><p>  特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>  如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p></li><li><p><strong>对象分配的特殊情况</strong></p><ol><li>如果来了一个新对象，先看看 Eden 是否放的下？<ul><li>如果 Eden 放得下，则直接放到 Eden 区</li><li>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li></ul></li><li>将对象放到老年区又有两种情况：<ul><li>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</li><li>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM</li></ul></li><li>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</li></ol><p>  <img src="/Untitled%2014.png" alt="Untitled">  </p></li><li><p><strong>代码演示对象分配过程</strong></p></li></ul><p>我们不断的创建大对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码演示对象创建过程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-02-11 17:27:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapInstanceTest</span> &#123;</span><br><span class="line">    <span class="type">byte</span> [] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HeapInstanceTest</span>());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置JVM参数：<code>-Xms600m -Xmx600m</code></p><p>打开VisualVM图形化界面</p><p><img src="/Untitled.gif" alt="Untitled"></p><p>最终，在老年代和新生代都满了，就出现OOM</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\software\Java\jdk1<span class="number">.8</span>\jdk1<span class="number">.8</span><span class="number">.0_241</span>\bin\java.exe -Xms600m -Xmx600m</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.peppa.heap.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:<span class="number">12</span>)</span><br><span class="line">at com.peppa.heap.HeapInstanceTest.main(HeapInstanceTest.java:<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>常用调优工具</strong></p><ol><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控，推荐）</li><li>Jprofiler（IDEA插件）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ol></li><li><p><strong>GC分类</strong></p><ul><li><p><strong>Minor GC，MajorGC、Full GC</strong></p><ul><li>Minor GC：新生代的GC</li><li>Major GC：老年代的GC</li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><blockquote><p><em>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题，而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</em></p></blockquote></li><li><p><strong>部分收集（Partial GC）&amp;&amp; 整堆收集（FullGC）</strong></p><ul><li>新生代收集（MinorGC&#x2F;YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC&#x2F;o1dGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li></ul></li><li><p><strong>整堆收集（FullGC）</strong>：收集整个java堆和方法区的垃圾收集。</p></li><li><p><strong>Young GC</strong></p><p>  当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>  因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>  Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><p>  <img src="/Untitled%2015.png" alt="Untitled"></p></li><li><p><strong>老年代GC（MajorGC）触发机制</strong></p><ol><li>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</li><li>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）<ul><li>也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC</li></ul></li><li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li><li>如果Major GC后，内存还不足，就报OOM了</li></ol></li><li><p><strong>触发Full GC执行的情况有如下五种：</strong></p><ol><li>调用System.gc()时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol></li></ul></li><li><p><strong>GC日志分析</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试MinorGC 、 MajorGC、FullGC</span></span><br><span class="line"><span class="comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;this is peppa&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  输出：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1964K-&gt;510K(2560K)] 1964K-&gt;826K(9728K), <span class="number">0.0008721</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2361K-&gt;496K(2560K)] 2677K-&gt;1489K(9728K), <span class="number">0.0007112</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1796K-&gt;384K(2560K)] 2790K-&gt;2417K(9728K), <span class="number">0.0009442</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2151K-&gt;0K(2560K)] [ParOldGen: 7025K-&gt;5682K(7168K)] 9177K-&gt;5682K(9728K), [Metaspace: 3227K-&gt;3227K(1056768K)], <span class="number">0.0029911</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5682K-&gt;5682K(9728K), <span class="number">0.0004552</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5682K-&gt;5599K(7168K)] 5682K-&gt;5599K(9728K), [Metaspace: 3227K-&gt;3227K(1056768K)], <span class="number">0.0058927</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">遍历次数为：<span class="number">16</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 101K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 2048K, <span class="number">4</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd19568</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 5599K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">78</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffb77d90</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3259K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 353K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:<span class="number">3332</span>)</span><br><span class="line">at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="number">124</span>)</span><br><span class="line">at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="number">448</span>)</span><br><span class="line">at java.lang.StringBuilder.append(StringBuilder.java:<span class="number">136</span>)</span><br><span class="line">at com.peppa.gc.GCTest.main(GCTest.java:<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1964K-&gt;510K(2560K)] 1964K-&gt;826K(9728K), <span class="number">0.0008721</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br></pre></td></tr></table></figure><ul><li>[PSYoungGen: 1964K-&gt;510K(2560K)]：年轻代总空间为 2560K ，当前占用 1964K ，经过垃圾回收后剩余510K****</li><li>1964K-&gt;826K(9728K)：堆内存总空间为 9728K ，当前占用1964K，经过垃圾回收后剩余826K</li></ul><p>  <img src="/Untitled%2016.png" alt="Untitled"></p><p>  <img src="/Untitled%2017.png" alt="Untitled">  </p></li><li><p><strong>堆空间分代思想</strong></p><p>  为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。</li><li>老年代：存放新生代中经历多次GC仍然存活的对象。</li></ul><p>  <img src="/Untitled%2018.png" alt="Untitled"></p><p>  其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p>  <img src="/Untitled%2019.png" alt="Untitled">  </p></li><li><p><strong>内存分配策略</strong></p><p>  如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>  对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p><p>  针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden<ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>  空间分配担保： -Xx:HandlePromotionFailure</p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul></li><li><p><strong>为对象分配内存：TLAB</strong></p><ul><li><p><strong>问题：堆空间都是共享的么？</strong></p><p>  不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p></li><li><p><strong>为什么有TLAB？</strong></p><p>  从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>  多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>  据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><p>  <img src="/Untitled%2020.png" alt="Untitled"></p><p>  尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>  在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p><p>  默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>  一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p></li><li><p><strong>TLAB分配过程</strong></p><p>  对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p>  <img src="/Untitled%2021.png" alt="Untitled"></p></li></ul></li><li><p><strong>小结：堆空间的参数设置</strong></p><ul><li>XX：+PrintFlagsInitial：查看所有的参数的默认初始值</li><li>XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</li><li><strong>Xms：初始堆空间内存（默认为物理内存的1&#x2F;64）</strong></li><li><strong>Xmx：最大堆空间内存（默认为物理内存的1&#x2F;4）</strong></li><li>Xmn：设置新生代的大小。（初始值及最大值）</li><li>XX:NewRatio：配置新生代与老年代在堆结构的占比</li><li>XX:SurvivorRatio：设置新生代中Eden和S0&#x2F;S1空间的比例</li><li>XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</li><li>XX：+PrintGCDetails：输出详细的GC处理日志<ul><li>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</li></ul></li><li>XX:HandlePromotionFalilure：是否设置空间分配担保</li></ul><p>  在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul><li>如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次FullGC。</li><li>如果HandlePromotionFailure&#x3D;false，则改为进行一次Full GC</li></ul></li></ul><p>  在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p></li><li><p><strong>堆是分配对象的唯一选择么？</strong></p><p>  <strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p><ol><li>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li><li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li><li>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li></ol></li></ul><h3 id="6-逃逸分析"><a href="#6-逃逸分析" class="headerlink" title="6.逃逸分析"></a>6.<strong>逃逸分析</strong></h3><ul><li><p><strong>逃逸分析</strong></p><ol><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li><li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ol></li><li><p><strong>逃逸分析举例</strong></p><ul><li>没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果想要StringBuffer sb不发生逃逸，可以这样写</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span>? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>逃逸分析参数设置</strong></p><ol><li>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</li><li>如果使用的是较早的版本，开发人员则可以通过：<ul><li>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul></li></ol></li><li><p><strong>结论</strong></p><p>  开发中能使用局部变量的，就不要使用在方法外定义。</p><p>  使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul></li></ul><h3 id="7-栈上分配"><a href="#7-栈上分配" class="headerlink" title="7.栈上分配"></a>7.<strong>栈上分配</strong></h3><ul><li><p><strong>栈上分配举例</strong></p><ul><li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li><li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li></ul></li><li><p>举例</p><ul><li><p>设置JVM参数，表示未开启逃逸分析</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配：</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 开启逃逸分析：</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAllocation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String age;</span><br><span class="line">        <span class="keyword">private</span> String gender;</span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数：<code>-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</code></p></li><li><p>运行结果，同时还触发了GC操作</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 262144K-&gt;728K(305664K)] 262144K-&gt;736K(1005056K), <span class="number">0.0007353</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">花费的时间为： <span class="number">120</span> ms</span><br></pre></td></tr></table></figure></li></ul></li><li><p>我们开启逃逸分析</p><ul><li><p>参数：<code>-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</code></p></li><li><p>运行结果：日志打印：并没有发生 GC ，耗时5ms 。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为： <span class="number">5</span> ms</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="8-同步省略"><a href="#8-同步省略" class="headerlink" title="8.同步省略"></a>8.<strong>同步省略</strong></h3><ul><li><p>概述：线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>  在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>  例如下面的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/Object&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="number">4</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">7</span> astore_1</span><br><span class="line"><span class="number">8</span> aload_1</span><br><span class="line"><span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> monitorenter</span><br><span class="line"><span class="number">12</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">15</span> aload_1</span><br><span class="line"><span class="number">16</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">19</span> aload_2</span><br><span class="line"><span class="number">20</span> monitorexit</span><br><span class="line"><span class="number">21</span> <span class="keyword">goto</span> <span class="number">29</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">24</span> astore_3</span><br><span class="line"><span class="number">25</span> aload_2</span><br><span class="line"><span class="number">26</span> monitorexit</span><br><span class="line"><span class="number">27</span> aload_3</span><br><span class="line"><span class="number">28</span> athrow</span><br><span class="line"><span class="number">29</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>  注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p></li></ul><h3 id="9-分离对象或标量替换"><a href="#9-分离对象或标量替换" class="headerlink" title="9.分离对象或标量替换"></a>9.<strong>分离对象或标量替换</strong></h3><ol><li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li><li>相对的，那些还可以分解的数据叫做<strong>聚合量（Aggregate）</strong>，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li><li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</li></ol><ul><li><p><strong>标量替换举例</strong></p><ul><li>代码</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码，经过标量替换后，就会变成</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。  </p></li><li><p><strong>标量替换参数设置</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不开启标量替换：</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [GC (Allocation Failure)  25600K-&gt;816K(98304K), 0.0007805 secs]</span></span><br><span class="line"><span class="comment"> * [GC (Allocation Failure)  26416K-&gt;832K(98304K), 0.0005552 secs]</span></span><br><span class="line"><span class="comment"> * [GC (Allocation Failure)  26432K-&gt;704K(98304K), 0.0010244 secs]</span></span><br><span class="line"><span class="comment"> * [GC (Allocation Failure)  26304K-&gt;752K(98304K), 0.0006991 secs]</span></span><br><span class="line"><span class="comment"> * [GC (Allocation Failure)  26352K-&gt;704K(98304K), 0.0006366 secs]</span></span><br><span class="line"><span class="comment"> * [GC (Allocation Failure)  26304K-&gt;720K(101376K), 0.0008407 secs]</span></span><br><span class="line"><span class="comment"> * [GC (Allocation Failure)  32464K-&gt;652K(101376K), 0.0010512 secs]</span></span><br><span class="line"><span class="comment"> * [GC (Allocation Failure)  32396K-&gt;652K(100352K), 0.0003788 secs]</span></span><br><span class="line"><span class="comment"> * 花费的时间为： 64 ms</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开启标量替换：</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> *  花费的时间为： 4 ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplace</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;peppa&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>逃逸分析的不足</strong></p><ol><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li><li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li></ol></li><li><p><strong>小结</strong></p><ol><li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li><li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</li><li>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；</li><li>如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；</li><li>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li><li>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</li><li>当GC发生在老年代时则被称为Major GC或者Full GC。</li><li>一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li></ol></li></ul>]]></content>
    
    
    <summary type="html">概述:Java 虚拟机有一个堆，它在所有 Java 虚拟机线程之间共享。堆是运行时数据区域，从中分配所有类实例和数组的内存。</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>VM虚拟机详解(七)**虚拟机栈Virtual Machine Stacks</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%83)%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88Virtual%20Machine%20Stacks/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%83)%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88Virtual%20Machine%20Stacks/</id>
    <published>2023-02-06T16:00:00.000Z</published>
    <updated>2025-09-03T15:16:25.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-七-虚拟机栈Virtual-Machine-Stacks"><a href="#JVM虚拟机详解-七-虚拟机栈Virtual-Machine-Stacks" class="headerlink" title="JVM虚拟机详解(七)虚拟机栈Virtual Machine Stacks"></a>JVM虚拟机详解(七)<strong>虚拟机栈Virtual Machine Stacks</strong></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>每个 Java 虚拟机线程都有一个专用的 Java 虚拟机堆栈，与线程同时创建。Java 虚拟机堆栈存储帧(2.6)。Java 虚拟机堆栈类似于传统语言(如 c)的堆栈: 它保存局部变量和部分结果，并在方法调用和返回中发挥作用。因为 Java 虚拟机堆栈从来不会被直接操作，除了推送和弹出框架，框架可能会被分配到堆中。Java 虚拟机堆栈的内存不需要是连续的。</p><p><em>在 Java 虚拟机规范的第一版中，Java 虚拟机堆栈被称为 Java 堆栈。</em></p><p>该规范允许 Java 虚拟机堆栈具有固定的大小，或者根据计算的需要动态扩展和收缩。如果 Java 虚拟机堆栈的大小是固定的，那么在创建该堆栈时可以独立地选择每个 Java 虚拟机堆栈的大小。</p><p>一个 Java 虚拟机实现可以为程序员或用户提供对 Java 虚拟机堆栈初始大小的控制，以及，在动态扩展或收缩 Java 虚拟机堆栈的情况下，对最大和最小大小的控制。</p><ul><li><strong>下列异常情况与 Java 虚拟机堆栈相关:</strong><ul><li>如果线程中的计算需要比允许的更大的 Java 虚拟机堆栈，则 Java 虚拟机抛出 StackOverflowError。</li><li>如果 Java 虚拟机堆栈可以动态扩展，并且尝试扩展，但是没有足够的内存来实现扩展，或者如果没有足够的内存来为新线程创建初始的 Java 虚拟机堆栈，Java 虚拟机抛出 OutOfMemoryError。</li></ul></li><li>默认堆大小：<ul><li>Xms：初始大小内存，默认为物理内存64&#x2F;1，等价于-XX:InitialHeapSize</li><li>Xmx：最大分配内存，默认为物理内存的4&#x2F;1，等价于：-XXMaxHeapSize</li></ul></li><li>默认栈大小：<ul><li>XX:ThreadStackSize设为0，就是使用“系统默认值”。而在Linux x64上HotSpot VM给Java栈定义的“系统默认”大小也是1MB。</li></ul></li></ul><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.6">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p><ul><li>首先栈是运行时的单位，而堆是存储的单位<ul><li><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</p></li><li><p>堆解决的是数据存储的问题，即数据怎么放，放哪里</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image.png" alt="Untitled"></p></li></ul></li></ul><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><p><img src="/images/jvm_virtual_machine/chapter7/image1.png" alt="Untitled"></p><ul><li><p><strong>生命周期</strong></p><p>  生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p></li><li><h2 id="作用-主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。-局部变量，它是相比于成员变量来说的（或属性）-基本数据类型变量-VS-引用类型变量（类、数组、接口）"><a href="#作用-主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。-局部变量，它是相比于成员变量来说的（或属性）-基本数据类型变量-VS-引用类型变量（类、数组、接口）" class="headerlink" title="作用  - 主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。  - 局部变量，它是相比于成员变量来说的（或属性）  - 基本数据类型变量 VS 引用类型变量（类、数组、接口）"></a><strong>作用</strong><br>  - 主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。<br>  - <em>局部变量，它是相比于成员变量来说的（或属性）</em><br>  - <em>基本数据类型变量 VS 引用类型变量（类、数组、接口）</em></h2></li><li><p><strong>虚拟机栈的特点</strong></p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter7/image2.png" alt="Untitled">  </p></li><li><p><strong>设置栈内存大小</strong></p><ul><li>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</li></ul><blockquote><p>Sets the thread stack size (in bytes). Append the letter k or K to indicate KB, m or M to indicate MB, and g or G to indicate GB. The default value depends on the platform:</p><ul><li>Linux&#x2F;x64 (64-bit): 1024 KB</li><li>macOS (64-bit): 1024 KB</li><li>Oracle Solaris&#x2F;x64 (64-bit): 1024 KB</li><li>Windows: The default value depends on virtual memory</li></ul></blockquote><p>  The following examples set the thread stack size to 1024 KB in different units:</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">-Xss1m</span></span><br><span class="line"><span class="literal">-Xss1024k</span></span><br><span class="line"><span class="literal">-Xss1048576</span></span><br></pre></td></tr></table></figure></li><li><p>举例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.stack;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示栈中的异常：StackOverflowError</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-02-10 15:35:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认参数：当栈深度达到：9826，出现内存空间不足。报错：Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">     * 添加参数：-Xss128k，当栈深度达到：982。报错：Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">     * at java.io.PrintStream.write(PrintStream.java:526)</span></span><br><span class="line"><span class="comment">     * at java.io.PrintStream.print(PrintStream.java:597)</span></span><br><span class="line"><span class="comment">     * at java.io.PrintStream.println(PrintStream.java:736)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-栈的存储单位"><a href="#2-栈的存储单位" class="headerlink" title="2.栈的存储单位"></a>2.<strong>栈的存储单位</strong></h3><ul><li><p><strong>栈中存储什么？</strong></p><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ul></li><li><p><strong>栈运行原理</strong></p><ol><li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><p>  <img src="/images/jvm_virtual_machine/chapter7/image3.png" alt="Untitled">  </p></li><li><p><strong>栈帧的内部结构</strong></p><p>  每个栈帧中存储着：</p><ul><li><p>局部变量表（Local Variables）</p></li><li><p>操作数栈（operand Stack）（或表达式栈）</p></li><li><p>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image4.png" alt="Untitled"></p><p>  并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image5.png" alt="Untitled"></p></li></ul></li></ul><h3 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3.局部变量表"></a>3.<strong>局部变量表</strong></h3><ul><li><p>概述：</p><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol></li><li><p><strong>关于Slot的理解</strong></p><ul><li><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p></li><li><p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p></li><li><p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</p><ul><li>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 1ong和double则占据两个slot。</li></ul></li><li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上，如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）</p></li><li><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image6.png" alt="Untitled"></p></li></ul></li><li><p><strong>Slot的重复利用</strong></p><p>  栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  局部变量 c 重用了局部变量 b 的 slot 位置</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image7.png" alt="Untitled"></p></li><li><p><strong>静态变量与局部变量的对比</strong></p><ul><li><p>按数据类型分：基本数据类型、引用数据类型</p></li><li><p>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量</p><ul><li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li><li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li><li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li></ul></li><li><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>  我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p><p>  和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p></li><li><p><strong>补充说明</strong></p><p>  在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>  局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p></li></ul></li></ul><h3 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4.操作数栈"></a>4.<strong>操作数栈</strong></h3><p>操作数栈：Operand Stack</p><ul><li><p><strong>操作数栈的特点</strong></p><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li><li>比如：执行复制、交换、求和等操作</li></ul><p> <img src="/images/jvm_virtual_machine/chapter7/image8.png" alt="Untitled"></p><p> <img src="/images/jvm_virtual_machine/chapter7/image9.png" alt="Untitled"></p></li></ol><p>  操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p><p>  操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.</p><blockquote><p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p></blockquote><p>  每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p><p>  栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul><p>  操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p>  如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>  操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p><p>  另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。  </p></li><li><p><strong>代码追踪</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  使用javap 命令反编译class文件： javap -v 类名.class</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image10.png" alt="Untitled"></p><p>  <em>byte、short、char、boolean 内部都是使用int型来进行保存的</em></p><p>  <em>从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和 8进行入栈操作</em></p><p>  <em>同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作</em></p></li><li><p><strong>一步一步看流程</strong></p><ol><li>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</li></ol><p>  <img src="/images/jvm_virtual_machine/chapter7/image11.png" alt="Untitled"></p><p>  执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image12.png" alt="Untitled"></p><p>  <em>为什么局部变量表不是从0开始的呢？</em></p><p>  <em>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~</em></p><p>  然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image13.png" alt="Untitled"></p><p>  <img src="/images/jvm_virtual_machine/chapter7/image14.png" alt="Untitled"></p><p>  然后从局部变量表中，依次将数据放在操作数栈中</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image15.png" alt="Untitled"></p><p>  <img src="/images/jvm_virtual_machine/chapter7/image16.png" alt="Untitled"></p><p>  然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><p>  <img src="/images/jvm_virtual_machine/chapter7/image17.png" alt="Untitled"></p><p>  <img src="/images/jvm_virtual_machine/chapter7/image18.png" alt="Untitled"></p><p>  最后PC寄存器的位置指向10，也就是return方法，则直接退出方法  </p></li><li><p><strong>栈顶缓存技术</strong></p><p>  栈顶缓存技术：Top Of Stack Cashing</p><p>  前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。</p><p>  由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</p></li></ul><h3 id="5-动态链接"><a href="#5-动态链接" class="headerlink" title="5.动态链接"></a>5.<strong>动态链接</strong></h3><p>动态链接：Dynamic Linking</p><p><img src="/images/jvm_virtual_machine/chapter7/image19.png" alt="Untitled"></p><p><em>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</em></p><ol><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</li></ol><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.linking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLinkingTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodA();</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.peppa.linking.DynamicLinkingTest</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">9.</span>#<span class="number">23</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">8.</span>#<span class="number">24</span>         <span class="comment">// com/peppa/linking/DynamicLinkingTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">27</span>            <span class="comment">// methodA()....</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">30</span>            <span class="comment">// methodB()....</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">31</span>         <span class="comment">// com/peppa/linking/DynamicLinkingTest.methodA:()V</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">32</span>            <span class="comment">// com/peppa/linking/DynamicLinkingTest</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               num</span><br><span class="line">  #<span class="number">11</span> = Utf8               I</span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">17</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               Lcom/peppa/linking/DynamicLinkingTest;</span><br><span class="line">  #<span class="number">19</span> = Utf8               methodA</span><br><span class="line">  #<span class="number">20</span> = Utf8               methodB</span><br><span class="line">  #<span class="number">21</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">22</span> = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               <span class="title function_">methodA</span><span class="params">()</span>....</span><br><span class="line">  #<span class="number">28</span> = Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">30</span> = Utf8               <span class="title function_">methodB</span><span class="params">()</span>....</span><br><span class="line">  #<span class="number">31</span> = NameAndType        #<span class="number">19</span>:#<span class="number">13</span>        <span class="comment">// methodA:()V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               com/peppa/linking/DynamicLinkingTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.peppa.linking.DynamicLinkingTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">4</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/peppa/linking/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String methodA()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/peppa/linking/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String methodB()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method methodA:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_0</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        <span class="number">14</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">17</span>: iconst_1</span><br><span class="line">        <span class="number">18</span>: iadd</span><br><span class="line">        <span class="number">19</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">22</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/peppa/linking/DynamicLinkingTest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li><code>#8 = Class #32</code> ：去找 #32</li><li><code>#32 = Utf8 com/peppa/linking/DynamicLinkingTest</code></li><li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><p><img src="/images/jvm_virtual_machine/chapter7/image20.png" alt="Untitled"></p><p><em>为什么需要运行时常量池？</em></p><p><em>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</em></p><p><em>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</em></p><ul><li><p><strong>方法调用：解析与分配</strong></p><ul><li><p><strong>静态链接与动态链接</strong></p><p>  在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li>**静态链接：**当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li><li><strong>动态链接：<strong>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</strong></strong></li></ul></li><li><p><strong>早期绑定与晚期绑定</strong></p><p>  静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><p><strong>早期绑定</strong></p><p>  早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p></li><li><p><strong>晚期绑定</strong></p><p>  如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p></li></ul></li><li><p><strong>早晚期绑定的发展历史</strong></p><p>  随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>  Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p></li><li><p><strong>虚方法和非虚方法</strong></p><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul></li><li><p><strong>子类对象的多态的使用前提：</strong></p><ol><li>类的继承关系</li><li>方法的重写</li></ol></li><li><p><strong>虚拟机中提供了以下几条方法调用指令：</strong></p><ul><li><p><strong>普通调用指令：</strong></p><ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul></li><li><p><strong>动态调用指令：</strong></p><ul><li><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><p>  前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p></li></ul></li></ul></li><li><p><strong>invokednamic指令</strong></p><ol><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li></ol></li><li><p><strong>动态语言和静态语言</strong></p><ol><li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</li><li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java：<span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;mogu blog&quot;</span>; (Java是静态类型语言的，会先编译就进行类型检查) </span><br><span class="line">JS：<span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;shkstart&quot;</span>; <span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span> <span class="number">10</span>; （运行时才进行检查）</span><br><span class="line">Python: info = <span class="number">130.5</span> (运行时才检查)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Java语言中方法重写的本质</strong></p><ul><li><p><strong>什么是动态分派？</strong></p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol></li><li><p><strong>IllegalAccessError介绍</strong></p><p>  程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p></li><li><p><strong>方法的调用：虚方法表</strong></p><ol><li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li></ol><p>  <img src="/images/jvm_virtual_machine/chapter7/image21.png" alt="Untitled"></p><p>  如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p></li></ul></li></ul><h3 id="6-方法返回地址"><a href="#6-方法返回地址" class="headerlink" title="6.方法返回地址"></a>6.<strong>方法返回地址</strong></h3><ul><li><p>方法的结束</p><ul><li>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：<ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li><li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li><li>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ul></li><li><p><strong>方法退出的两种方式</strong></p><p>  当一个方法开始执行后，只有两种方式可以退出这个方法，</p><ul><li><p><strong>正常退出：</strong></p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含：<ul><li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li><li>lreturn：Long类型</li><li>freturn：Float类型</li><li>dreturn：Double类型</li><li>areturn：引用类型</li><li>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</li></ul></li></ol></li><li><p><strong>异常退出：</strong></p><ol><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</li><li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li></ol><p>  <img src="/images/jvm_virtual_machine/chapter7/image22.png" alt="Untitled"></p><p>  异常处理表：</p><ul><li>反编译字节码文件，可得到 Exception table</li><li>from ：字节码指令起始地址</li><li>to ：字节码指令结束地址</li><li>target ：出现异常跳转至地址为 11 的指令执行</li><li>type ：捕获异常的类型</li></ul></li></ul><p>  本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>  正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p></li></ul><h3 id="7-一些附加信息"><a href="#7-一些附加信息" class="headerlink" title="7.一些附加信息"></a>7.<strong>一些附加信息</strong></h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，成为栈帧信息。</p>]]></content>
    
    
    <summary type="html">每个 Java 虚拟机线程都有一个专用的 Java 虚拟机堆栈，与线程同时创建。Java 虚拟机堆栈存储帧(2.6)。Java 虚拟机堆栈类似于传统语言(如 c)的堆栈：它保存局部变量和部分结果，并在方法调用和返回中发挥作用。因为 Java 虚拟机堆栈从来不会被直接操作，除了推送和弹出框架，框架可能会被分配到堆中。Java 虚拟机堆栈的内存不需要是连续的。</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(六)**本地方法栈Native Method Stacks</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%85%AD)%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88Native%20Method%20Stacks/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%85%AD)%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88Native%20Method%20Stacks/</id>
    <published>2023-02-05T16:00:00.000Z</published>
    <updated>2025-09-03T15:14:27.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-六-本地方法栈Native-Method-Stacks"><a href="#JVM虚拟机详解-六-本地方法栈Native-Method-Stacks" class="headerlink" title="JVM虚拟机详解(六)本地方法栈Native Method Stacks"></a>JVM虚拟机详解(六)<strong>本地方法栈Native Method Stacks</strong></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>Java 虚拟机的实现可以使用传统的栈(通常称为“ c 栈”)来支持本机方法(用 Java 编程语言以外的语言编写的方法)。本机方法堆栈也可以用于 Java 虚拟机指令集的解释器的实现，如 c 语言的 Java 虚拟机实现，不能加载本机方法，也不依赖于传统的堆栈，不需要提供本机方法堆栈。如果提供，通常在创建每个线程时为每个线程分配本机方法堆栈。</p><p>该规范允许本机方法堆栈具有固定的大小，或者根据计算的需要动态扩展和收缩。如果本机方法堆栈的大小固定，则在创建该堆栈时可以独立选择每个本机方法堆栈的大小。</p><p>Java 虚拟机实现可以为程序员或用户提供对本机方法堆栈初始大小的控制，以及对于不同大小的本机方法堆栈，对最大和最小方法堆栈大小的控制。</p><ul><li>下面的异常情况与本机方法堆栈相关联:<ul><li>如果线程中的计算需要比允许的更大的本机方法堆栈，那么 Java 虚拟机抛出一个 StackOverflowError。</li><li>如果本机方法堆栈可以动态扩展，本机方法堆栈扩展可以尝试，但是没有足够的内存可用，或者如果没有足够的内存可用来为新线程创建初始的本机方法堆栈，Java 虚拟机将抛出 OutOfMemoryError。</li></ul></li></ul><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.6">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p><p><img src="/images/jvm_virtual_machine/chapter6/image" alt="Untitled"></p><p>简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p><p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。</p><ul><li><p><strong>代码举例说明Native方法是如何编写的</strong></p><p>  需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">Native2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">Native3</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么使用Native Method？</strong></p><ul><li>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</li></ul></li><li><p><strong>与Java环境的交互</strong></p><ul><li>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li></ul></li><li><p><strong>与操作系统的交互</strong></p><ul><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ul></li><li><p><strong>Sun’s Java</strong></p><ul><li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Java 虚拟机的实现可以使用传统的栈(通常称为“ c 栈”)来支持本机方法(用 Java 编程语言以外的语言编写的方法)。本机方法堆栈也可以用于 Java 虚拟机指令集的解释器的实现，如 c 语言的 Java 虚拟机实现，不能加载本机方法，也不依赖于传统的堆栈，不需要提供本机方法堆栈。如果提供，通常在创建每个线程时为每个线程分配本机方法堆栈。</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(三)**类加载器的分类</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%89)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%89)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2023-02-02T16:00:00.000Z</published>
    <updated>2025-09-03T14:49:45.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-三-类加载器的分类"><a href="#JVM虚拟机详解-三-类加载器的分类" class="headerlink" title="JVM虚拟机详解(三)类加载器的分类"></a>JVM虚拟机详解(三)<strong>类加载器的分类</strong></h2><h3 id="1-类加载器概述"><a href="#1-类加载器概述" class="headerlink" title="1. 类加载器概述"></a>1. <strong>类加载器概述</strong></h3><ol><li>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</li></ol><p><img src="/images/jvm_virtual_machine/chapter3/image.png" alt="Untitled"></p><p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</p><p><img src="/images/jvm_virtual_machine/chapter3/image1.png" alt="Untitled"></p><ul><li><p>我们通过一个类，获取它不同的加载器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-10 11:25:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层的：扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图获取 根加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自定义加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取String类型的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>  得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p><p>  我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C&#x2F;C++ 语言，我们获取不到</strong></p><p>  两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></p></li></ul><h3 id="2-虚拟机自带的加载器"><a href="#2-虚拟机自带的加载器" class="headerlink" title="2.虚拟机自带的加载器"></a>2.<strong>虚拟机自带的加载器</strong></h3><ul><li><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME&#x2F;jre&#x2F;1ib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul></li><li><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;1ib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul></li><li><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul></li><li><p><strong>用户自定义类加载器</strong></p><p>  在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>  用户自定义类加载器实现步骤：</p><ul><li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul></li></ul><h3 id="3-查看根加载器所能加载的目录"><a href="#3-查看根加载器所能加载的目录" class="headerlink" title="3.查看根加载器所能加载的目录"></a>3.<strong>查看根加载器所能加载的目录</strong></h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java &#x2F;lib目录下的class，我们通过下面代码验证一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.security.Provider;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-10 11:42:4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderPathTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*********启动类加载器************&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapClassLoader 能够加载的API的路径</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            System.out.println(url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader ==&gt;&quot;</span>+classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到的结果</span></span><br><span class="line">*********启动类加载器************</span><br><span class="line">file:/D:/software/Java/jdk1<span class="number">.8</span>/jdk1<span class="number">.8</span><span class="number">.0_241</span>/jre/lib/resources.jar</span><br><span class="line">file:/D:/software/Java/jdk1<span class="number">.8</span>/jdk1<span class="number">.8</span><span class="number">.0_241</span>/jre/lib/rt.jar</span><br><span class="line">file:/D:/software/Java/jdk1<span class="number">.8</span>/jdk1<span class="number">.8</span><span class="number">.0_241</span>/jre/lib/sunrsasign.jar</span><br><span class="line">file:/D:/software/Java/jdk1<span class="number">.8</span>/jdk1<span class="number">.8</span><span class="number">.0_241</span>/jre/lib/jsse.jar</span><br><span class="line">file:/D:/software/Java/jdk1<span class="number">.8</span>/jdk1<span class="number">.8</span><span class="number">.0_241</span>/jre/lib/jce.jar</span><br><span class="line">file:/D:/software/Java/jdk1<span class="number">.8</span>/jdk1<span class="number">.8</span><span class="number">.0_241</span>/jre/lib/charsets.jar</span><br><span class="line">file:/D:/software/Java/jdk1<span class="number">.8</span>/jdk1<span class="number">.8</span><span class="number">.0_241</span>/jre/lib/jfr.jar</span><br><span class="line">file:/D:/software/Java/jdk1<span class="number">.8</span>/jdk1<span class="number">.8</span><span class="number">.0_241</span>/jre/classes</span><br><span class="line">classLoader ==&gt;<span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="4-关于ClassLoader"><a href="#4-关于ClassLoader" class="headerlink" title="4. 关于ClassLoader"></a>4. <strong>关于ClassLoader</strong></h3><ul><li><p><strong>ClassLoader 类介绍</strong></p><p>  ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p>  <img src="/images/jvm_virtual_machine/chapter3/image2.png" alt="Untitled"></p></li><li><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p></li></ul><p><img src="/images/jvm_virtual_machine/chapter3/image3.png" alt="Untitled"></p><ul><li>获取ClassLoader的途径<ul><li>获取当前ClassLoader：clazz.getClassLoader()</li><li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li><li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li><li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li></ul></li></ul><h3 id="5-双亲委派机制"><a href="#5-双亲委派机制" class="headerlink" title="5.双亲委派机制"></a>5.<strong>双亲委派机制</strong></h3><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><p><img src="/images/jvm_virtual_machine/chapter3/image4.png" alt="Untitled"></p><ul><li><p><strong>双亲委派机制举例</strong></p><p>  当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p><p>  <img src="/images/jvm_virtual_machine/chapter3/image5.png" alt="Untitled"></p></li><li><p><strong>沙箱安全机制</strong></p><p>  自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p></li><li><p><strong>双亲委派机制的优势</strong></p><p>  通过上面的例子，我们可以知道，双亲机制可以</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul></li><li><p><strong>其他</strong></p><ul><li><p><strong>如何判断两个class对象是否相同？</strong></p><p>  在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名</li><li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li><li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li></ol></li><li><p><strong>对类加载器的引用</strong></p><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li></ol></li></ul></li></ul>]]></content>
    
    
    <summary type="html">JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是**将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(五)**程序计数器(PC寄存器)PC Register</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%BA%94)%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8(PC%E5%AF%84%E5%AD%98%E5%99%A8)PC%20Register/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%BA%94)%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8(PC%E5%AF%84%E5%AD%98%E5%99%A8)PC%20Register/</id>
    <published>2023-02-01T16:00:00.000Z</published>
    <updated>2025-09-03T15:12:50.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-五-程序计数器-PC寄存器-PC-Register"><a href="#JVM虚拟机详解-五-程序计数器-PC寄存器-PC-Register" class="headerlink" title="JVM虚拟机详解(五)程序计数器(PC寄存器)PC Register"></a>JVM虚拟机详解(五)<strong>程序计数器(PC寄存器)PC Register</strong></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>Java 虚拟机可以同时支持多个线程的执行(jls17)。每个 Java 虚拟机线程都有自己的 pc (程序计数器)寄存器。在任何时候，每个 Java 虚拟机线程都在执行单个方法的代码，即该线程的当前方法(2.6)。如果这个方法不是本机的，那么 pc 寄存器就会包含当前正在执行的 Java 虚拟指令的地址。如果当前由线程执行的方法是本机的，那么 Java 虚拟机的 pc 寄存器的值是未定义的。Java 虚拟机的 pc 寄存器足够宽，可以在特定平台上保存 returnAddress 或本机指针。</p><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification (oracle.com)</a></p><p><img src="/images/jvm_virtual_machine/chapter5/image.png" alt="Untitled"></p><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><ul><li><p><strong>作用</strong></p><p>  PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p>  <img src="/images/jvm_virtual_machine/chapter5/image1.png" alt="Untitled"></p><p>  内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>代码实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.register;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**程序计数器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-02-10 13:25:3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCRegisterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line"><span class="number">2</span>: istore_1</span><br><span class="line"><span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line"><span class="number">5</span>: istore_2</span><br><span class="line"><span class="number">6</span>: iload_1</span><br><span class="line"><span class="number">7</span>: iload_2</span><br><span class="line"><span class="number">8</span>: iadd</span><br><span class="line"><span class="number">9</span>: istore_3</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>  通过PC寄存器，我们就可以知道当前程序执行到哪一步了</p><p>  <img src="/images/jvm_virtual_machine/chapter5/image2.png" alt="Untitled"></p><p>  <img src="/images/jvm_virtual_machine/chapter5/image3.png" alt="Untitled"></p></li><li><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong></p><p>  因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>  JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p>  <img src="/images/jvm_virtual_machine/chapter5/image4.png" alt="Untitled"></p></li><li><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ol></li></ul><h3 id="2-CPU-时间片"><a href="#2-CPU-时间片" class="headerlink" title="2.CPU 时间片"></a>2.<strong>CPU 时间片</strong></h3><ol><li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li><li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li><li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</li></ol><p><img src="/images/jvm_virtual_machine/chapter5/image5.png" alt="Untitled"></p>]]></content>
    
    
    <summary type="html">Java 虚拟机可以同时支持多个线程的执行(jls17)。每个 Java 虚拟机线程都有自己的 pc (程序计数器)寄存器。在任何时候，每个 Java 虚拟机线程都在执行单个方法的代码，即该线程的当前方法(2.6)。如果这个方法不是本机的，那么 pc 寄存器就会包含当前正在执行的 Java 虚拟指令的地址。如果当前由线程执行的方法是本机的，那么 Java 虚拟机的 pc 寄存器的值是未定义的。Java 虚拟机的 pc 寄存器足够宽，可以在特定平台上保存 returnAddress 或本机指针。</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机详解(二)**类加载子系统</title>
    <link href="https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%BA%8C)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://yuanxw.github.io/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%BA%8C)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-01-31T16:00:00.000Z</published>
    <updated>2025-09-03T14:43:10.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM虚拟机详解-二-类加载子系统"><a href="#JVM虚拟机详解-二-类加载子系统" class="headerlink" title="JVM虚拟机详解(二)类加载子系统"></a>JVM虚拟机详解(二)<strong>类加载子系统</strong></h2><h3 id="1-内存结构概述"><a href="#1-内存结构概述" class="headerlink" title="1. 内存结构概述"></a>1. <strong>内存结构概述</strong></h3><p><img src="/images/jvm_virtual_machine/chapter2/image.png" alt="Untitled"></p><aside>💡 注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有</aside><p><img src="/images/jvm_virtual_machine/chapter2/image1.png" alt="Untitled"></p><h3 id="2-类加载器子系统"><a href="#2-类加载器子系统" class="headerlink" title="2.类加载器子系统"></a>2.<strong>类加载器子系统</strong></h3><ul><li><p><strong>类加载器子系统作用：</strong></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li><li><strong>加载的类信息存放于一块称为方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter2/image2.png" alt="Untitled"></p></li></ul><h3 id="3-类加载器ClassLoader角色"><a href="#3-类加载器ClassLoader角色" class="headerlink" title="3. 类加载器ClassLoader角色"></a>3. <strong>类加载器ClassLoader角色</strong></h3><ul><li>class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。</li><li>在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ul><p><img src="/images/jvm_virtual_machine/chapter2/image3.png" alt="Untitled"></p><h3 id="4-类加载过程"><a href="#4-类加载过程" class="headerlink" title="4.类加载过程"></a>4.<strong>类加载过程</strong></h3><p>例如下面的一段简单的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载子系统</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-08 16:51:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我已经被加载啦...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>它的加载过程是怎么样的呢?</p><ul><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li><li>加载失败则抛出异常</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter2/image4.png" alt="Untitled"></p><p>  完整的流程图如下所示</p><p>  <img src="/images/jvm_virtual_machine/chapter2/image5.png" alt="Untitled"></p></li></ul><h3 id="5-加载阶段"><a href="#5-加载阶段" class="headerlink" title="5. 加载阶段"></a>5. <strong>加载阶段</strong></h3><ul><li><p><strong>加载：</strong></p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li></ol></li><li><p><strong>加载class文件的方式</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol></li></ul><h3 id="6-链接阶段"><a href="#6-链接阶段" class="headerlink" title="6. 链接阶段"></a>6. <strong>链接阶段</strong></h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p><ul><li><p><strong>验证(Verify)</strong></p><ol><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ol><ul><li><p><strong>举例</strong></p><p>  使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><p>  <em>工具：Binary Viewer查看，工具下载地址：</em><a href="https://www.proxoft.com/BinaryViewer.aspx">Binary Viewer Page (proxoft.com)</a></p><p>  <img src="/images/jvm_virtual_machine/chapter2/image6.png" alt="Untitled"></p><p>  如果出现不合法的字节码文件，那么将会验证不通过，同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p></li><li><p>安装<em>Binary Viewer</em></p><p>  同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p><p>  <img src="/images/jvm_virtual_machine/chapter2/image7.png" alt="Untitled"></p></li><li><p>配置插件参数</p><p>  点击<code>Help</code>，点击<code>Edit Custom Vm Options…</code>，增加以下配置后重启<code>IDEA</code>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Duser.language=en</span><br><span class="line">-Duser.region=CN</span><br></pre></td></tr></table></figure><p>  安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p><p>  <img src="/images/jvm_virtual_machine/chapter2/image8.png" alt="Untitled"></p></li></ul></li><li><p><strong>准备(Prepare)</strong></p><ol><li>为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</li><li>注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><ul><li><strong>举例</strong></li></ul><p>  代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-08 17:36:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>解析(Resolve)</strong></p><ol><li><strong>将常量池内的符号引用转换为直接引用的过程</strong></li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</li></ol><ul><li><p><strong>符号引用</strong></p><ul><li>反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</li></ul><p>  <img src="/images/jvm_virtual_machine/chapter2/image9.png" alt="Untitled"></p></li></ul></li></ul><h3 id="7-初始化阶段"><a href="#7-初始化阶段" class="headerlink" title="7.初始化阶段"></a>7.<strong>初始化阶段</strong></h3><ul><li><p><strong>类的初始化时机</strong></p><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.atguigu.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>  除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）  </p></li><li><p>构造器方法<code>&lt;clinit&gt;()</code>方法</p><ol><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li><li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li></ol></li><li><p><strong>案例1：有static变量</strong></p><p>  查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-09 20:38:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        <span class="comment">// System.out.println(number);  //报错：Illegal forward reference 非法的前向引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line"><span class="comment">     * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span></span><br><span class="line"><span class="comment">     * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ClassInitTest.age); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(ClassInitTest.number); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/images/jvm_virtual_machine/chapter2/image10.png" alt="Untitled"></p><ul><li>&lt;clint字节码&gt;：当我们代码中包含static变量的时候，就会有clinit方法</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_1</span><br><span class="line"><span class="number">1</span>: putstatic     #<span class="number">3</span>                   <span class="comment">// Field age:I</span></span><br><span class="line"><span class="number">4</span>: iconst_2</span><br><span class="line"><span class="number">5</span>: putstatic     #<span class="number">3</span>                   <span class="comment">// Field age:I</span></span><br><span class="line"><span class="number">8</span>: bipush        <span class="number">20</span>                   <span class="comment">// 先赋20                    </span></span><br><span class="line"><span class="number">10</span>: putstatic     #<span class="number">5</span>                  <span class="comment">// Field number:I</span></span><br><span class="line"><span class="number">13</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">16</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field age:I</span></span><br><span class="line"><span class="number">19</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line"><span class="number">22</span>: bipush        <span class="number">10</span>                  <span class="comment">// 再赋10       </span></span><br><span class="line"><span class="number">24</span>: putstatic     #<span class="number">5</span>                  <span class="comment">// Field number:I</span></span><br><span class="line"><span class="number">27</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li><li><p><strong>案例2：无static变量</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-09 20:38:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonStaticClassInitTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is NonStaticClassInitTest.class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/jvm_virtual_machine/chapter2/image11.png" alt="Untitled"></p><ul><li><p><strong>案例3：关于涉及到父类时候的变量赋值过程</strong></p><ul><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peppa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-09 22:32:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClassInitTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Dog.B);  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 SubClassInitTest 类</li><li>获取 Dog .B 静态变量，需要加载 Dog 类</li><li>Dog 类的父类是 Animal 类，所以需要先执行 Animal 类的加载，再执行 Dog 类的加载</li></ul></li><li><p><strong>案例4：虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            <span class="type">DeadThread</span> <span class="variable">dead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadThread</span>();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadThread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果:</span></span><br><span class="line">线程<span class="number">2</span>开始</span><br><span class="line">线程<span class="number">1</span>开始</span><br><span class="line">线程<span class="number">2</span>初始化当前类</span><br><span class="line"></span><br><span class="line"><span class="comment">/**然后程序卡死了**/</span></span><br></pre></td></tr></table></figure><p>  程序卡死，分析原因：</p><ul><li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li><li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">类加载器子系统作用：类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。加载的类信息存放于一块称为方法区的内存空间**。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</summary>
    
    
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="JVM" scheme="https://yuanxw.github.io/tags/JVM/"/>
    
    <category term="JVM虚拟机详解" scheme="https://yuanxw.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程(二十八)Java多线程之SynchronousQueue容器</title>
    <link href="https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%85%AB)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSynchronousQue/"/>
    <id>https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%85%AB)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSynchronousQue/</id>
    <published>2023-01-27T16:00:00.000Z</published>
    <updated>2025-09-03T08:21:04.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA多线程-二十八-Java多线程之SynchronousQueue容器"><a href="#1-JAVA多线程-二十八-Java多线程之SynchronousQueue容器" class="headerlink" title="1.JAVA多线程(二十八)Java多线程之SynchronousQueue容器"></a>1.JAVA多线程(二十八)Java多线程之SynchronousQueue容器</h2><h3 id="1-1-什么是SynchronousQueue"><a href="#1-1-什么是SynchronousQueue" class="headerlink" title="1.1 什么是SynchronousQueue"></a>1.1 什么是SynchronousQueue</h3><p>&emsp;&emsp;Java 6的并发编程包中的SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。</p><p>不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的线程，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。</p><p>SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p><p>下面是 SynchronousQueue继承结构关系图：</p><p><img src="/images/java_multithreading/chapter28/20200211124757675.png" alt="在这里插入图片描述"></p><p>通过源代码查看SynchronousQueue实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 SynchronousQueue非公平策略。 </span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> SynchronousQueue&#125; with nonfair access policy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SynchronousQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 SynchronousQueue非公平策略。 如果fair参数：true，等待线程在FIFO顺序中进行访问; </span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> SynchronousQueue&#125; with the specified fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair if true, waiting threads contend in FIFO order for</span></span><br><span class="line"><span class="comment"> *        access; otherwise the order is unspecified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SynchronousQueue</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> <span class="title class_">TransferQueue</span>&lt;E&gt;() : <span class="keyword">new</span> <span class="title class_">TransferStack</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-SynchronousQueue队列特点"><a href="#1-2-SynchronousQueue队列特点" class="headerlink" title="1.2 SynchronousQueue队列特点"></a>1.2 SynchronousQueue队列特点</h3><ul><li><p>SynchronousQueue没有容量。与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。</p></li><li><p>因为没有容量，所以对应的peek、contains、clear、isEmpty…..等方法其实是无效的。例如clear是不执行任何操作的，contains始终返回false，peek始终返回null。</p></li><li><p>SynchronousQueue分为公平和非公平，默认情况下采用非公平性访问策略，当然也可以通过构造函数来设置为公平性访问策略（为true即可）。</p></li><li><p>SynchronousQueue内部采用了无锁实现（CAS）。</p></li></ul><h3 id="1-3-常用的方法"><a href="#1-3-常用的方法" class="headerlink" title="1.3 常用的方法"></a>1.3 常用的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.thread.chapter28;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// add();</span></span><br><span class="line">        <span class="comment">// addAndTake();</span></span><br><span class="line">        <span class="comment">// offer();</span></span><br><span class="line">        put();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     如果可以在不超过队列的容量的情况下立即将其指定的元素插入到该队列中，</span></span><br><span class="line"><span class="comment">     如果队列已满，则返回 true并抛出 IllegalStateException 。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行add()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">         at java.util.AbstractQueue.add(AbstractQueue.java:98)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter28.SynchronousQueueExample.add(SynchronousQueueExample.java:16)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter28.SynchronousQueueExample.main(SynchronousQueueExample.java:10)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">SynchronousQueue</span> <span class="variable">synchronousQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>();</span><br><span class="line">        synchronousQueue.add(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addAndTake</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">SynchronousQueue</span> <span class="variable">synchronousQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, synchronousQueue.size(),synchronousQueue.remainingCapacity()));</span><br><span class="line">                <span class="type">Object</span> <span class="variable">take</span> <span class="operator">=</span> synchronousQueue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;当前synchronousQueue对象中take()数据值为：&quot;</span> + take);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronousQueue.add()执行返回结果：&quot;</span>+synchronousQueue.add(<span class="string">&quot;Message 1&quot;</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     如果另一个线程正在等待接收，则将指定的元素插入到此队列中。</span></span><br><span class="line"><span class="comment">     true如果元素被添加到这个队列，否则 false</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行offer()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         synchronousQueue.offer()执行返回结果：false</span></span><br><span class="line"><span class="comment">         ------------------------------------</span></span><br><span class="line"><span class="comment">         synchronousQueue.offer()执行返回结果：true</span></span><br><span class="line"><span class="comment">         当前synchronousQueue对象中take()数据值为：Message 2</span></span><br><span class="line"><span class="comment">         =====执行offer()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行offer()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">SynchronousQueue</span> <span class="variable">synchronousQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronousQueue.offer()执行返回结果：&quot;</span>+synchronousQueue.offer(<span class="string">&quot;Message 1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">take</span> <span class="operator">=</span> synchronousQueue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;当前synchronousQueue对象中take()数据值为：&quot;</span> + take);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronousQueue.offer()执行返回结果：&quot;</span>+synchronousQueue.offer(<span class="string">&quot;Message 2&quot;</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行offer()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素添加到此队列，等待另一个线程接收它。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行put()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         当前synchronousQueue对象中take()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         =====执行put()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行put()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">SynchronousQueue</span> <span class="variable">synchronousQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="comment">// 检索并删除此队列的头</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">take</span> <span class="operator">=</span> synchronousQueue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;当前synchronousQueue对象中take()数据值为：&quot;</span> + take);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// put方法会阻塞，直到有一个线程获取。</span></span><br><span class="line">        synchronousQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行put()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h3><p> &emsp;&emsp;可缓存线程池CachedThreadPool的源码实现，使用SynchronousQueue作为工作队列，工作队列本身并不限制待执行的任务的数量。但此时需要限定线程池的最大大小为一个合理的有限值，而不是Integer.MAX_VALUE，否则可能导致线程池中的工作者线程的数量一直增加到系统资源所无法承受为止。如果应用程序确实需要比较大的工作队列容量，而又想避免无界工作队列可能导致的问题，不妨考虑SynchronousQueue。SynchronousQueue实现上并不使用缓存空间。<br>使用SynchronousQueue的目的就是保证“对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务”。<br><strong><a href="https://blog.csdn.net/yuan_xw/article/details/104137076">JAVA多线程(十九)Java多线程之CachedThreadPool可缓存线程池</a></strong>。</p><p>&emsp;&emsp;可缓存线程池CachedThreadPool源代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a thread pool that creates new threads as needed, but</span></span><br><span class="line"><span class="comment"> * will reuse previously constructed threads when they are</span></span><br><span class="line"><span class="comment"> * available.  These pools will typically improve the performance</span></span><br><span class="line"><span class="comment"> * of programs that execute many short-lived asynchronous tasks.</span></span><br><span class="line"><span class="comment"> * Calls to &#123;<span class="doctag">@code</span> execute&#125; will reuse previously constructed</span></span><br><span class="line"><span class="comment"> * threads if available. If no existing thread is available, a new</span></span><br><span class="line"><span class="comment"> * thread will be created and added to the pool. Threads that have</span></span><br><span class="line"><span class="comment"> * not been used for sixty seconds are terminated and removed from</span></span><br><span class="line"><span class="comment"> * the cache. Thus, a pool that remains idle for long enough will</span></span><br><span class="line"><span class="comment"> * not consume any resources. Note that pools with similar</span></span><br><span class="line"><span class="comment"> * properties but different details (for example, timeout parameters)</span></span><br><span class="line"><span class="comment"> * may be created using &#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125; constructors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十八)Java多线程之SynchronousQueue容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。<br>  <p align="right">——厚积薄发(yuanxw)</p></p>]]></content>
    
    
    <summary type="html">Java 6的并发编程包中的SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。</summary>
    
    
    
    <category term="Java多线程" scheme="https://yuanxw.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://yuanxw.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yuanxw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器</title>
    <link href="https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%83)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BLinkedBlockingQueue%E5%AE%B9%E5%99%A8/"/>
    <id>https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%83)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BLinkedBlockingQueue%E5%AE%B9%E5%99%A8/</id>
    <published>2023-01-26T16:00:00.000Z</published>
    <updated>2025-09-03T08:21:13.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA多线程-二十七-Java多线程之LinkedBlockingQueue容器"><a href="#1-JAVA多线程-二十七-Java多线程之LinkedBlockingQueue容器" class="headerlink" title="1.JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器"></a>1.JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器</h2><h3 id="1-1-什么是LinkedBlockingQueue"><a href="#1-1-什么是LinkedBlockingQueue" class="headerlink" title="1.1 什么是LinkedBlockingQueue"></a>1.1 什么是LinkedBlockingQueue</h3><p>&emsp;&emsp;LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。</p><p>下面是 LinkedBlockingQueue继承结构关系图：</p><p><img src="/images/java_multithreading/chapter27/20200211105035486.png" alt="在这里插入图片描述"></p><h3 id="1-2-LinkedBlockingQueue单向链表实现的阻塞队列"><a href="#1-2-LinkedBlockingQueue单向链表实现的阻塞队列" class="headerlink" title="1.2 LinkedBlockingQueue单向链表实现的阻塞队列"></a>1.2 LinkedBlockingQueue单向链表实现的阻塞队列</h3><p>&emsp;&emsp;LinkedBlockingQueue是一个阻塞队列，内部由两个ReentrantLock来实现出入队列的线程安全，由各自的Condition对象的await和signal来实现等待和唤醒功能。它和ArrayBlockingQueue的不同点在于：</p><ul><li>队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。</li><li>数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。</li><li>由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。</li><li>两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</li></ul><p>通过源代码查看LinkedBlockingQueue实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 LinkedBlockingQueue ，容量为 Integer.MAX_VALUE 。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个具有给定（固定）容量的 LinkedBlockingQueue 。 </span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with the given (fixed) capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is not greater</span></span><br><span class="line"><span class="comment"> *         than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 LinkedBlockingQueue ，容量为 Integer.MAX_VALUE ，最初包含给定集合的元素，以集合的迭代* 器的遍历顺序添加。 </span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;, initially containing the elements of the</span></span><br><span class="line"><span class="comment"> * given collection,</span></span><br><span class="line"><span class="comment"> * added in traversal order of the collection&#x27;s iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection of elements to initially contain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment"> *         of its elements are null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-常用的方法"><a href="#1-3-常用的方法" class="headerlink" title="1.3 常用的方法"></a>1.3 常用的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.thread.chapter27;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// add();</span></span><br><span class="line">        <span class="comment">// offer();</span></span><br><span class="line">        <span class="comment">// put();</span></span><br><span class="line">        <span class="comment">// poll();</span></span><br><span class="line">        <span class="comment">// peek();</span></span><br><span class="line">        <span class="comment">// element();</span></span><br><span class="line">         remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     如果可以在不超过队列的容量的情况下立即将其指定的元素插入到该队列，</span></span><br><span class="line"><span class="comment">     如果队列已满，则返回 true并抛出 IllegalStateException 。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行add()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         linkedBlockingQueue.add()执行返回结果：true</span></span><br><span class="line"><span class="comment">         linkedBlockingQueue.add()执行返回结果：true</span></span><br><span class="line"><span class="comment">         linkedBlockingQueue.add()执行返回结果：true</span></span><br><span class="line"><span class="comment">         Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">         at java.util.AbstractQueue.add(AbstractQueue.java:98)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.add(LinkedBlockingQueueExample.java:38)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.main(LinkedBlockingQueueExample.java:9)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">LinkedBlockingQueue</span> <span class="variable">linkedBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedBlockingQueue.add()执行返回结果：&quot;</span>+linkedBlockingQueue.add(<span class="string">&quot;Message 1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedBlockingQueue.add()执行返回结果：&quot;</span>+linkedBlockingQueue.add(<span class="string">&quot;Message 2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedBlockingQueue.add()执行返回结果：&quot;</span>+linkedBlockingQueue.add(<span class="string">&quot;Message 3&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedBlockingQueue.add()执行返回结果：&quot;</span>+linkedBlockingQueue.add(<span class="string">&quot;Message 4&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果可以在不超过队列容量的情况下立即将其指定的元素插入该队列的尾部，</span></span><br><span class="line"><span class="comment">     * 则在成功时true如果该队列已满，则返回false 。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行offer()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         linkedBlockingQueue.offer()执行返回结果：true</span></span><br><span class="line"><span class="comment">         linkedBlockingQueue.offer()执行返回结果：true</span></span><br><span class="line"><span class="comment">         linkedBlockingQueue.offer()执行返回结果：true</span></span><br><span class="line"><span class="comment">         linkedBlockingQueue.offer()执行返回结果：false</span></span><br><span class="line"><span class="comment">         =====执行offer()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行offer()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">LinkedBlockingQueue</span> <span class="variable">linkedBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedBlockingQueue.offer()执行返回结果：&quot;</span>+linkedBlockingQueue.offer(<span class="string">&quot;Message 1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedBlockingQueue.offer()执行返回结果：&quot;</span>+linkedBlockingQueue.offer(<span class="string">&quot;Message 2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedBlockingQueue.offer()执行返回结果：&quot;</span>+linkedBlockingQueue.offer(<span class="string">&quot;Message 3&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedBlockingQueue.offer()执行返回结果：&quot;</span>+linkedBlockingQueue.offer(<span class="string">&quot;Message 4&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行offer()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在该队列的尾部插入指定的元素，如果队列已满，则等待空间变为可用。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">     =====执行put()签名方法-开始=====</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中的个数：3</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中的容量：0</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中take()数据值为：Message 1</span></span><br><span class="line"><span class="comment">     Message 2</span></span><br><span class="line"><span class="comment">     Message 3</span></span><br><span class="line"><span class="comment">     Message 4</span></span><br><span class="line"><span class="comment">     =====执行put()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行put()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">LinkedBlockingQueue</span> <span class="variable">linkedBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Executors.newSingleThreadExecutor().execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中的个数：&quot;</span> + linkedBlockingQueue.size());</span><br><span class="line">            System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中的容量：&quot;</span> + linkedBlockingQueue.remainingCapacity());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="comment">// 检索并删除此队列的头</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">take</span> <span class="operator">=</span> linkedBlockingQueue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中take()数据值为：&quot;</span> + take);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 4&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行put()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索并删除此队列的头，则等待空间变为可用。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">     =====执行poll()签名方法-开始=====</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中poll()数据值为：Message 1</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中poll()数据值为：Message 2</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中的个数：【1】,容量：【2】</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中poll()数据值为：Message 3</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中poll()数据值为：null</span></span><br><span class="line"><span class="comment">     当前linkedBlockingQueue对象中poll()数据值为：null</span></span><br><span class="line"><span class="comment">     =====执行poll()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行poll()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">LinkedBlockingQueue</span> <span class="variable">linkedBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot;</span> + linkedBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot;</span> + linkedBlockingQueue.poll());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot;</span> + linkedBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot;</span> + linkedBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot;</span> + linkedBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行poll()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索但不删除此队列的头，如果此队列为空，则返回 null。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行peek()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         =====执行peek()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行peek()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">LinkedBlockingQueue</span> <span class="variable">linkedBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot;</span> + linkedBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot;</span> + linkedBlockingQueue.peek());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot;</span> + linkedBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot;</span> + linkedBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot;</span> + linkedBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行peek()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索，但不删除，这个队列的头。 此方法与peek的不同之处在于，如果此队列为空，它将抛出异常。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行element()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中的个数：【0】,容量：【3】</span></span><br><span class="line"><span class="comment">         Exception in thread &quot;main&quot; java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">         at java.util.AbstractQueue.element(AbstractQueue.java:136)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.element(LinkedBlockingQueueExample.java:181)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.main(LinkedBlockingQueueExample.java:14)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">element</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行element()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">LinkedBlockingQueue</span> <span class="variable">linkedBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));</span><br><span class="line">        linkedBlockingQueue.clear();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中element()数据值为：&quot;</span> + linkedBlockingQueue.element());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行element()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索并删除此队列的头。 此方法与poll不同之处在于，如果此队列为空，它将抛出异常。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行remove()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中remove()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中remove()数据值为：Message 2</span></span><br><span class="line"><span class="comment">         当前linkedBlockingQueue对象中remove()数据值为：Message 3</span></span><br><span class="line"><span class="comment">         Exception in thread &quot;main&quot; java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">         at java.util.AbstractQueue.remove(AbstractQueue.java:117)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.remove(LinkedBlockingQueueExample.java:205)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.main(LinkedBlockingQueueExample.java:15)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行remove()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">LinkedBlockingQueue</span> <span class="variable">linkedBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        linkedBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot;</span> + linkedBlockingQueue.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot;</span> + linkedBlockingQueue.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot;</span> + linkedBlockingQueue.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot;</span> + linkedBlockingQueue.remove());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行remove()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。<br>  <p align="right">——厚积薄发(yuanxw)</p></p>]]></content>
    
    
    <summary type="html">LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。</summary>
    
    
    
    <category term="Java多线程" scheme="https://yuanxw.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://yuanxw.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yuanxw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器</title>
    <link href="https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%85%AD)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BPriorityBlockingQueue%E5%AE%B9%E5%99%A8/"/>
    <id>https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%85%AD)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BPriorityBlockingQueue%E5%AE%B9%E5%99%A8/</id>
    <published>2023-01-25T16:00:00.000Z</published>
    <updated>2025-09-03T08:21:26.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA多线程-二十六-Java多线程之PriorityBlockingQueue容器"><a href="#1-JAVA多线程-二十六-Java多线程之PriorityBlockingQueue容器" class="headerlink" title="1.JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器"></a>1.JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器</h2><h3 id="1-1-什么是PriorityBlockingQueue"><a href="#1-1-什么是PriorityBlockingQueue" class="headerlink" title="1.1 什么是PriorityBlockingQueue"></a>1.1 什么是PriorityBlockingQueue</h3><p>&emsp;&emsp;PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。</p><p>PriorityBlockingQueue 并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p><p>下面是 PriorityBlockingQueue继承结构关系图：<br><img src="/images/java_multithreading/chapter26/20200210174818165.png" alt="在这里插入图片描述"></p><h3 id="1-2-PriorityBlockingQueue无界阻塞队列"><a href="#1-2-PriorityBlockingQueue无界阻塞队列" class="headerlink" title="1.2 PriorityBlockingQueue无界阻塞队列"></a>1.2 PriorityBlockingQueue无界阻塞队列</h3><p>&emsp;&emsp;简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。<br>通过源代码查看PriorityBlockingQueue实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个PriorityBlockingQueue ，具有默认的初始容量（11），根据它们的Comparable对其元素进行排序 。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> PriorityBlockingQueue&#125; with the default</span></span><br><span class="line"><span class="comment"> * initial capacity (11) that orders its elements according to</span></span><br><span class="line"><span class="comment"> * their &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个PriorityBlockingQueue ，指定容量大小，根据它们的Comparable对其元素进行排序 。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> PriorityBlockingQueue&#125; with the specified</span></span><br><span class="line"><span class="comment"> * initial capacity that orders its elements according to their</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity the initial capacity for this priority queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is less</span></span><br><span class="line"><span class="comment"> *         than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityBlockingQueue</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建具有 PriorityBlockingQueue初始容量的PriorityBlockingQueue，根据指定的比较器对其元素进行排序。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> PriorityBlockingQueue&#125; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity that orders its elements according to the specified</span></span><br><span class="line"><span class="comment"> * comparator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity the initial capacity for this priority queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  comparator the comparator that will be used to order this</span></span><br><span class="line"><span class="comment"> *         priority queue.  If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable</span></span><br><span class="line"><span class="comment"> *         natural ordering&#125; of the elements will be used.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is less</span></span><br><span class="line"><span class="comment"> *         than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityBlockingQueue</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                             Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="built_in">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 PriorityBlockingQueue集合中的元素的PriorityBlockingQueue。 </span></span><br><span class="line"><span class="comment"> * 在指定的集合中。如果指定的集合是 &#123;<span class="doctag">@link</span> SortedSet&#125;或&#123;<span class="doctag">@link</span> PriorityQueue&#125;，</span></span><br><span class="line"><span class="comment"> * 这个优先队列将按照相同的顺序排序。否则，此优先队列将根据&#123;<span class="doctag">@linkplain</span>可比较的自然排序&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> PriorityBlockingQueue&#125; containing the elements</span></span><br><span class="line"><span class="comment"> * in the specified collection.  If the specified collection is a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> SortedSet&#125; or a &#123;<span class="doctag">@link</span> PriorityQueue&#125;, this</span></span><br><span class="line"><span class="comment"> * priority queue will be ordered according to the same ordering.</span></span><br><span class="line"><span class="comment"> * Otherwise, this priority queue will be ordered according to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125; of its elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c the collection whose elements are to be placed</span></span><br><span class="line"><span class="comment"> *         into this priority queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if elements of the specified collection</span></span><br><span class="line"><span class="comment"> *         cannot be compared to one another according to the priority</span></span><br><span class="line"><span class="comment"> *         queue&#x27;s ordering</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment"> *         of its elements are null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="built_in">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">heapify</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// true if not known to be in heap order</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">screen</span> <span class="operator">=</span> <span class="literal">true</span>;  <span class="comment">// true if must screen for nulls</span></span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; ss = (SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) ss.comparator();</span><br><span class="line">        heapify = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityBlockingQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityBlockingQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; pq =</span><br><span class="line">            (PriorityBlockingQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) pq.comparator();</span><br><span class="line">        screen = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pq.getClass() == PriorityBlockingQueue.class) <span class="comment">// exact match</span></span><br><span class="line">            heapify = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">// If c.toArray incorrectly doesn&#x27;t return Object[], copy it.</span></span><br><span class="line">    <span class="keyword">if</span> (a.getClass() != Object[].class)</span><br><span class="line">        a = Arrays.copyOf(a, n, Object[].class);</span><br><span class="line">    <span class="keyword">if</span> (screen &amp;&amp; (n == <span class="number">1</span> || <span class="built_in">this</span>.comparator != <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.queue = a;</span><br><span class="line">    <span class="built_in">this</span>.size = n;</span><br><span class="line">    <span class="keyword">if</span> (heapify)</span><br><span class="line">        heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-PriorityBlockingQueue无界阻塞队列特点"><a href="#1-3-PriorityBlockingQueue无界阻塞队列特点" class="headerlink" title="1.3 PriorityBlockingQueue无界阻塞队列特点"></a>1.3 PriorityBlockingQueue无界阻塞队列特点</h3><ol><li>PriorityBlockingQueue无界队列，只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容。</li><li>PriorityBlockingQueue不可以插入 null 值。</li><li>插入队列的对象必须是可比较大小的（comparable）。</li></ol><h3 id="1-4-常用的方法"><a href="#1-4-常用的方法" class="headerlink" title="1.4 常用的方法"></a>1.4 常用的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.thread.chapter26;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityBlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// add();</span></span><br><span class="line">        <span class="comment">// poll();</span></span><br><span class="line">        <span class="comment">// peek();</span></span><br><span class="line">        <span class="comment">// element();</span></span><br><span class="line">        <span class="comment">// remove();</span></span><br><span class="line">        <span class="comment">// addNoComparable();</span></span><br><span class="line">        addWithNull();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PriorityBlockingQueue</span></span><br><span class="line"><span class="comment">     * 将指定的元素插入到此优先级队列中。 由于队列无限制，此方法将永远不会返回false 。</span></span><br><span class="line"><span class="comment">     * add()方法、put()方法，都调用用offer()方法。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行add()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         Message 1</span></span><br><span class="line"><span class="comment">         Message 2</span></span><br><span class="line"><span class="comment">         Message 3</span></span><br><span class="line"><span class="comment">         =====执行add()签名方法-开始=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个PriorityBlockingQueue ，具有指定的初始容量，根据它们的natural ordering对其元素进行排序 。</span></span><br><span class="line">        <span class="comment">// 超过容量之后会自动扩容</span></span><br><span class="line">        <span class="type">PriorityBlockingQueue</span> <span class="variable">priorityBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>(<span class="number">2</span>);</span><br><span class="line">        priorityBlockingQueue.add(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.offer(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-开始=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索并删除此队列的头，则等待空间变为可用。</span></span><br><span class="line"><span class="comment">     =====执行poll()签名方法-开始=====</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中poll()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中poll()数据值为：Message 2</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中的个数：【1】,容量：【2147483647】</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中poll()数据值为：Message 3</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中poll()数据值为：null</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中poll()数据值为：null</span></span><br><span class="line"><span class="comment">     =====执行poll()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行poll()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">PriorityBlockingQueue</span> <span class="variable">priorityBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>(<span class="number">2</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot;</span> + priorityBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot;</span> + priorityBlockingQueue.poll());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot;</span> + priorityBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot;</span> + priorityBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot;</span> + priorityBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行poll()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索但不删除此队列的头，如果此队列为空，则返回 null。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行peek()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         =====执行peek()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">()</span>  &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行peek()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">PriorityBlockingQueue</span> <span class="variable">priorityBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>(<span class="number">2</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot;</span> + priorityBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot;</span> + priorityBlockingQueue.peek());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot;</span> + priorityBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot;</span> + priorityBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot;</span> + priorityBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行peek()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索，但不删除，这个队列的头。 此方法与peek的不同之处在于，如果此队列为空，它将抛出异常。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行element()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中take()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中take()数据值为：Message 2</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中take()数据值为：Message 3</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中的个数：【0】,容量：【2147483647】</span></span><br><span class="line"><span class="comment">         Exception in thread &quot;main&quot; java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">         at java.util.AbstractQueue.element(AbstractQueue.java:136)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.element(PriorityBlockingQueueExample.java:123)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:11)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">element</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行element()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">PriorityBlockingQueue</span> <span class="variable">priorityBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中take()数据值为：&quot;</span> + priorityBlockingQueue.take());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中take()数据值为：&quot;</span> + priorityBlockingQueue.take());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中take()数据值为：&quot;</span> + priorityBlockingQueue.take());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中element()数据值为：&quot;</span> + priorityBlockingQueue.element());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行element()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索并删除此队列的头。 此方法与poll不同之处在于，如果此队列为空，它将抛出异常。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行remove()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中remove()数据值为：Message 1</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中remove()数据值为：Message 2</span></span><br><span class="line"><span class="comment">         当前priorityBlockingQueue对象中remove()数据值为：Message 3</span></span><br><span class="line"><span class="comment">         Exception in thread &quot;main&quot; java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">         at java.util.AbstractQueue.remove(AbstractQueue.java:117)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.remove(PriorityBlockingQueueExample.java:151)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:12)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行remove()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">PriorityBlockingQueue</span> <span class="variable">priorityBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        priorityBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot;</span> + priorityBlockingQueue.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot;</span> + priorityBlockingQueue.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot;</span> + priorityBlockingQueue.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot;</span> + priorityBlockingQueue.remove());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行remove()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证：</span></span><br><span class="line"><span class="comment">     * 添加元素时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行addNoComparable()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         Exception in thread &quot;main&quot; java.lang.ClassCastException: com.yuanxw.thread.chapter26.PriorityBlockingQueueExample$Order cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.PriorityBlockingQueue.siftUpComparable(PriorityBlockingQueue.java:358)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.PriorityBlockingQueue.offer(PriorityBlockingQueue.java:490)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.PriorityBlockingQueue.add(PriorityBlockingQueue.java:464)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.addNoComparable(PriorityBlockingQueueExample.java:166)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:12)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addNoComparable</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行addNoComparable()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="comment">// 默认长度为：11</span></span><br><span class="line">        <span class="type">PriorityBlockingQueue</span> <span class="variable">priorityBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>();</span><br><span class="line">        priorityBlockingQueue.add(<span class="keyword">new</span> <span class="title class_">Order</span>());</span><br><span class="line">        priorityBlockingQueue.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行addNoComparable()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证：</span></span><br><span class="line"><span class="comment">     * 添加元素时，插入队列的对象是null，报 NullPointerException 异常。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行addWithNull()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         Exception in thread &quot;main&quot; java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.PriorityBlockingQueue.offer(PriorityBlockingQueue.java:480)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.PriorityBlockingQueue.add(PriorityBlockingQueue.java:464)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.addWithNull(PriorityBlockingQueueExample.java:194)</span></span><br><span class="line"><span class="comment">         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:13)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addWithNull</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行addWithNull()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="comment">// 默认长度为：11</span></span><br><span class="line">        <span class="type">PriorityBlockingQueue</span> <span class="variable">priorityBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>();</span><br><span class="line">        priorityBlockingQueue.add(<span class="literal">null</span>);</span><br><span class="line">        priorityBlockingQueue.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行addWithNull()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Order</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。<br>  <p align="right">——厚积薄发(yuanxw)</p></p>]]></content>
    
    
    <summary type="html">PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。</summary>
    
    
    
    <category term="Java多线程" scheme="https://yuanxw.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://yuanxw.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yuanxw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器</title>
    <link href="https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%BA%94)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BArrayBlockingQueue%E5%AE%B9%E5%99%A8/"/>
    <id>https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%BA%94)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BArrayBlockingQueue%E5%AE%B9%E5%99%A8/</id>
    <published>2023-01-24T16:00:00.000Z</published>
    <updated>2025-09-03T08:21:32.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA-多线程-二十五-Java-多线程之-ArrayBlockingQueue-容器"><a href="#1-JAVA-多线程-二十五-Java-多线程之-ArrayBlockingQueue-容器" class="headerlink" title="1.JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器"></a>1.JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器</h2><h3 id="1-1-什么是-BlockingQueue"><a href="#1-1-什么是-BlockingQueue" class="headerlink" title="1.1 什么是 BlockingQueue"></a>1.1 什么是 BlockingQueue</h3><p>&emsp;&emsp;阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p><strong>BlockingQueue 和 ArrayBlockingQueue 之间的关系：</strong><br>&emsp;&emsp;BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 继承结构关系图：<br><img src="/images/java_multithreading/chapter25/20200210155410849.png" alt="在这里插入图片描述"></p><h3 id="1-2-ArrayBlockingQueue-有界的阻塞队列"><a href="#1-2-ArrayBlockingQueue-有界的阻塞队列" class="headerlink" title="1.2 ArrayBlockingQueue 有界的阻塞队列"></a>1.2 ArrayBlockingQueue 有界的阻塞队列</h3><p>&emsp;&emsp;ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p><p>ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。<br>通过源代码查看 ArrayBlockingQueue 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建具有给定（固定）容量和默认访问策略的 ArrayBlockingQueue 。</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@code</span> ArrayBlockingQueue&#125; with the given (fixed)</span></span><br><span class="line"><span class="comment"> * capacity and default access policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(capacity, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 ArrayBlockingQueue具有给定（固定）容量和指定访问策略。</span></span><br><span class="line"><span class="comment"> * 如果true然后对插入或删除阻塞的线程进行队列访问，则按FIFO顺序处理; 如果false访问顺序未指定。</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@code</span> ArrayBlockingQueue&#125; with the given (fixed)</span></span><br><span class="line"><span class="comment"> * capacity and the specified access policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair if &#123;<span class="doctag">@code</span> true&#125; then queue accesses for threads blocked</span></span><br><span class="line"><span class="comment"> *        on insertion or removal, are processed in FIFO order;</span></span><br><span class="line"><span class="comment"> *        if &#123;<span class="doctag">@code</span> false&#125; the access order is unspecified.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 ArrayBlockingQueue具有给定（固定）容量，指定访问策略和最初包含给定集合中的元素，添加在收集* 迭代器的遍历顺序。</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@code</span> ArrayBlockingQueue&#125; with the given (fixed)</span></span><br><span class="line"><span class="comment"> * capacity, the specified access policy and initially containing the</span></span><br><span class="line"><span class="comment"> * elements of the given collection,</span></span><br><span class="line"><span class="comment"> * added in traversal order of the collection&#x27;s iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair if &#123;<span class="doctag">@code</span> true&#125; then queue accesses for threads blocked</span></span><br><span class="line"><span class="comment"> *        on insertion or removal, are processed in FIFO order;</span></span><br><span class="line"><span class="comment"> *        if &#123;<span class="doctag">@code</span> false&#125; the access order is unspecified.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection of elements to initially contain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is less than</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> c.size()&#125;, or less than 1.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment"> *         of its elements are null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair,</span></span><br><span class="line"><span class="params">                          Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(capacity, fair);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                checkNotNull(e);</span><br><span class="line">                items[i++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;</span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-ArrayBlockingQueue-有界的阻塞队列特点"><a href="#1-3-ArrayBlockingQueue-有界的阻塞队列特点" class="headerlink" title="1.3 ArrayBlockingQueue 有界的阻塞队列特点"></a>1.3 ArrayBlockingQueue 有界的阻塞队列特点</h3><ol><li>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。</li><li>ArrayBlockingQueue 是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改。</li></ol><h3 id="1-4-常用的方法"><a href="#1-4-常用的方法" class="headerlink" title="1.4 常用的方法"></a>1.4 常用的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.thread.chapter25;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// add();</span></span><br><span class="line">        <span class="comment">// offer();</span></span><br><span class="line">        <span class="comment">// put();</span></span><br><span class="line">        <span class="comment">// poll();</span></span><br><span class="line">        <span class="comment">// peek();</span></span><br><span class="line">        <span class="comment">// element();</span></span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果可以在不超过队列的容量的情况下立即将其指定的元素插入到该队列的尾部，</span></span><br><span class="line"><span class="comment">     * 如果队列已满，则返回 true并抛出 IllegalStateException 。</span></span><br><span class="line"><span class="comment">     * 执行结果：</span></span><br><span class="line"><span class="comment">     *     =====执行add()签名方法-开始=====</span></span><br><span class="line"><span class="comment">     *     arrayBlockingQueue.add()执行返回结果：true</span></span><br><span class="line"><span class="comment">     *     arrayBlockingQueue.add()执行返回结果：true</span></span><br><span class="line"><span class="comment">     *     arrayBlockingQueue.add()执行返回结果：true</span></span><br><span class="line"><span class="comment">     *     Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">     *     at java.util.AbstractQueue.add(AbstractQueue.java:98)</span></span><br><span class="line"><span class="comment">     *     at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)</span></span><br><span class="line"><span class="comment">     *     at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.add(ArrayBlockingQueueExample.java:28)</span></span><br><span class="line"><span class="comment">     *     at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.main(ArrayBlockingQueueExample.java:7)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">arrayBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;arrayBlockingQueue.add()执行返回结果：&quot;</span>+arrayBlockingQueue.add(<span class="string">&quot;Message 1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;arrayBlockingQueue.add()执行返回结果：&quot;</span>+arrayBlockingQueue.add(<span class="string">&quot;Message 2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;arrayBlockingQueue.add()执行返回结果：&quot;</span>+arrayBlockingQueue.add(<span class="string">&quot;Message 3&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;arrayBlockingQueue.add()执行返回结果：&quot;</span>+arrayBlockingQueue.add(<span class="string">&quot;Message 4&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行add()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 如果可以在不超过队列容量的情况下立即将其指定的元素插入该队列的尾部，</span></span><br><span class="line"><span class="comment">      * 则在成功时true如果该队列已满，则返回false 。</span></span><br><span class="line"><span class="comment">      * 执行结果：</span></span><br><span class="line"><span class="comment">      *  =====执行offer()签名方法-开始=====</span></span><br><span class="line"><span class="comment">      *  arrayBlockingQueue.offer()执行返回结果：true</span></span><br><span class="line"><span class="comment">      *  arrayBlockingQueue.offer()执行返回结果：true</span></span><br><span class="line"><span class="comment">      *  arrayBlockingQueue.offer()执行返回结果：true</span></span><br><span class="line"><span class="comment">      *  arrayBlockingQueue.offer()执行返回结果：false</span></span><br><span class="line"><span class="comment">      *  =====执行offer()签名方法-结束=====</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行offer()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">arrayBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;arrayBlockingQueue.offer()执行返回结果：&quot;</span>+arrayBlockingQueue.offer(<span class="string">&quot;Message 1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;arrayBlockingQueue.offer()执行返回结果：&quot;</span>+arrayBlockingQueue.offer(<span class="string">&quot;Message 2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;arrayBlockingQueue.offer()执行返回结果：&quot;</span>+arrayBlockingQueue.offer(<span class="string">&quot;Message 3&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;arrayBlockingQueue.offer()执行返回结果：&quot;</span>+arrayBlockingQueue.offer(<span class="string">&quot;Message 4&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行offer()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 在该队列的尾部插入指定的元素，如果队列已满，则等待空间变为可用。</span></span><br><span class="line"><span class="comment">      *  执行结果：</span></span><br><span class="line"><span class="comment">      *   =====执行put()签名方法-开始=====</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中的个数：3</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中的容量：0</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中take()数据值为：Message 1</span></span><br><span class="line"><span class="comment">      *   Message 2</span></span><br><span class="line"><span class="comment">      *   Message 3</span></span><br><span class="line"><span class="comment">      *   Message 4</span></span><br><span class="line"><span class="comment">      *   =====执行put()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行put()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">arrayBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Executors.newSingleThreadExecutor().execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中的个数：&quot;</span> + arrayBlockingQueue.size());</span><br><span class="line">            System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中的容量：&quot;</span> + arrayBlockingQueue.remainingCapacity());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="comment">// 检索并删除此队列的头</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">take</span> <span class="operator">=</span> arrayBlockingQueue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中take()数据值为：&quot;</span> + take);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 4&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行put()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 检索并删除此队列的头，则等待空间变为可用。</span></span><br><span class="line"><span class="comment">      *  执行结果：</span></span><br><span class="line"><span class="comment">      *   =====执行poll()签名方法-开始=====</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中poll()数据值为：Message 1</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中poll()数据值为：Message 2</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中的个数：【1】,容量：【2】</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中poll()数据值为：Message 3</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中poll()数据值为：null</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中poll()数据值为：null</span></span><br><span class="line"><span class="comment">      *   =====执行poll()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行poll()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">arrayBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot;</span> + arrayBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot;</span> + arrayBlockingQueue.poll());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot;</span> + arrayBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot;</span> + arrayBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot;</span> + arrayBlockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行poll()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 检索但不删除此队列的头，如果此队列为空，则返回 null。</span></span><br><span class="line"><span class="comment">      *  执行结果：</span></span><br><span class="line"><span class="comment">      *   =====执行peek()签名方法-开始=====</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1</span></span><br><span class="line"><span class="comment">      *   =====执行peek()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行peek()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">arrayBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot;</span> + arrayBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot;</span> + arrayBlockingQueue.peek());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot;</span> + arrayBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot;</span> + arrayBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot;</span> + arrayBlockingQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行peek()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索，但不删除，这个队列的头。 此方法与peek的不同之处在于，如果此队列为空，它将抛出异常。</span></span><br><span class="line"><span class="comment">     *  执行结果：</span></span><br><span class="line"><span class="comment">     *   =====执行element()签名方法-开始=====</span></span><br><span class="line"><span class="comment">     *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">     *   当前arrayBlockingQueue对象中take()数据值为：Message 1</span></span><br><span class="line"><span class="comment">     *   当前arrayBlockingQueue对象中take()数据值为：Message 2</span></span><br><span class="line"><span class="comment">     *   当前arrayBlockingQueue对象中take()数据值为：Message 3</span></span><br><span class="line"><span class="comment">     *   当前arrayBlockingQueue对象中的个数：【0】,容量：【3】</span></span><br><span class="line"><span class="comment">     *   Exception in thread &quot;main&quot; java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">     *   at java.util.AbstractQueue.element(AbstractQueue.java:136)</span></span><br><span class="line"><span class="comment">     *   at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.element(ArrayBlockingQueueExample.java:182)</span></span><br><span class="line"><span class="comment">     *   at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.main(ArrayBlockingQueueExample.java:14)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">element</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行element()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">arrayBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中take()数据值为：&quot;</span> + arrayBlockingQueue.take());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中take()数据值为：&quot;</span> + arrayBlockingQueue.take());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中take()数据值为：&quot;</span> + arrayBlockingQueue.take());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中element()数据值为：&quot;</span> + arrayBlockingQueue.element());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行element()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 检索并删除此队列的头。 此方法与poll不同之处在于，如果此队列为空，它将抛出异常。</span></span><br><span class="line"><span class="comment">      * 执行结果：</span></span><br><span class="line"><span class="comment">      * =====执行remove()签名方法-开始=====</span></span><br><span class="line"><span class="comment">      * 当前arrayBlockingQueue对象中的个数：【3】,容量：【0】</span></span><br><span class="line"><span class="comment">      * 当前arrayBlockingQueue对象中remove()数据值为：Message 1</span></span><br><span class="line"><span class="comment">      * 当前arrayBlockingQueue对象中remove()数据值为：Message 2</span></span><br><span class="line"><span class="comment">      * 当前arrayBlockingQueue对象中remove()数据值为：Message 3</span></span><br><span class="line"><span class="comment">      * Exception in thread &quot;main&quot; java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">      * at java.util.AbstractQueue.remove(AbstractQueue.java:117)</span></span><br><span class="line"><span class="comment">      * at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.remove(ArrayBlockingQueueExample.java:212)</span></span><br><span class="line"><span class="comment">      * at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.main(ArrayBlockingQueueExample.java:15)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行remove()签名方法-开始=====&quot;</span>);</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">arrayBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;Message 3&quot;</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot;</span> + arrayBlockingQueue.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot;</span> + arrayBlockingQueue.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot;</span> + arrayBlockingQueue.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot;</span> + arrayBlockingQueue.remove());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;</span>, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行remove()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;– 以上为《JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。</p>  <p align="right">——厚积薄发(yuanxw)</p>]]></content>
    
    
    <summary type="html">阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</summary>
    
    
    
    <category term="Java多线程" scheme="https://yuanxw.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://yuanxw.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yuanxw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程(二十四)Java多线程之CompletableFuture类</title>
    <link href="https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%9B%9B)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCompletableFuture%E7%B1%BB/"/>
    <id>https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%9B%9B)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCompletableFuture%E7%B1%BB/</id>
    <published>2023-01-23T16:00:00.000Z</published>
    <updated>2025-09-03T08:22:32.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA多线程-二十四-Java多线程之CompletableFuture类"><a href="#1-JAVA多线程-二十四-Java多线程之CompletableFuture类" class="headerlink" title="1.JAVA多线程(二十四)Java多线程之CompletableFuture类"></a>1.JAVA多线程(二十四)Java多线程之CompletableFuture类</h2><h3 id="1-1-什么是Future"><a href="#1-1-什么是Future" class="headerlink" title="1.1 什么是Future"></a>1.1 什么是Future</h3><p>&emsp;&emsp;Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 构造一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 提交线程任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;当前【%s】线程工作-开始...&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;当前【%s】线程工作-结束...&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">                <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;【%s】在等待线程执行结果...&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">        System.out.println(<span class="string">&quot;是否执行结束：&quot;</span>+future.isDone());</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否执行结束：&quot;</span>+future.isDone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前【pool-1-thread-1】线程工作-开始...</span><br><span class="line">【main】在等待线程执行结果...</span><br><span class="line">是否执行结束：false</span><br><span class="line">当前【pool-1-thread-1】线程工作-结束...</span><br><span class="line">76</span><br><span class="line">是否执行结束：true</span><br></pre></td></tr></table></figure><h3 id="1-2-Future的局限性"><a href="#1-2-Future的局限性" class="headerlink" title="1.2 Future的局限性"></a>1.2 Future的局限性</h3><p>&emsp;&emsp;虽然Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果。CompletableFuture的出现解决了Future模式的缺点。</p><ul><li>不能手动完成：<ul><li>当你写了一个函数，用于通过一个远程API获取一个电子商务产品最新价格。因为这个 API 太耗时，你把它允许在一个独立的线程中，并且从你的函数中返回一个 Future。现在假设这个API服务宕机了，这时你想通过该产品的最新缓存价格手工完成这个Future 。你会发现无法这样做。</li></ul></li><li>Future的结果在非阻塞的情况下，不能执行更进一步的操作：<ul><li>Future 不会通知你它已经完成了，它提供了一个阻塞的 get() 方法通知你结果。你无法给 Future 植入一个回调函数，当 Future 结果可用的时候，用该回调函数自动的调用 Future 的结果。</li></ul></li><li>多个Future不能串联在一起组成链式调用：<ul><li>有时候你需要执行一个长时间运行的计算任务，并且当计算任务完成的时候，你需要把它的计算结果发送给另外一个长时间运行的计算任务等等。你会发现你无法使用 Future 创建这样的一个工作流。<br>  不能组合多个 Future 的结果<br>  假设你有10个不同的Future，你想并行的运行，然后在它们运行未完成后运行一些函数。你会发现你也无法使用 Future 这样做。</li></ul></li><li>没有异常处理：<ul><li>Future API 没有任务的异常处理结构居然有如此多的限制，幸好我们有CompletableFuture，你可以使用 CompletableFuture 达到以上所有目的。</li></ul></li></ul><h3 id="1-3-什么是CompletableFuture"><a href="#1-3-什么是CompletableFuture" class="headerlink" title="1.3 什么是CompletableFuture"></a>1.3 什么是CompletableFuture</h3><p>&emsp;&emsp; 在Java中CompletableFuture用于异步编程，异步编程是编写非阻塞的代码，运行的任务在一个单独的线程，与主线程隔离，并且会通知主线程它的进度，成功或者失败。在这种方式中，主线程不会被阻塞，不需要一直等到子线程完成。主线程可以并行的执行其他任务。使用这种并行方式，可以极大的提高程序的性能。<br>&emsp;&emsp; CompletableFuture 实现了 Future 和 CompletionStage接口，并且提供了许多关于创建，链式调用和组合多个 Future 的便利方法集，而且有广泛的异常处理支持。<br>&emsp;&emsp; CompletableFuture和Java8的Stream搭配使用，使用对于一些并行访问的耗时操作有很大的操作。</p><p><strong>CompletableFuture继承结构关系图</strong>：</p><p><img src="/images/java_multithreading/chapter24/20200205192248674.png" alt="在这里插入图片描述"><br>CompletableFuture类实现了CompletionStage和Future接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。</p><h3 id="1-4-CompletableFuture方法分类"><a href="#1-4-CompletableFuture方法分类" class="headerlink" title="1.4 CompletableFuture方法分类"></a>1.4 CompletableFuture方法分类</h3><h4 id="1-4-1-创建CompletableFuture对象"><a href="#1-4-1-创建CompletableFuture对象" class="headerlink" title="1.4.1. 创建CompletableFuture对象"></a>1.4.1. <strong>创建CompletableFuture对象</strong><br /></h4><p>&emsp;&emsp;以Async结尾并且没有指定Executor的方法会使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。runAsync方法也好理解，它以Runnable函数式接口类型为参数，所以CompletableFuture的计算结果为空。supplyAsync方法以Supplier&lt;U&gt;函数式接口类型为参数,CompletableFuture的计算结果类型为U。<br>CompletableFuture的静态工厂方法：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>runAsync(Runnable runnable)</td><td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。</td></tr><tr><td>runAsync(Runnable runnable, Executor executor)</td><td>使用指定的thread pool执行异步代码。</td></tr><tr><td>supplyAsync(Supplier<U> supplier)</td><td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值。</td></tr><tr><td>supplyAsync(Supplier<U> supplier, Executor executor)</td><td>使用指定的thread pool执行异步代码，异步操作有返回值。</td></tr></tbody></table><ul><li>CompletableFuture.completedFuture是一个静态辅助方法，用来返回一个已经计算好的CompletableFuture。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is already completed with</span></span><br><span class="line"><span class="comment"> * the given value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the type of the value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the completed CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">completedFuture</span><span class="params">(U value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;U&gt;((value == <span class="literal">null</span>) ? NIL : value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而以下四个静态方法用来为一段异步执行的代码创建CompletableFuture对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the &#123;<span class="doctag">@link</span> ForkJoinPool#commonPool()&#125; with</span></span><br><span class="line"><span class="comment"> * the value obtained by calling the given Supplier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier a function returning the value to be used</span></span><br><span class="line"><span class="comment"> * to complete the returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the function&#x27;s return type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the given executor with the value obtained</span></span><br><span class="line"><span class="comment"> * by calling the given Supplier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier a function returning the value to be used</span></span><br><span class="line"><span class="comment"> * to complete the returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor the executor to use for asynchronous execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the function&#x27;s return type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the &#123;<span class="doctag">@link</span> ForkJoinPool#commonPool()&#125; after</span></span><br><span class="line"><span class="comment"> * it runs the given action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the action to run before completing the</span></span><br><span class="line"><span class="comment"> * returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the given executor after it runs the given</span></span><br><span class="line"><span class="comment"> * action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the action to run before completing the</span></span><br><span class="line"><span class="comment"> * returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor the executor to use for asynchronous execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-主动完成计算"><a href="#1-4-2-主动完成计算" class="headerlink" title="1.4.2. 主动完成计算"></a>1.4.2. <strong>主动完成计算</strong></h4><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>get()</td><td>方法同步等待结果。</td></tr><tr><td>get(timeout,unit)</td><td>get(timeout,unit)签名方法，给定时间，然后返回其结果，如果超时，抛出异常</td></tr><tr><td>join()</td><td>完成后返回结果值，如果完成异常，则返回（未检查）异常。</td></tr><tr><td>getNow()</td><td>如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        runAsync();</span><br><span class="line">        <span class="comment">// get() 方法同步等待结果。</span></span><br><span class="line">        get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get(timeout,unit)签名方法，给定时间，然后返回其结果，如果超时，抛出异常</span></span><br><span class="line">        get(<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// join() 完成后返回结果值，如果完成异常，则返回（未检查）异常。</span></span><br><span class="line">        join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getNow() 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。</span></span><br><span class="line">        getNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * runAsync()异步执行runAsync返回的CompletableFuture是没有返回值的。</span></span><br><span class="line"><span class="comment">     * supplyAsync()异步执行runAsync返回的CompletableFuture是有返回值的。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">     =====【main】执行runAsync()签名方法-开始=====</span></span><br><span class="line"><span class="comment">     Hello world！！！</span></span><br><span class="line"><span class="comment">     =====【main】执行runAsync()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】执行runAsync()签名方法-开始=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;Hello world！！！&quot;</span>)).get();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】执行runAsync()签名方法-结束=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     get() 方法同步等待结果。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">          =====【main】执行get()签名方法-开始=====</span></span><br><span class="line"><span class="comment">          get()签名方法，执行结果：4</span></span><br><span class="line"><span class="comment">          =====【main】执行get()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】执行get()签名方法-开始=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 睡眠5秒</span></span><br><span class="line">            processSleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/** get() 方法同步等待结果。 **/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;get()签名方法，执行结果：&quot;</span>+completableFuture.get());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】执行get()签名方法-结束=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     get(timeout,unit)签名方法，给定时间，然后返回其结果，如果超时，抛出异常</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">     =====【main】执行get(timeout,unit)签名方法-开始=====</span></span><br><span class="line"><span class="comment">     java.util.concurrent.TimeoutException</span></span><br><span class="line"><span class="comment">     at java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1771)</span></span><br><span class="line"><span class="comment">     at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1915)</span></span><br><span class="line"><span class="comment">     at com.yuanxw.chapter24.CompletableFutureExample.get(CompletableFutureExample.java:53)</span></span><br><span class="line"><span class="comment">     at com.yuanxw.chapter24.CompletableFutureExample.main(CompletableFutureExample.java:11)</span></span><br><span class="line"><span class="comment">     =====【main】执行get(timeout,unit)签名方法-结束=====</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】执行get(timeout,unit)签名方法-开始=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 睡眠5秒</span></span><br><span class="line">            processSleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;get(timeout,unit)签名方法，执行结果：&quot;</span>+completableFuture.get(timeout,unit));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】执行get(timeout,unit)签名方法-结束=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      join() 完成后返回结果值，如果完成异常，则返回（未检查）异常。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====【main】执行join()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         join()签名方法，执行结果：40</span></span><br><span class="line"><span class="comment">         =====【main】执行join()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】执行join()签名方法-开始=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 睡眠5秒</span></span><br><span class="line">            processSleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>) * <span class="number">5</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/** join() 完成后返回结果值，如果完成异常，则返回（未检查）异常。 **/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;join()签名方法，执行结果：&quot;</span>+ completableFuture.join());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】执行join()签名方法-结束=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     getNow() 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">      =====【main】执行getNow()签名方法-开始=====</span></span><br><span class="line"><span class="comment">      getNow()签名方法，执行结果：===unknown===</span></span><br><span class="line"><span class="comment">      getNow()签名方法，执行结果：N</span></span><br><span class="line"><span class="comment">      =====【main】getNow()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNow</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】执行getNow()签名方法-开始=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 睡眠5秒</span></span><br><span class="line">            processSleep(<span class="number">5</span>);</span><br><span class="line">            <span class="comment">// 生成随机字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (ThreadLocalRandom.current().nextInt(<span class="number">25</span> )+ <span class="number">65</span>);</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(c);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/** getNow() 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。 **/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;getNow()签名方法，执行结果：&quot;</span>+ completableFuture.getNow(<span class="string">&quot;===unknown===&quot;</span>));</span><br><span class="line">        processSleep(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;getNow()签名方法，执行结果：&quot;</span>+ completableFuture.getNow(<span class="string">&quot;===unknown===&quot;</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;=====【%s】getNow()签名方法-结束=====&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程休眠的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processSleep</span><span class="params">(<span class="type">long</span> seconds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-计算结果完成时的处理"><a href="#1-4-3-计算结果完成时的处理" class="headerlink" title="1.4.3. 计算结果完成时的处理 "></a>1.4.3. <strong>计算结果完成时的处理</strong> <br/></h4><p>&emsp;&emsp; 当CompletableFuture计算结果完成时,我们需要对结果进行处理，或者当CompletableFuture产生异常的时候需要对异常进行处理。有如下几种方法:</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action)</td><td>当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。</td></tr><tr><td>whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action)</td><td>当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用ForkJoinPool。</td></tr><tr><td>BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor)</td><td>当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用指定的线程池。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        whenComplete();</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * runAsync()异步执行runAsync返回的CompletableFuture是没有返回值的。</span></span><br><span class="line"><span class="comment">     * supplyAsync()异步执行runAsync返回的CompletableFuture是有返回值的。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">     =====【main】执行runAsync()签名方法-开始=====</span></span><br><span class="line"><span class="comment">     Hello world！！！</span></span><br><span class="line"><span class="comment">     =====【main】执行runAsync()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * whenComplete()：当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行whenComplete()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         执行supplyAsync()签名方法-结束&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">         统计字符串长度：14</span></span><br><span class="line"><span class="comment">         =====执行whenComplete()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">whenComplete</span><span class="params">()</span>  &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行whenComplete()签名方法-开始=====&quot;</span>);</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt;&#123;</span><br><span class="line">            <span class="comment">// 睡眠5秒</span></span><br><span class="line">            processSleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;执行supplyAsync()签名方法-结束&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello world！！！&quot;</span>;</span><br><span class="line">        &#125;).whenComplete((s, throwable) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;统计字符串长度：&quot;</span>+s.length());</span><br><span class="line">            System.out.println(<span class="string">&quot;=====执行whenComplete()签名方法-结束=====&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程休眠的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processSleep</span><span class="params">(<span class="type">long</span> seconds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-4-计算结果完成时的转换"><a href="#1-4-4-计算结果完成时的转换" class="headerlink" title="1.4.4. 计算结果完成时的转换 "></a>1.4.4. <strong>计算结果完成时的转换</strong> <br/></h4><p>&emsp;&emsp; 这里同样也是返回CompletableFuture，但是这个结果会由我们自定义返回去转换他，同样的不以Async结尾的方法由原来的线程计算，以Async结尾的方法由默认的线程池ForkJoinPool.commonPool()或者指定的线程池executor运行。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</td><td>接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture。</td></tr><tr><td>public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</td><td>接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用ForkJoinPool。</td></tr><tr><td>public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</td><td>接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用指定的线程池。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        thenApply();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     thenApply() 当原来的CompletableFuture计算完后，将结果传递给函数fn，将fn的结果作为新的CompletableFuture计算结果。</span></span><br><span class="line"><span class="comment">     因此它的功能相当于将CompletableFuture&lt;T&gt;转换成CompletableFuture&lt;U&gt;。。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行thenApply()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         thenApply()签名方法，在supplyAsync阶段，执行结果：DFRHHQ</span></span><br><span class="line"><span class="comment">         thenApply()签名方法，执行结果：###【dfrhhq】###</span></span><br><span class="line"><span class="comment">         =====thenApply()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thenApply</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行thenApply()签名方法-开始=====&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 睡眠5秒</span></span><br><span class="line">            processSleep(<span class="number">5</span>);</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            IntStream.range(<span class="number">0</span>,<span class="number">6</span>).boxed().forEach(integer -&gt; &#123;</span><br><span class="line">                <span class="comment">// 生成随机字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (ThreadLocalRandom.current().nextInt(<span class="number">25</span> )+ <span class="number">65</span>);</span><br><span class="line">                buffer.append(c);</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;thenApply()签名方法，在supplyAsync阶段，执行结果：&quot;</span> + buffer.toString());</span><br><span class="line">            <span class="keyword">return</span> buffer.toString();</span><br><span class="line">        &#125;).thenApply(str -&gt; String.format(<span class="string">&quot;###【%s】###&quot;</span>, str.toLowerCase()));</span><br><span class="line">        System.out.println(<span class="string">&quot;thenApply()签名方法，执行结果：&quot;</span>+ completableFuture.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====thenApply()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程休眠的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processSleep</span><span class="params">(<span class="type">long</span> seconds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-5-计算结果完成时的消费"><a href="#1-4-5-计算结果完成时的消费" class="headerlink" title="1.4.5. 计算结果完成时的消费 "></a>1.4.5. <strong>计算结果完成时的消费</strong> <br/></h4><p>&emsp;&emsp; 这里还会有一个只会对计算结果消费不会返回任何结果的方法。同样的不以Async结尾的方法由原来的线程计算，以Async结尾的方法由默认的线程池ForkJoinPool.commonPool()或者指定的线程池executor运行。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>public CompletableFuture<Void> thenAccept(Consumer&lt;? super T&gt; action)</td><td>当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值。</td></tr><tr><td>public CompletableFuture<Void> thenAcceptAsync(Consumer&lt;? super T&gt; action)</td><td>当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值，使用ForkJoinPool。</td></tr><tr><td>public CompletableFuture<Void> thenAcceptAsync(Consumer&lt;? super T&gt; action,Executor executor)</td><td>当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        thenAccept();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     thenAccept() CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">     =====执行thenAccept()签名方法-开始=====</span></span><br><span class="line"><span class="comment">     系统自动生成的6位验证码：EHSRHT，该验证码5分钟有效，请勿泄露给他人。</span></span><br><span class="line"><span class="comment">     =====thenAccept()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thenAccept</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行thenAccept()签名方法-开始=====&quot;</span>);</span><br><span class="line">        CompletableFuture</span><br><span class="line">                .supplyAsync(() -&gt; <span class="string">&quot;系统自动生成的6位验证码：&quot;</span>)</span><br><span class="line">                .thenApply((str) -&gt; str + verifiCode())</span><br><span class="line">                .thenApply((str) -&gt; str + <span class="string">&quot;，该验证码5分钟有效，请勿泄露给他人。&quot;</span>)</span><br><span class="line">                .thenAccept(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====thenAccept()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成6位数验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">verifiCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        IntStream.range(<span class="number">0</span>,<span class="number">6</span>).boxed().forEach(integer -&gt; &#123;</span><br><span class="line">            <span class="comment">// 生成随机字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (ThreadLocalRandom.current().nextInt(<span class="number">25</span> )+ <span class="number">65</span>);</span><br><span class="line">            buffer.append(c);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-4-6-计算结果完成时的消费合并结果"><a href="#1-4-6-计算结果完成时的消费合并结果" class="headerlink" title="1.4.6. 计算结果完成时的消费合并结果 "></a>1.4.6. <strong>计算结果完成时的消费合并结果</strong> <br/></h4><p>&emsp;&emsp; thenAcceptBoth以及相关方法提供了类似的功能，当两个CompletionStage都正常完成计算的时候，就会执行提供的action，它用来组合另外一个异步的结果。</p><p>&emsp;&emsp; runAfterBoth是当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action)</td><td>当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。</td></tr><tr><td>public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action)</td><td>当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td></tr><tr><td>public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action, Executor executor)</td><td>当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td></tr><tr><td>public CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other,Runnable action)</td><td>当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。</td></tr><tr><td>public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action)</td><td>当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。使用ForkJoinPool。</td></tr><tr><td>public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</td><td>当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。使用指定的线程池。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        thenAcceptBoth();</span><br><span class="line">        runAfterBoth();</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     thenAcceptBoth() 当你想要使用两个Future结果时，但不需要将任何结果值进行返回时，</span></span><br><span class="line"><span class="comment">     可以用 thenAcceptBoth ，它表示后续的处理不需要返回值。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====执行thenAcceptBoth()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         Hello World</span></span><br><span class="line"><span class="comment">         =====thenAcceptBoth()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thenAcceptBoth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行thenAcceptBoth()签名方法-开始=====&quot;</span>);</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">                .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot; World&quot;</span>),</span><br><span class="line">                        (s1, s2) -&gt; System.out.println(s1 + s2));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====thenAcceptBoth()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * runAfterBoth是当两个CompletionStage都正常完成计算的时候,</span></span><br><span class="line"><span class="comment">     执行一个Runnable，这个Runnable并不使用计算的结果。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">          =====执行runAfterBoth()签名方法-开始=====</span></span><br><span class="line"><span class="comment">          ForkJoinPool.commonPool-worker-1线程，工作-开始&gt;&gt;</span></span><br><span class="line"><span class="comment">          ForkJoinPool.commonPool-worker-2线程，工作-开始&gt;&gt;</span></span><br><span class="line"><span class="comment">          =====runAfterBoth()签名方法-结束=====</span></span><br><span class="line"><span class="comment">          ForkJoinPool.commonPool-worker-2线程，工作-结束&lt;&lt;</span></span><br><span class="line"><span class="comment">          ForkJoinPool.commonPool-worker-1线程，工作-结束&lt;&lt;</span></span><br><span class="line"><span class="comment">          ===执行任务结束===</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runAfterBoth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行runAfterBoth()签名方法-开始=====&quot;</span>);</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程，工作-开始&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="comment">// 睡眠5秒</span></span><br><span class="line">            processSleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程，工作-结束&lt;&lt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;).runAfterBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程，工作-开始&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="comment">// 睡眠1秒</span></span><br><span class="line">            processSleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程，工作-结束&lt;&lt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;), () -&gt; System.out.println(<span class="string">&quot;===执行任务结束===&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====runAfterBoth()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程休眠的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processSleep</span><span class="params">(<span class="type">long</span> seconds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-4-7-对计算结果的组合"><a href="#1-4-7-对计算结果的组合" class="headerlink" title="1.4.7. 对计算结果的组合 "></a>1.4.7. <strong>对计算结果的组合</strong> <br/></h4><p>&emsp;&emsp; 对于Compose可以连接两个CompletableFuture，其内部处理逻辑是当第一个CompletableFuture处理没有完成时会合并成一个CompletableFuture,如果处理完成，第二个future会紧接上一个CompletableFuture进行处理。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td><td>当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。</td></tr><tr><td>public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td><td>当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td></tr><tr><td>public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)</td><td>当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        thenCombine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行thenCombine()对于Compose可以连接两个CompletableFuture，</span></span><br><span class="line"><span class="comment">     * 其内部处理逻辑是当第一个CompletableFuture处理没有完成时会合并成一个CompletableFuture,</span></span><br><span class="line"><span class="comment">     * 如果处理完成，第二个future会紧接上一个CompletableFuture进行处理。</span></span><br><span class="line"><span class="comment">      执行结果：</span></span><br><span class="line"><span class="comment">         =====执行thenCombine()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         thenCombine()签名方法，执行结果：计算结果：30</span></span><br><span class="line"><span class="comment">         =====thenCombine()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thenCombine</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====执行thenCombine()签名方法-开始=====&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = future1.thenCombine(future2, (x, y) -&gt; <span class="string">&quot;计算结果：&quot;</span> + (x + y));</span><br><span class="line">        System.out.println(<span class="string">&quot;thenCombine()签名方法，执行结果：&quot;</span>+ completableFuture.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====thenCombine()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-4-8-对计算结果的异常处理"><a href="#1-4-8-对计算结果的异常处理" class="headerlink" title="1.4.8. 对计算结果的异常处理 "></a>1.4.8. <strong>对计算结果的异常处理</strong> <br/></h4><p>&emsp;&emsp; 当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。<br>&emsp;&emsp; exceptionally() 方法将导致CompletableFuture 内发生问题的异常抛出。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>public <U> CompletableFuture<U> handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td><td>当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。</td></tr><tr><td>public <U> CompletableFuture<U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td><td>当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。使用ForkJoinPool。</td></tr><tr><td>public <U> CompletableFuture<U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)</td><td>当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。使用指定的线程池。</td></tr><tr><td>public CompletableFuture<T> exceptionally(Function&lt;Throwable, ? extends T&gt; fn)</td><td>exceptionally() 方法将导致CompletableFuture 内发生问题的异常抛出。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        handle();</span><br><span class="line">        exceptionally();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     handle() 当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====handle()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         handle()签名方法，在supplyAsync阶段，执行1/0结果。</span></span><br><span class="line"><span class="comment">         handle()签名方法，执行结果：-1</span></span><br><span class="line"><span class="comment">         =====handle()签名方法-结束=====</span></span><br><span class="line"><span class="comment">         java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1592)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1582)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)</span></span><br><span class="line"><span class="comment">         Caused by: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">         at com.yuanxw.chapter24.CompletableFutureExample7.lambda$handle$0(CompletableFutureExample3.java:26)</span></span><br><span class="line"><span class="comment">         at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1590)</span></span><br><span class="line"><span class="comment">         ... 5 more</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====handle()签名方法-开始=====&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;handle()签名方法，在supplyAsync阶段，执行1/0结果。&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;).handle((integer, throwable) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(throwable != <span class="literal">null</span>)&#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">return</span> integer;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;handle()签名方法，执行结果：&quot;</span>+ completableFuture.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====handle()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * exceptionally() 方法将导致CompletableFuture 内发生问题的异常抛出。</span></span><br><span class="line"><span class="comment">     * 这样，当执行任务发生异常时，调用get()方法的线程将会收到一个 ExecutionException 异常，</span></span><br><span class="line"><span class="comment">     * 该异常接收了一个包含失败原因的Exception 参数。</span></span><br><span class="line"><span class="comment">     * 执行结果：</span></span><br><span class="line"><span class="comment">         =====exceptionally()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         exceptionally()签名方法，在supplyAsync阶段，执行1/0结果。</span></span><br><span class="line"><span class="comment">         exceptionally()签名方法，执行结果：java.lang.ArrayIndexOutOfBoundsException: 1</span></span><br><span class="line"><span class="comment">         =====exceptionally()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exceptionally</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====exceptionally()签名方法-开始=====&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;exceptionally()签名方法，在supplyAsync阶段，执行1/0结果。&quot;</span>);</span><br><span class="line">            String [] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;;</span><br><span class="line">            <span class="comment">// 此处异常：java.lang.ArrayIndexOutOfBoundsException: 1</span></span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">1</span>];</span><br><span class="line">        &#125;).exceptionally(ex -&gt; ex.getMessage());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;exceptionally()签名方法，执行结果：&quot;</span>+ completableFuture.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;=====exceptionally()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-9-其它方法"><a href="#1-4-9-其它方法" class="headerlink" title="1.4.9. 其它方法 "></a>1.4.9. <strong>其它方法</strong> <br/></h4><p>&emsp;&emsp;allOf方法是当所有的CompletableFuture都执行完后执行计算。anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>public static CompletableFuture<Void> allOf(CompletableFuture&lt;?&gt;… cfs)</td><td>allOf方法是当所有的CompletableFuture都执行完后执行计算。</td></tr><tr><td>public static CompletableFuture<Object> anyOf(CompletableFuture&lt;?&gt;… cfs)</td><td>anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        anyAndAllOfCompletableFuture();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     allOf方法是当所有的CompletableFuture都执行完后执行计算。</span></span><br><span class="line"><span class="comment">     anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。</span></span><br><span class="line"><span class="comment">     执行结果：</span></span><br><span class="line"><span class="comment">         =====anyAndAllOfCompletableFuture()签名方法-开始=====</span></span><br><span class="line"><span class="comment">         ForkJoinPool.commonPool-worker-1线程，工作-开始&gt;&gt;</span></span><br><span class="line"><span class="comment">         ForkJoinPool.commonPool-worker-2线程，工作-开始&gt;&gt;</span></span><br><span class="line"><span class="comment">         ForkJoinPool.commonPool-worker-2线程，工作-结束&lt;&lt;</span></span><br><span class="line"><span class="comment">         anyOf()签名方法，执行结果：result-2</span></span><br><span class="line"><span class="comment">         ForkJoinPool.commonPool-worker-1线程，工作-结束&lt;&lt;</span></span><br><span class="line"><span class="comment">         =====anyAndAllOfCompletableFuture()签名方法-结束=====</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">anyAndAllOfCompletableFuture</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====anyAndAllOfCompletableFuture()签名方法-开始=====&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture1=CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//模拟执行耗时任务</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程，工作-开始&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="comment">// 睡眠5秒</span></span><br><span class="line">            processSleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程，工作-结束&lt;&lt;&quot;</span>);</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;result-1&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture2=CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//模拟执行耗时任务</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程，工作-开始&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="comment">// 睡眠5秒</span></span><br><span class="line">            processSleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程，工作-结束&lt;&lt;&quot;</span>);</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;result-2&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Object&gt; anyOfCompletableFuture = CompletableFuture.anyOf(completableFuture1,completableFuture2);</span><br><span class="line">        System.out.println(<span class="string">&quot;anyOf()签名方法，执行结果：&quot;</span>+ anyOfCompletableFuture.get());</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; allOfCompletableFuture = CompletableFuture.allOf(completableFuture1,completableFuture2);</span><br><span class="line">        <span class="comment">// 阻塞等待所有任务执行完成</span></span><br><span class="line">        allOfCompletableFuture.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;=====anyAndAllOfCompletableFuture()签名方法-结束=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程休眠的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processSleep</span><span class="params">(<span class="type">long</span> seconds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十四)Java多线程之CompletableFuture类》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。<br>  <p align="right">——厚积薄发(yuanxw)</p></p>]]></content>
    
    
    <summary type="html">Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</summary>
    
    
    
    <category term="Java多线程" scheme="https://yuanxw.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://yuanxw.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yuanxw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池</title>
    <link href="https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%89)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BScheduledThreadPool%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%89)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BScheduledThreadPool%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2023-01-22T16:00:00.000Z</published>
    <updated>2025-09-03T08:23:13.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA多线程-二十三-Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池"><a href="#1-JAVA多线程-二十三-Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池" class="headerlink" title="1.JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池"></a>1.JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池</h2><h3 id="1-1-定时执行任务线程池ScheduledThreadPoolExecutor"><a href="#1-1-定时执行任务线程池ScheduledThreadPoolExecutor" class="headerlink" title="1.1 定时执行任务线程池ScheduledThreadPoolExecutor"></a>1.1 定时执行任务线程池ScheduledThreadPoolExecutor</h3><p>&emsp;&emsp; ScheduledThreadPoolExecutor是一个使用线程池执行定时任务的类，相较于Java中提供的另一个执行定时任务的类Timer，其主要有如下两个优点：</p><ul><li>使用多线程执行任务，不用担心任务执行时间过长而导致任务相互阻塞的情况，Timer是单线程执行的，因而会出现这个问题。</li><li>不用担心任务执行过程中，如果线程失活，其会新建线程执行任务，Timer类的单线程挂掉之后是不会重新创建线程执行后续任务的。</li></ul><p><strong>时cheduledThreadPoolExecutor定 执行任务线程池继承结构关系图</strong>：<br><img src="/images/java_multithreading/chapter23/2020020318503054.png" alt="在这里插入图片描述"></p><p>通过源代码查看ScheduledThreadPoolExecutor构造函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个ScheduledThreadPoolExecutor，需要指定核心线程池大小。</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ScheduledThreadPoolExecutor&#125; with the</span></span><br><span class="line"><span class="comment"> * given core pool size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new ScheduledThreadPoolExecutor with the given</span></span><br><span class="line"><span class="comment"> * initial parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ScheduledThreadPoolExecutor&#125; with the</span></span><br><span class="line"><span class="comment"> * given initial parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> threadFactory&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new ScheduledThreadPoolExecutor with the given</span></span><br><span class="line"><span class="comment"> * initial parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> threadFactory&#125; or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                                   RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ScheduledThreadPoolExecutor实现中：</p><ul><li>corePoolSize &#x3D;&gt; 需要自己传递参数，指定核心线程数大小。</li><li>maximumPoolSize &#x3D;&gt; 允许最大的线程数默认Integer.MAX_VALUE无限大。</li><li>keepAliveTime &#x3D;&gt; keepAliveTime为0，意味着多余的空闲线程会被立即终止。</li><li>workQueue &#x3D;&gt; 采用DelayedWorkQueue作为线程池的工作队列。该队列是一个使用数组实现的优先队列，在调用ScheduledFutureTask::cancel()方法时，其会根据removeOnCancel变量的设置来确认是否需要将当前任务真正的从队列中移除，而不只是标识其为已删除状态。</li></ul><h3 id="1-2-ScheduledThreadPoolExecutor使用样例"><a href="#1-2-ScheduledThreadPoolExecutor使用样例" class="headerlink" title="1.2 ScheduledThreadPoolExecutor使用样例"></a>1.2 ScheduledThreadPoolExecutor使用样例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter23;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// schedule();</span></span><br><span class="line">        <span class="comment">// scheduleAtFixedRate();</span></span><br><span class="line">        scheduleWithFixedDelay();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单次定时任务调用</span></span><br><span class="line"><span class="comment">     * schedule(Runnable command, long delay, TimeUnit unit) // 无返回值的延迟任务</span></span><br><span class="line"><span class="comment">     * schedule(Callable callable, long delay, TimeUnit unit) // 有返回值的延迟任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">scheduledThreadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 创建并执行在给定延迟后启用的单次操作。</span></span><br><span class="line">        ScheduledFuture&lt;?&gt; scheduledFuture = scheduledThreadPoolExecutor.schedule(() -&gt; System.out.println(<span class="string">&quot;定时任务正在被执行&gt;&gt;&gt;&quot;</span>), <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 尝试取消执行此任务。</span></span><br><span class="line">        System.out.println(scheduledFuture.cancel(<span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         执行结果：</span></span><br><span class="line"><span class="comment">          true</span></span><br><span class="line"><span class="comment">     */</span>      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定频率周期任务</span></span><br><span class="line"><span class="comment">     * 注意：一次任务超时，会持续的影响后续的任务周期；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">scheduleAtFixedRate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">scheduledThreadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">5</span>);</span><br><span class="line">        scheduledThreadPoolExecutor.scheduleAtFixedRate(()-&gt;System.out.println(String.format(<span class="string">&quot;===定时任务线程【%s】正在执行，执行时间：【%s】===&quot;</span>, Thread.currentThread().getName(),System.currentTimeMillis())),<span class="number">2</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         执行结果：</span></span><br><span class="line"><span class="comment">          ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580728645370】===</span></span><br><span class="line"><span class="comment">          ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580728647372】===</span></span><br><span class="line"><span class="comment">          ===定时任务线程【pool-1-thread-2】正在执行，执行时间：【1580728649372】===</span></span><br><span class="line"><span class="comment">          ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580728651374】===</span></span><br><span class="line"><span class="comment">          ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580728653371】===</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定延迟周期任务</span></span><br><span class="line"><span class="comment">     * 注意：固定延迟周期任务，即每次任务结束后，需要再加上等待固定时间；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">scheduleWithFixedDelay</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">scheduledThreadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">5</span>);</span><br><span class="line">        scheduledThreadPoolExecutor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;===定时任务线程【%s】正在执行，执行时间：【%s】===&quot;</span>, Thread.currentThread().getName(),System.currentTimeMillis()));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠5秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         执行结果：</span></span><br><span class="line"><span class="comment">         ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580729087258】===</span></span><br><span class="line"><span class="comment">         ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580729094268】===</span></span><br><span class="line"><span class="comment">         ===定时任务线程【pool-1-thread-2】正在执行，执行时间：【1580729101272】===</span></span><br><span class="line"><span class="comment">         ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580729108273】===</span></span><br><span class="line"><span class="comment">         ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580729115275】===</span></span><br><span class="line"><span class="comment">         ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580729122277】===</span></span><br><span class="line"><span class="comment">         ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580729129279】===</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-ScheduledThreadPoolExecutor运行机制"><a href="#1-3-ScheduledThreadPoolExecutor运行机制" class="headerlink" title="1.3 ScheduledThreadPoolExecutor运行机制"></a>1.3 ScheduledThreadPoolExecutor运行机制</h3><p>&emsp;&emsp; ScheduledThreadPoolExecutor 使用的任务队列 DelayQueue 封装了一个 PriorityQueue，PriorityQueue 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(ScheduledFutureTask 的 time 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(ScheduledFutureTask 的 squenceNumber 变量小的先执行)。<br><img src="/images/java_multithreading/chapter23/20200203200817381.png" alt="在这里插入图片描述"></p><ul><li><p>ScheduledThreadPoolExecutor 和 Timer 的比较：</p><ul><li>Timer 对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是；</li><li>Timer 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 ScheduledThreadPoolExecutor 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程;</li><li>在TimerTask 中抛出的运行时异常会杀死一个线程，从而导致 Timer 死机:-( …即计划任务将不再运行。ScheduledThreadExecutor 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 afterExecute 方法ThreadPoolExecutor）。抛出异常的任务将被取消，但其他任务将继续运行。</li></ul></li><li><p>ScheduledThreadPoolExecutor 的执行主要分为两大部分：</p><ul><li>当调用 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate() 方法或者<strong>scheduleWirhFixedDelay()</strong> 方法时，会向 ScheduledThreadPoolExecutor 的 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduledFutureTask 。<br>  线程池中的线程从 DelayQueue 中获取 ScheduledFutureTask，然后执行任务。</li></ul></li><li><p>ScheduledThreadPoolExecutor 为了实现周期性的执行任务，对 ThreadPoolExecutor 做了如下修改：</p><ul><li>使用 DelayQueue 作为任务队列；</li><li>获取任务的方不同</li><li>执行周期任务后，增加了额外的处理</li></ul></li></ul><h3 id="1-4-ScheduledThreadPoolExecutor-执行周期任务的步骤"><a href="#1-4-ScheduledThreadPoolExecutor-执行周期任务的步骤" class="headerlink" title="1.4 ScheduledThreadPoolExecutor 执行周期任务的步骤"></a>1.4 ScheduledThreadPoolExecutor 执行周期任务的步骤</h3><p><img src="/images/java_multithreading/chapter23/20200203202333261.png" alt="在这里插入图片描述"></p><ul><li>线程 1 从 DelayQueue 中获取已到期的 ScheduledFutureTask（DelayQueue.take()）。到期任务是指 ScheduledFutureTask 的 time 大于等于当前系统的时间；</li><li>线程 1 执行这个 ScheduledFutureTask；</li><li>线程 1 修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间；</li><li>线程 1 把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add())。</li></ul><p> &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。<br>  <p align="right">——厚积薄发(yuanxw)</p></p>]]></content>
    
    
    <summary type="html">ScheduledThreadPoolExecutor是一个使用线程池执行定时任务的类，相较于Java中提供的另一个执行定时任务的类Timer，其主要有如下两个优点：1)使用多线程执行任务，不用担心任务执行时间过长而导致任务相互阻塞的情况，Timer是单线程执行的，因而会出现这个问题。2)不用担心任务执行过程中，如果线程失活，其会新建线程执行任务，Timer类的单线程挂掉之后是不会重新创建线程执行后续任务的。</summary>
    
    
    
    <category term="Java多线程" scheme="https://yuanxw.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://yuanxw.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yuanxw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池</title>
    <link href="https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%BA%8C)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BWorkStealingPool%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://yuanxw.github.io/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%BA%8C)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BWorkStealingPool%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2023-01-21T16:00:00.000Z</published>
    <updated>2025-09-03T08:23:40.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA多线程-二十二-Java多线程之WorkStealingPool工作窃取线程池"><a href="#1-JAVA多线程-二十二-Java多线程之WorkStealingPool工作窃取线程池" class="headerlink" title="1.JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池"></a>1.JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池</h2><h3 id="1-1-工作窃取线程池WorkStealingPool"><a href="#1-1-工作窃取线程池WorkStealingPool" class="headerlink" title="1.1 工作窃取线程池WorkStealingPool"></a>1.1 工作窃取线程池WorkStealingPool</h3><p>&emsp;&emsp; 在Java 8中，引入了一种新型的线程池，作为newWorkStealingPool()来补充现有的线程池。WorkStealingPool线程池，来维持相应的并行级别，它会通过工作窃取的方式，使得多核的 CPU 不会闲置，总会有活着的线程让 CPU 去运行。</p><p>&emsp;&emsp;顾名思义，它基于  工作窃取算法，其中任务可以生成其他较小的任务，这些任务将添加到并行处理线程的队列中。如果一个线程完成了工作并且无事可做，则可以从另一线程的队列中“窃取”工作。<br>通过源代码查看WorkStealingPool实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a work-stealing thread pool using all</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Runtime#availableProcessors available processors&#125;</span></span><br><span class="line"><span class="comment"> * as its target parallelism level.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #newWorkStealingPool(int)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a thread pool that maintains enough threads to support</span></span><br><span class="line"><span class="comment"> * the given parallelism level, and may use multiple queues to</span></span><br><span class="line"><span class="comment"> * reduce contention. The parallelism level corresponds to the</span></span><br><span class="line"><span class="comment"> * maximum number of threads actively engaged in, or available to</span></span><br><span class="line"><span class="comment"> * engage in, task processing. The actual number of threads may</span></span><br><span class="line"><span class="comment"> * grow and shrink dynamically. A work-stealing pool makes no</span></span><br><span class="line"><span class="comment"> * guarantees about the order in which submitted tasks are</span></span><br><span class="line"><span class="comment"> * executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parallelism the targeted parallelism level</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parallelism &lt;= 0&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在WorkStealingPool实现中：</p><ul><li>parallelism &#x3D;&gt; Runtime.getRuntime().availableProcessors() - 这是JVM可用的处理器数。</li><li>handler &#x3D;&gt; ForkJoinPool.defaultForkJoinWorkerThreadFactory - 返回新线程的默认线程工厂。</li><li>asyncMode &#x3D;&gt; true – 使其在aysnc模式下工作，并为分叉的任务设置FIFO顺序，这些任务永远不会从其工作队列中加入。</li></ul><p><img src="/images/java_multithreading/chapter22/20200202171651883.png" alt="在这里插入图片描述"></p><h3 id="1-2-WorkStealingPool使用样例"><a href="#1-2-WorkStealingPool使用样例" class="headerlink" title="1.2 WorkStealingPool使用样例"></a>1.2 WorkStealingPool使用样例</h3><ol><li>单线程化线程池WorkStealingPool特点：<ul><li>WorkStealingPool是守护线程，使用ForkJoinPool实现的WorkStealingPool根据当前操作系统的CPU有几个核就会创建几个线程。</li><li>应用场景：WorkStealingPool能够合理的使用CPU进行对任务操作（并行操作）适合使用在很耗时的操作。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxw.chapter22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用WorkStealingPool工作窃取线程池，创建Callable类型的多线程，并最终返回结果</span></span><br><span class="line"><span class="comment"> * https://blog.csdn.net/yuan_xw/article/details/103730628</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkStealingPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获得JAVA虚拟机可用的最大CPU处理器数量：&quot;</span> + Runtime.getRuntime().availableProcessors());</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * call方法存在返回值futureTask的get方法可以获取这个返回值。</span></span><br><span class="line"><span class="comment">         * 使用此种方法实现线程的好处是当你创建的任务的结果不是立即就要时，</span></span><br><span class="line"><span class="comment">         * 你可以提交一个线程在后台执行，而你的程序仍可以正常运行下去，</span></span><br><span class="line"><span class="comment">         * 在需要执行结果时使用futureTask去获取即可。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Callable&lt;String&gt;&gt; callableList = IntStream.range(<span class="number">0</span>, <span class="number">20</span>).boxed().map(i -&gt; (Callable&lt;String&gt;) () -&gt; &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;当前【%s】线程正在执行&gt;&gt;&gt;&quot;</span>, Thread.currentThread().getName()));</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;callable type thread task：&quot;</span> + i;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行给定的任务，返回持有他们的状态和结果的所有完成的期待列表。</span></span><br><span class="line">        executorService.invokeAll(callableList).stream().map(futureTask-&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> futureTask.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">获得JAVA虚拟机可用的最大CPU处理器数量：8</span><br><span class="line">当前【ForkJoinPool-1-worker-0】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-6】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-1】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-3】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-5】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-7】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-2】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-4】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-1】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-3】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-2】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-5】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-6】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-0】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-7】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-4】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-1】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-2】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-5】线程正在执行&gt;&gt;&gt;</span><br><span class="line">当前【ForkJoinPool-1-worker-3】线程正在执行&gt;&gt;&gt;</span><br><span class="line">callable type thread task：0</span><br><span class="line">callable type thread task：1</span><br><span class="line">callable type thread task：2</span><br><span class="line">callable type thread task：3</span><br><span class="line">callable type thread task：4</span><br><span class="line">callable type thread task：5</span><br><span class="line">callable type thread task：6</span><br><span class="line">callable type thread task：7</span><br><span class="line">callable type thread task：8</span><br><span class="line">callable type thread task：9</span><br><span class="line">callable type thread task：10</span><br><span class="line">callable type thread task：11</span><br><span class="line">callable type thread task：12</span><br><span class="line">callable type thread task：13</span><br><span class="line">callable type thread task：14</span><br><span class="line">callable type thread task：15</span><br><span class="line">callable type thread task：16</span><br><span class="line">callable type thread task：17</span><br><span class="line">callable type thread task：18</span><br><span class="line">callable type thread task：19</span><br></pre></td></tr></table></figure><p> &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。<br>  <p align="right">——厚积薄发(yuanxw)</p></p>]]></content>
    
    
    <summary type="html">在Java 8中，引入了一种新型的线程池，作为newWorkStealingPool()来补充现有的线程池。WorkStealingPool线程池，来维持相应的并行级别，它会通过工作窃取的方式，使得多核的 CPU 不会闲置，总会有活着的线程让 CPU 去运行。</summary>
    
    
    
    <category term="Java多线程" scheme="https://yuanxw.github.io/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://yuanxw.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yuanxw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
