<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  
  
  <link href="https://yuanxw.github.io/atom.xml" rel="self"/>
  
  <link href="https://yuanxw.github.io/"/>
  <updated>2025-09-03T17:04:20.946Z</updated>
  <id>https://yuanxw.github.io/</id>
  
  <author>
    <name>Panda Yuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka源码分析(四)Producer生产者执行流程</title>
    <link href="https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)Producer%E7%94%9F%E4%BA%A7%E8%80%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)Producer%E7%94%9F%E4%BA%A7%E8%80%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2025-07-03T16:00:00.000Z</published>
    <updated>2025-09-03T17:04:20.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka源码分析-四-Producer生产者执行流程"><a href="#Kafka源码分析-四-Producer生产者执行流程" class="headerlink" title="Kafka源码分析(四)Producer生产者执行流程"></a>Kafka源码分析(四)Producer生产者执行流程</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><ul><li>代码的入口main方法中Producer类是一个多线程，在main中对producerThread进行start。表示开始了这个线程，Producer类中的run方法被获得被执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConsumerProducerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否是异步：如果参数个数为0，或者第一个参数不是&quot;sync&quot;，则是异步。生产环境一般是异步的数据处理。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAsync</span> <span class="operator">=</span> args.length == <span class="number">0</span> || !args[<span class="number">0</span>].trim().equalsIgnoreCase(<span class="string">&quot;sync&quot;</span>);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(KafkaProperties.TOPIC, isAsync);</span><br><span class="line">        producerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(KafkaProperties.TOPIC);</span><br><span class="line">        consumerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、Producer获取元数据流程图"><a href="#二、Producer获取元数据流程图" class="headerlink" title="二、Producer获取元数据流程图"></a>二、Producer获取元数据流程图</h2><ul><li>Producer流程图</li></ul><p><img src="/images/kafak_source/chapter4/image.png" alt="image.png"></p><ul><li><p>获取元素流程图</p><p>  <img src="/images/kafak_source/chapter4/image1.png" alt="image.png"></p></li><li><p>Broker和Partition关系图</p><p>  <img src="/images/kafak_source/chapter4/image2.png" alt="image.png"></p></li></ul><pre><code class="mermaid">sequenceDiagramautonumberProducer -&gt;&gt; Producer: run()方法Producer -&gt;&gt; KafkaProducer:send()KafkaProducer -&gt;&gt; KafkaProducer: 执行拦截器Note right of KafkaProducer : Producer唤醒sender线程等待元数据更新KafkaProducer -&gt;&gt; KafkaProducer: 从服务端获取metadata数据KafkaProducer -&gt;&gt; Metadata: 将topic添加到metadata列表，如果列表中不存在topic，则把属性needUpdate设置为：trueKafkaProducer -&gt;&gt; KafkaProducer: 从缓存中获取metadata数据，如果存在已经存在缓存的数据，直接返回流程结束  loop topic主题分区数量：partitionsCount      KafkaProducer -&gt;&gt; Metadata: 属性needUpdate设置为：true      KafkaProducer --&gt;&gt; Sender: 唤醒sender线程      KafkaProducer -&gt;&gt; Metadata: 等待元数据更新，直到当前版本大于我们所知道的最后一个版本，或者等待超时  end  loop Sender线程while true死循环Note right of NetworkClient: 获取并验证apiVersion版本：handleInitiateApiVersionRequests()] Sender -&gt;&gt; NetworkClient: 当Producer线程把needUpdate设置为true时，&lt;br&#x2F;&gt;说明需要更新metadata信息NetworkClient -&gt;&gt; NetworkClient: 第一次初始化网络连接：initiateConnectNetworkClient -&gt;&gt; NetworkClient: 网络连接已经完成后，注册版本添加一个write写的事件NetworkClient -&gt;&gt; NetworkClient : handleInitiateApiVersionRequests()处理apiVersion请求。NetworkClient -&gt;&gt; NetworkClient : 再次循环handleApiVersionsResponse()成功校验apiVersion版本，并修改连接状态为readyNote right of NetworkClient: 元数据获取NetworkClient -&gt;&gt; NetworkClient : 构建获取元数据请求参数sendInternalMetadataRequestNetworkClient -&gt;&gt; NetworkClient : 处理返回值handleCompletedMetadataResponse更新元素数据metadata对象，版本号+1NetworkClient --&gt;&gt; Producer: notifyAll，唤醒Producer主线程Sender -&gt;&gt; Sender: 获取已准备好发送数据的分区请求Sender -&gt;&gt; Sender: 判断节点有没有准备好，并移除没有准备的节点Sender -&gt;&gt; NetworkClient: 如果没有建立连接 -&gt; 初始化网络连接NetworkClient -&gt;&gt; Selector: 建立连接注册的OP_CONNECT事件Sender -&gt;&gt; Sender: 准备待发送请求的数据Sender -&gt;&gt; NetworkClient: 执行网络请求pollNetworkClient -&gt;&gt; NetworkClient: 封装要拉取元数据的请求NetworkClient -&gt;&gt; NetworkClient: 处理返回请求的操作，包括：&lt;br&#x2F;&gt;处理被中止的发送请求、&lt;br&#x2F;&gt;处理已完成的发送请求、&lt;br&#x2F;&gt;处理从Broker接收到的响应、&lt;br&#x2F;&gt;处理连接断开事件、&lt;br&#x2F;&gt;建立新连接、&lt;br&#x2F;&gt;处理API版本协商请求、&lt;br&#x2F;&gt;处理超时请求NetworkClient -&gt;&gt; NetworkClient: 执行回调函数endKafkaProducer -&gt;&gt; KafkaProducer: 对消息key和value进行序列化KafkaProducer -&gt;&gt; KafkaProducer: 根据分区策略获取消息发送的分区%% 默认分区策略（DefaultPartitioner.java）%% 获得topic的分区的数量%% 如果没有指定key，则生成一个随机数，正整数，然后取模获得分区号。%% 有指定key，把key的字节数组用hash算法生成一个整数，然后取模获得分区号。KafkaProducer -&gt;&gt; KafkaProducer: 获取序列化后的消息大小并验证大小是否超过默认1M限制KafkaProducer -&gt;&gt; KafkaProducer: 绑定拦截器和回调函数KafkaProducer -&gt;&gt; KafkaProducer: 消息添加到Accumulator中，Accumulator负责将消息分成多个批次，并将消息发送到Kafka集群KafkaProducer -&gt;&gt; KafkaProducer: 如果Accumulator中缓存的消息数量已满或已创建新的批次，则唤醒sender线程KafkaProducer -&gt;&gt; KafkaProducer: 返回RecordMetadataFuture，用于获取消息发送结果</code></pre><h2 id="三、源代码分析"><a href="#三、源代码分析" class="headerlink" title="三、源代码分析"></a>三、源代码分析</h2><ul><li><p>Producer 主线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaProducer&lt;Integer, String&gt; producer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Boolean isAsync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者构造函数</span></span><br><span class="line"><span class="comment">     * topic: 主题名称</span></span><br><span class="line"><span class="comment">     * isAsync: 是否异步发送</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isAsync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(String topic, Boolean isAsync)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 连接kafka集群地址，这里使用默认配置：localhost:9092</span></span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, KafkaProperties.KAFKA_SERVER_URL + <span class="string">&quot;:&quot;</span> + KafkaProperties.KAFKA_SERVER_PORT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// client.id: 客户端ID，用于标识当前生产者实例</span></span><br><span class="line">        props.put(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;DemoProducer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key.serializer: key序列化器，这里使用IntegerSerializer</span></span><br><span class="line">        <span class="comment">// value.serializer: value序列化器，这里使用StringSerializer</span></span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.IntegerSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// KafkaProducer实例化, 传入配置信息</span></span><br><span class="line">        producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line">        <span class="built_in">this</span>.topic = topic;</span><br><span class="line">        <span class="built_in">this</span>.isAsync = isAsync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">messageNo</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">messageStr</span> <span class="operator">=</span> <span class="string">&quot;Message_&quot;</span> + messageNo;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (isAsync) &#123; <span class="comment">// Send asynchronously</span></span><br><span class="line">                producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic,</span><br><span class="line">                    messageNo,</span><br><span class="line">                    messageStr), <span class="keyword">new</span> <span class="title class_">DemoCallBack</span>(startTime, messageNo, messageStr));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Send synchronously</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic,</span><br><span class="line">                        messageNo,</span><br><span class="line">                        messageStr)).get();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Sent message: (&quot;</span> + messageNo + <span class="string">&quot;, &quot;</span> + messageStr + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++messageNo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>KafkaProducer.send() 发送消息之前，先将消息拦截器拦截</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title function_">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> &#123;</span><br><span class="line">    <span class="comment">// 发送消息之前，先将消息拦截器拦截</span></span><br><span class="line">    <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="built_in">this</span>.interceptors == <span class="literal">null</span> ? record : <span class="built_in">this</span>.interceptors.onSend(record);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> doSend(interceptedRecord, callback);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>KafkaProducer.doSend() 发送消息</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title function_">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> &#123;</span><br><span class="line">    <span class="type">TopicPartition</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从服务端获取元数据：maxBlockTimeMs：最大阻塞时间，默认60s</span></span><br><span class="line">        <span class="type">ClusterAndWaitTime</span> <span class="variable">clusterAndWaitTime</span> <span class="operator">=</span> waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">        <span class="comment">// remainingWaitMs（剩余可用时间） = maxBlockTimeMs（最大阻塞时间） - clusterAndWaitTime.waitedOnMetadataMs(上次获取元数据耗时)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">remainingWaitMs</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">        <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> clusterAndWaitTime.cluster;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 对消息key和value进行序列化</span></span><br><span class="line">        <span class="type">byte</span>[] serializedKey;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serializedKey = keySerializer.serialize(record.topic(), record.key());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(<span class="string">&quot;Can&#x27;t convert key of class &quot;</span> + record.key().getClass().getName() +</span><br><span class="line">                    <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                    <span class="string">&quot; specified in key.serializer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] serializedValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serializedValue = valueSerializer.serialize(record.topic(), record.value());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(<span class="string">&quot;Can&#x27;t convert value of class &quot;</span> + record.value().getClass().getName() +</span><br><span class="line">                    <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                    <span class="string">&quot; specified in value.serializer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 根据分区策略获取消息发送的分区</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 获取序列化后的消息大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">serializedSize</span> <span class="operator">=</span> Records.LOG_OVERHEAD + Record.recordSize(serializedKey, serializedValue);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 验证消息大小是否超出限制，默认1M</span></span><br><span class="line">        ensureValidRecordSize(serializedSize);</span><br><span class="line">        tp = <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), partition);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> record.timestamp() == <span class="literal">null</span> ? time.milliseconds() : record.timestamp();</span><br><span class="line">        log.trace(<span class="string">&quot;Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;&quot;</span>, record, callback, record.topic(), partition);</span><br><span class="line">        <span class="comment">// producer callback will make sure to call both &#x27;callback&#x27; and interceptor callback</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 绑定拦截器和回调函数</span></span><br><span class="line">        <span class="type">Callback</span> <span class="variable">interceptCallback</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptors == <span class="literal">null</span> ? callback : <span class="keyword">new</span> <span class="title class_">InterceptorCallback</span>&lt;&gt;(callback, <span class="built_in">this</span>.interceptors, tp);</span><br><span class="line">        <span class="comment">// 消息添加到Accumulator中，Accumulator负责将消息分成多个批次，并将消息发送到Kafka集群</span></span><br><span class="line">        RecordAccumulator.<span class="type">RecordAppendResult</span> <span class="variable">result</span> <span class="operator">=</span> accumulator.append(tp, timestamp, serializedKey, serializedValue, interceptCallback, remainingWaitMs);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果Accumulator中缓存的消息数量已满或已创建新的批次，则唤醒sender线程</span></span><br><span class="line">        <span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch&quot;</span>, record.topic(), partition);</span><br><span class="line">            <span class="built_in">this</span>.sender.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回RecordMetadataFuture，用于获取消息发送结果</span></span><br><span class="line">        <span class="keyword">return</span> result.future;</span><br><span class="line">        <span class="comment">// handling exceptions and record the errors;</span></span><br><span class="line">        <span class="comment">// for API exceptions return them in the future,</span></span><br><span class="line">        <span class="comment">// for other exceptions throw directly</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ApiException e) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Exception occurred during message send:&quot;</span>, e);</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>)</span><br><span class="line">            callback.onCompletion(<span class="literal">null</span>, e);</span><br><span class="line">        <span class="built_in">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureFailure</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BufferExhaustedException e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.errors.record();</span><br><span class="line">        <span class="built_in">this</span>.metrics.sensor(<span class="string">&quot;buffer-exhausted-records&quot;</span>).record();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// we notify interceptor about all exceptions, since onSend is called before anything else in this method</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从服务端获取元数据<code>waitOnMetadata</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wait for cluster metadata including partitions for the given topic to be available.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic The topic we want metadata for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> partition A specific partition expected to exist in metadata, or null if there&#x27;s no preference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxWaitMs The maximum time in ms for waiting on the metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The cluster containing topic metadata and the amount of time we waited in ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ClusterAndWaitTime <span class="title function_">waitOnMetadata</span><span class="params">(String topic, Integer partition, <span class="type">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 将主题添加到元数据主题列表（如果尚不存在）并重置过期时间和needUpdate设置为true</span></span><br><span class="line">    metadata.add(topic);</span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> metadata.fetch();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">partitionsCount</span> <span class="operator">=</span> cluster.partitionCountForTopic(topic);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果我们有缓存的metadata数据，并且消息的分区未定义或在已知分区范围内，则返回缓存的metadata数据</span></span><br><span class="line">    <span class="keyword">if</span> (partitionsCount != <span class="literal">null</span> &amp;&amp; (partition == <span class="literal">null</span> || partition &lt; partitionsCount))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClusterAndWaitTime</span>(cluster, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> time.milliseconds();</span><br><span class="line">    <span class="comment">// 剩余可用时间，默认值为maxWaitMs，最多可以等待时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">remainingWaitMs</span> <span class="operator">=</span> maxWaitMs;</span><br><span class="line">    <span class="type">long</span> elapsed;</span><br><span class="line">    <span class="comment">// Issue metadata requests until we have metadata for the topic or maxWaitTimeMs is exceeded.</span></span><br><span class="line">    <span class="comment">// In case we already have cached metadata for the topic, but the requested partition is greater</span></span><br><span class="line">    <span class="comment">// than expected, issue an update request only once. This is necessary in case the metadata</span></span><br><span class="line">    <span class="comment">// is stale and the number of partitions for this topic has increased in the meantime.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Requesting metadata update for topic &#123;&#125;.&quot;</span>, topic);</span><br><span class="line">        <span class="comment">// needUpdate设置为true，返回更新前的当前版本</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> metadata.requestUpdate();</span><br><span class="line">        <span class="comment">// 唤醒sender线程</span></span><br><span class="line">        sender.wakeup();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            metadata.awaitUpdate(version, remainingWaitMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException ex) &#123;</span><br><span class="line">            <span class="comment">// Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>(<span class="string">&quot;Failed to update metadata after &quot;</span> + maxWaitMs + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次获取集群的元数据信息</span></span><br><span class="line">        cluster = metadata.fetch();</span><br><span class="line">        <span class="comment">// 计算拉取metadata数据耗时</span></span><br><span class="line">        elapsed = time.milliseconds() - begin;</span><br><span class="line">        <span class="comment">// 如果拉取metadata数据耗时超过了最大阻塞时间，则抛出超时异常</span></span><br><span class="line">        <span class="keyword">if</span> (elapsed &gt;= maxWaitMs)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>(<span class="string">&quot;Failed to update metadata after &quot;</span> + maxWaitMs + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果获取到metadata数据，topic没有授权，则抛出TopicAuthorizationException</span></span><br><span class="line">        <span class="keyword">if</span> (cluster.unauthorizedTopics().contains(topic))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TopicAuthorizationException</span>(topic);</span><br><span class="line">        <span class="comment">// 计算剩余可用时间</span></span><br><span class="line">        remainingWaitMs = maxWaitMs - elapsed;</span><br><span class="line">        <span class="comment">// 如果topic的分区数量未知，则继续等待</span></span><br><span class="line">        partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">    &#125; <span class="keyword">while</span> (partitionsCount == <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (partition != <span class="literal">null</span> &amp;&amp; partition &gt;= partitionsCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KafkaException</span>(</span><br><span class="line">                String.format(<span class="string">&quot;Invalid partition given with record: %d is not in the range [0...%d).&quot;</span>, partition, partitionsCount));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回集群元数据和耗时时间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClusterAndWaitTime</span>(cluster, elapsed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Sender线程在run()方法死循环</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run a single iteration of sending</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now</span></span><br><span class="line"><span class="comment"> *            The current POSIX time in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前集群metadata信息</span></span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> metadata.fetch();</span><br><span class="line">    <span class="comment">// 获取已准备好发送数据的分区请求</span></span><br><span class="line">    RecordAccumulator.<span class="type">ReadyCheckResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.accumulator.ready(cluster, now);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有任何分区的 leader 尚不清楚，则强制元数据更新。第一次执行topic，不会走</span></span><br><span class="line">    <span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// The set of topics with unknown leader contains topics with leader election pending as well as</span></span><br><span class="line">        <span class="comment">// topics which may have expired. Add the topic again to metadata to ensure it is included</span></span><br><span class="line">        <span class="comment">// and request metadata update, since there are messages to send to the topic.</span></span><br><span class="line">        <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</span><br><span class="line">            <span class="built_in">this</span>.metadata.add(topic);</span><br><span class="line">        <span class="built_in">this</span>.metadata.requestUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断节点有没有准备好，并移除没有准备的节点</span></span><br><span class="line">    <span class="comment">// remove any nodes we aren&#x27;t ready to send to</span></span><br><span class="line">    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</span><br><span class="line">    <span class="type">long</span> <span class="variable">notReadyTimeout</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">            iter.remove();</span><br><span class="line">            notReadyTimeout = Math.min(notReadyTimeout, <span class="built_in">this</span>.client.connectionDelay(node, now));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建批次请求</span></span><br><span class="line">    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="built_in">this</span>.accumulator.drain(cluster,</span><br><span class="line">                                                                     result.readyNodes,</span><br><span class="line">                                                                     <span class="built_in">this</span>.maxRequestSize,</span><br><span class="line">                                                                     now);</span><br><span class="line">    <span class="comment">// 保证消息顺序，第一次执行guaranteeMessageOrder为false，不会走</span></span><br><span class="line">    <span class="keyword">if</span> (guaranteeMessageOrder) &#123;</span><br><span class="line">        <span class="comment">// Mute all the partitions drained</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (RecordBatch batch : batchList)</span><br><span class="line">                <span class="built_in">this</span>.accumulator.mutePartition(batch.topicPartition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查超时的批次，第一次执行没expiredBatches为空</span></span><br><span class="line">    List&lt;RecordBatch&gt; expiredBatches = <span class="built_in">this</span>.accumulator.abortExpiredBatches(<span class="built_in">this</span>.requestTimeout, now);</span><br><span class="line">    <span class="comment">// 更新超时批次的错误计数</span></span><br><span class="line">    <span class="keyword">for</span> (RecordBatch expiredBatch : expiredBatches)</span><br><span class="line">        <span class="built_in">this</span>.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);</span><br><span class="line">    </span><br><span class="line">    sensors.updateProduceRequestMetrics(batches);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If we have any nodes that are ready to send + have sendable data, poll with 0 timeout so this can immediately</span></span><br><span class="line">    <span class="comment">// loop and try sending more data. Otherwise, the timeout is determined by nodes that have partitions with data</span></span><br><span class="line">    <span class="comment">// that isn&#x27;t yet sendable (e.g. lingering, backing off). Note that this specifically does not include nodes</span></span><br><span class="line">    <span class="comment">// with sendable data that aren&#x27;t ready to send since they would cause busy looping.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">pollTimeout</span> <span class="operator">=</span> Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</span><br><span class="line">    <span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Nodes with data ready to send: &#123;&#125;&quot;</span>, result.readyNodes);</span><br><span class="line">        <span class="comment">// 如果有已经准备好的节点，超时间隔为0，立即发送请求</span></span><br><span class="line">        pollTimeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备待发送请求的数据</span></span><br><span class="line">    sendProduceRequests(batches, now);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行网络请求</span></span><br><span class="line">    <span class="comment">// if some partitions are already ready to be sent, the select time would be 0;</span></span><br><span class="line">    <span class="comment">// otherwise if some partition already has some data accumulated but not ready yet,</span></span><br><span class="line">    <span class="comment">// the select time will be the time difference between now and its linger expiry time;</span></span><br><span class="line">    <span class="comment">// otherwise the select time will be the time difference between now and the metadata expiry time;</span></span><br><span class="line">    <span class="built_in">this</span>.client.poll(pollTimeout, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取已准备好发送数据的分区请求ready</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReadyCheckResult <span class="title function_">ready</span><span class="params">(Cluster cluster, <span class="type">long</span> nowMs)</span> &#123;</span><br><span class="line">    Set&lt;Node&gt; readyNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nextReadyCheckDelayMs</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    Set&lt;String&gt; unknownLeaderTopics = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存已经耗尽，并且线程阻塞等待buffer，则所有partition都可以发送</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exhausted</span> <span class="operator">=</span> <span class="built_in">this</span>.free.queued() &gt; <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有队列，获取每个partition的leader节点，如果leader节点不存在，则说明该partition的leader节点未知，</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; entry : <span class="built_in">this</span>.batches.entrySet()) &#123;</span><br><span class="line">        <span class="type">TopicPartition</span> <span class="variable">part</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        Deque&lt;RecordBatch&gt; deque = entry.getValue();</span><br><span class="line">    </span><br><span class="line">        <span class="type">Node</span> <span class="variable">leader</span> <span class="operator">=</span> cluster.leaderFor(part);</span><br><span class="line">        <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="literal">null</span> &amp;&amp; !deque.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// This is a partition for which leader is not known, but messages are available to send.</span></span><br><span class="line">                <span class="comment">// Note that entries are currently not removed from batches when deque is empty.</span></span><br><span class="line">                unknownLeaderTopics.add(part.topic());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!readyNodes.contains(leader) &amp;&amp; !muted.contains(part)) &#123;</span><br><span class="line">                <span class="comment">// 从队列头部获取第一个批次，如果批不为null，则判断是否可以发送，如果可以发送，则添加到readyNodes集合中</span></span><br><span class="line">                <span class="type">RecordBatch</span> <span class="variable">batch</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line">                <span class="keyword">if</span> (batch != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * batch.attempts重试的次数</span></span><br><span class="line"><span class="comment">                     * batch.lastAttemptMs上次重试的时间</span></span><br><span class="line"><span class="comment">                     * batch.retryBackoffMs重试的间隔时间</span></span><br><span class="line"><span class="comment">                     * nowMs当前时间</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">backingOff</span> <span class="operator">=</span> batch.attempts &gt; <span class="number">0</span> &amp;&amp; batch.lastAttemptMs + retryBackoffMs &gt; nowMs;</span><br><span class="line">                    <span class="comment">// waitedTimeMs（已经等待的时间） = nowMs当前时间 - batch.lastAttemptMs上次重试的时间</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">waitedTimeMs</span> <span class="operator">=</span> nowMs - batch.lastAttemptMs;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// timeToWaitMs最多等待的时间 = backingOff是否处于重试状态？重试间隔时间：lingerMs等待时间，默认为：0</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">timeToWaitMs</span> <span class="operator">=</span> backingOff ? retryBackoffMs : lingerMs;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// timeLeftMs剩余等待的时间 = timeToWaitMs（最多等待的时间） - waitedTimeMs（已经等待的时间）</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">timeLeftMs</span> <span class="operator">=</span> Math.max(timeToWaitMs - waitedTimeMs, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">//full是否已满 = 队列中有多个批次 || 当前批次已满</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">full</span> <span class="operator">=</span> deque.size() &gt; <span class="number">1</span> || batch.isFull();</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// expired是否已过期 = waitedTimeMs（已经等待的时间） &gt;= timeToWaitMs（最多等待的时间）</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">expired</span> <span class="operator">=</span> waitedTimeMs &gt;= timeToWaitMs;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// sendable是否可以发送 = 队列中有多个批次或者当前批次已满 || 等待时间已过 || 内存耗尽 || 关闭 || 正在flush</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">sendable</span> <span class="operator">=</span> full || expired || exhausted || closed || flushInProgress();</span><br><span class="line">                    <span class="keyword">if</span> (sendable &amp;&amp; !backingOff) &#123;</span><br><span class="line">                        readyNodes.add(leader);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Note that this results in a conservative estimate since an un-sendable partition may have</span></span><br><span class="line">                        <span class="comment">// a leader that will later be found to have sendable data. However, this is good enough</span></span><br><span class="line">                        <span class="comment">// since we&#x27;ll just wake up and then sleep again for the remaining time.</span></span><br><span class="line">                        nextReadyCheckDelayMs = Math.min(timeLeftMs, nextReadyCheckDelayMs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReadyCheckResult</span>(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断节点有没有准备好，并移除没有准备的节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 判断节点有没有准备好，并移除没有准备的节点</span></span><br><span class="line">    <span class="comment">// remove any nodes we aren&#x27;t ready to send to</span></span><br><span class="line">    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</span><br><span class="line">    <span class="type">long</span> <span class="variable">notReadyTimeout</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">            iter.remove();</span><br><span class="line">            notReadyTimeout = Math.min(notReadyTimeout, <span class="built_in">this</span>.client.connectionDelay(node, now));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Begin connecting to the given node, return true if we are already connected and ready to send to that node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node The node to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now The current timestamp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if we are ready to send to the given node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">ready</span><span class="params">(Node node, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot connect to empty node &quot;</span> + node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isReady(node, now))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (connectionStates.canConnect(node.idString(), now))</span><br><span class="line">        <span class="comment">// 初始化网络连接</span></span><br><span class="line">        initiateConnect(node, now);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化连接，如果连接失败，则会尝试重试。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initiateConnect</span><span class="params">(Node node, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">nodeConnectionId</span> <span class="operator">=</span> node.idString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Initiating connection to node &#123;&#125; at &#123;&#125;:&#123;&#125;.&quot;</span>, node.id(), node.host(), node.port());</span><br><span class="line">        <span class="comment">// 修改状态为正在连接</span></span><br><span class="line">        <span class="built_in">this</span>.connectionStates.connecting(nodeConnectionId, now);</span><br><span class="line">        <span class="comment">// 尝试连接</span></span><br><span class="line">        selector.connect(nodeConnectionId,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(node.host(), node.port()),</span><br><span class="line">                         <span class="built_in">this</span>.socketSendBuffer,</span><br><span class="line">                         <span class="built_in">this</span>.socketReceiveBuffer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">/* attempt failed, we&#x27;ll try again after the backoff */</span></span><br><span class="line">        connectionStates.disconnected(nodeConnectionId, now);</span><br><span class="line">        <span class="comment">/* maybe the problem is our metadata, update it */</span></span><br><span class="line">        metadataUpdater.requestUpdate();</span><br><span class="line">        log.debug(<span class="string">&quot;Error connecting to node &#123;&#125; at &#123;&#125;:&#123;&#125;:&quot;</span>, node.id(), node.host(), node.port(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String id, InetSocketAddress address, <span class="type">int</span> sendBufferSize, <span class="type">int</span> receiveBufferSize)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channels.containsKey(id))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;There is already a connection for id &quot;</span> + id);</span><br><span class="line">    <span class="comment">// 获取SocketChannel.open()</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">    <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 获取socket</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> socketChannel.socket();</span><br><span class="line">    socket.setKeepAlive(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置发送缓冲区大小、接收缓冲区大小</span></span><br><span class="line">    <span class="keyword">if</span> (sendBufferSize != Selectable.USE_DEFAULT_BUFFER_SIZE)</span><br><span class="line">        socket.setSendBufferSize(sendBufferSize);</span><br><span class="line">    <span class="keyword">if</span> (receiveBufferSize != Selectable.USE_DEFAULT_BUFFER_SIZE)</span><br><span class="line">        socket.setReceiveBufferSize(receiveBufferSize);</span><br><span class="line">    <span class="comment">// 设置TcpNoDelay属性为true，用于控制 TCP 连接中数据包的发送方式。</span></span><br><span class="line">    <span class="comment">// 默认情况下，TCP 使用 Nagle 算法 来减少网络中的小数据包数量，从而提高网络利用率。</span></span><br><span class="line">    <span class="comment">// 然而，这种方式可能会增加延迟，特别是在需要快速响应的应用中</span></span><br><span class="line">    socket.setTcpNoDelay(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">boolean</span> connected;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试连接服务器，有可能连接成功：true，也有可能连接失败:false</span></span><br><span class="line">        connected = socketChannel.connect(address);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnresolvedAddressException e) &#123;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Can&#x27;t resolve address: &quot;</span> + address, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SocketChannel.register()注册到Selector，并设置OP_CONNECT事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> socketChannel.register(nioSelector, SelectionKey.OP_CONNECT);</span><br><span class="line">    KafkaChannel channel;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据SocketChannel创建KafkaChannel</span></span><br><span class="line">        channel = channelBuilder.buildChannel(id, key, maxReceiveSize);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            key.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Channel could not be created for socket &quot;</span> + socketChannel, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把key和channel绑定，并设置附件为channel</span></span><br><span class="line">    key.attach(channel);</span><br><span class="line">    <span class="comment">// 缓存channel</span></span><br><span class="line">    <span class="built_in">this</span>.channels.put(id, channel);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (connected) &#123;</span><br><span class="line">        <span class="comment">// OP_CONNECT won&#x27;t trigger for immediately connected channels</span></span><br><span class="line">        log.debug(<span class="string">&quot;Immediately connected to node &#123;&#125;&quot;</span>, channel.id());</span><br><span class="line">        immediatelyConnectedKeys.add(key);</span><br><span class="line">        <span class="comment">// 取消前面注册的OP_CONNECT事件</span></span><br><span class="line">        key.interestOps(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建批次请求</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建批次请求</span></span><br><span class="line">Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="built_in">this</span>.accumulator.drain(cluster,</span><br><span class="line">                                                                 result.readyNodes,</span><br><span class="line">                                                                 <span class="built_in">this</span>.maxRequestSize,</span><br><span class="line">                                                                 now);</span><br><span class="line">                                                                     </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现按照NodeId进行分组，把相同NodeId的batch分到一组中，返回Map&lt;NodeId, List&lt;RecordBatch&gt;&gt;</span></span><br><span class="line"><span class="comment"> * Drain all the data for the given nodes and collate them into a list of batches that will fit within the specified</span></span><br><span class="line"><span class="comment"> * size on a per-node basis. This method attempts to avoid choosing the same topic-node over and over.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cluster The current cluster metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes The list of node to drain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxSize The maximum number of bytes to drain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now The current unix time in milliseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A list of &#123;<span class="doctag">@link</span> RecordBatch&#125; for each node specified with total size less than the requested maxSize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, List&lt;RecordBatch&gt;&gt; <span class="title function_">drain</span><span class="params">(Cluster cluster,</span></span><br><span class="line"><span class="params">                                             Set&lt;Node&gt; nodes,</span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> maxSize,</span></span><br><span class="line"><span class="params">                                             <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    </span><br><span class="line">    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;PartitionInfo&gt; parts = cluster.partitionsForNode(node.id());</span><br><span class="line">        List&lt;RecordBatch&gt; ready = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/* to make starvation less likely this loop doesn&#x27;t start at 0 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> drainIndex = drainIndex % parts.size();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">PartitionInfo</span> <span class="variable">part</span> <span class="operator">=</span> parts.get(drainIndex);</span><br><span class="line">            <span class="type">TopicPartition</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(part.topic(), part.partition());</span><br><span class="line">            <span class="comment">// Only proceed if the partition has no in-flight batches.</span></span><br><span class="line">            <span class="keyword">if</span> (!muted.contains(tp)) &#123;</span><br><span class="line">                Deque&lt;RecordBatch&gt; deque = getDeque(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(part.topic(), part.partition()));</span><br><span class="line">                <span class="keyword">if</span> (deque != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">                        <span class="type">RecordBatch</span> <span class="variable">first</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line">                        <span class="keyword">if</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">backoff</span> <span class="operator">=</span> first.attempts &gt; <span class="number">0</span> &amp;&amp; first.lastAttemptMs + retryBackoffMs &gt; now;</span><br><span class="line">                            <span class="comment">// Only drain the batch if it is not during backoff period.</span></span><br><span class="line">                            <span class="keyword">if</span> (!backoff) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (size + first.sizeInBytes() &gt; maxSize &amp;&amp; !ready.isEmpty()) &#123;</span><br><span class="line">                                    <span class="comment">// there is a rare case that a single batch size is larger than the request size due</span></span><br><span class="line">                                    <span class="comment">// to compression; in this case we will still eventually send this batch in a single</span></span><br><span class="line">                                    <span class="comment">// request</span></span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="type">RecordBatch</span> <span class="variable">batch</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">                                    batch.close();</span><br><span class="line">                                    size += batch.sizeInBytes();</span><br><span class="line">                                    ready.add(batch);</span><br><span class="line">                                    batch.drainedMs = now;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.drainIndex = (<span class="built_in">this</span>.drainIndex + <span class="number">1</span>) % parts.size();</span><br><span class="line">        &#125; <span class="keyword">while</span> (start != drainIndex);</span><br><span class="line">        batches.put(node.id(), ready);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> batches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行网络请求</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do actual reads and writes to sockets.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout The maximum amount of time to wait (in ms) for responses if there are none immediately,</span></span><br><span class="line"><span class="comment"> *                must be non-negative. The actual timeout will be the minimum of timeout, request timeout and</span></span><br><span class="line"><span class="comment"> *                metadata timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now The current time in milliseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The list of responses received</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">// 封装要拉取元数据的请求</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">metadataTimeout</span> <span class="operator">=</span> metadataUpdater.maybeUpdate(now);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error during I/O&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理已完成请求的操作</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">updatedNow</span> <span class="operator">=</span> <span class="built_in">this</span>.time.milliseconds();</span><br><span class="line">    List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    handleAbortedSends(responses);</span><br><span class="line">    handleCompletedSends(responses, updatedNow);</span><br><span class="line">    handleCompletedReceives(responses, updatedNow);</span><br><span class="line">    handleDisconnections(responses, updatedNow);</span><br><span class="line">    handleConnections();</span><br><span class="line">    handleInitiateApiVersionRequests(updatedNow);</span><br><span class="line">    handleTimedOutRequests(responses, updatedNow);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// invoke callbacks</span></span><br><span class="line">    <span class="keyword">for</span> (ClientResponse response : responses) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.onComplete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Uncaught error in request completion:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更新元数据信息</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maybeUpdate</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">     <span class="comment">// 是否要更新metadata信息，当Producer线程把needUpdate设置为true时，说明需要更新metadata信息</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">timeToNextMetadataUpdate</span> <span class="operator">=</span> metadata.timeToNextUpdate(now);</span><br><span class="line">     <span class="type">long</span> <span class="variable">waitForMetadataFetch</span> <span class="operator">=</span> <span class="built_in">this</span>.metadataFetchInProgress ? requestTimeoutMs : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="type">long</span> <span class="variable">metadataTimeout</span> <span class="operator">=</span> Math.max(timeToNextMetadataUpdate, waitForMetadataFetch);</span><br><span class="line">     <span class="keyword">if</span> (metadataTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> metadataTimeout;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// Beware that the behavior of this method and the computation of timeouts for poll() are</span></span><br><span class="line">     <span class="comment">// highly dependent on the behavior of leastLoadedNode.</span></span><br><span class="line">     <span class="comment">// 获取请求最少的Node节点</span></span><br><span class="line">     <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> leastLoadedNode(now);</span><br><span class="line">     <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;Give up sending metadata request since no node is available&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> maybeUpdate(now, node);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Add a metadata request to the list of sends if we can make one</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">maybeUpdate</span><span class="params">(<span class="type">long</span> now, Node node)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">nodeConnectionId</span> <span class="operator">=</span> node.idString();</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span> (canSendRequest(nodeConnectionId)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.metadataFetchInProgress = <span class="literal">true</span>;</span><br><span class="line">         MetadataRequest.Builder metadataRequest;</span><br><span class="line">         <span class="keyword">if</span> (metadata.needMetadataForAllTopics())</span><br><span class="line">             metadataRequest = MetadataRequest.Builder.allTopics();</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             metadataRequest = <span class="keyword">new</span> <span class="title class_">MetadataRequest</span>.Builder(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(metadata.topics()));</span><br><span class="line">    </span><br><span class="line">         log.debug(<span class="string">&quot;Sending metadata request &#123;&#125; to node &#123;&#125;&quot;</span>, metadataRequest, node.id());</span><br><span class="line">         sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now);</span><br><span class="line">         <span class="keyword">return</span> requestTimeoutMs;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// If there&#x27;s any connection establishment underway, wait until it completes. This prevents</span></span><br><span class="line">     <span class="comment">// the client from unnecessarily connecting to additional nodes while a previous connection</span></span><br><span class="line">     <span class="comment">// attempt has not been completed.</span></span><br><span class="line">     <span class="keyword">if</span> (isAnyNodeConnecting()) &#123;</span><br><span class="line">         <span class="comment">// Strictly the timeout we should return here is &quot;connect timeout&quot;, but as we don&#x27;t</span></span><br><span class="line">         <span class="comment">// have such application level configuration, using reconnect backoff instead.</span></span><br><span class="line">         <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span> (connectionStates.canConnect(nodeConnectionId, now)) &#123;</span><br><span class="line">         <span class="comment">// we don&#x27;t have a connection to this node right now, make one</span></span><br><span class="line">         log.debug(<span class="string">&quot;Initialize connection to node &#123;&#125; for sending metadata request&quot;</span>, node.id());</span><br><span class="line">         initiateConnect(node, now);</span><br><span class="line">         <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// connected, but can&#x27;t send more OR connecting</span></span><br><span class="line">     <span class="comment">// In either case, we just need to wait for a network event to let us know the selected</span></span><br><span class="line">     <span class="comment">// connection might be usable again.</span></span><br><span class="line">     <span class="keyword">return</span> Long.MAX_VALUE;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>发送Meatadata元数据请求</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendInternalMetadataRequest</span><span class="params">(MetadataRequest.Builder builder,</span></span><br><span class="line"><span class="params">                                          String nodeConnectionId, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">     <span class="type">ClientRequest</span> <span class="variable">clientRequest</span> <span class="operator">=</span> newClientRequest(nodeConnectionId, builder, now, <span class="literal">true</span>);</span><br><span class="line">     doSend(clientRequest, <span class="literal">true</span>, now);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSend</span><span class="params">(ClientRequest clientRequest, <span class="type">boolean</span> isInternalRequest, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">nodeId</span> <span class="operator">=</span> clientRequest.destination();</span><br><span class="line">     <span class="keyword">if</span> (!isInternalRequest) &#123;</span><br><span class="line">         <span class="comment">// If this request came from outside the NetworkClient, validate</span></span><br><span class="line">         <span class="comment">// that we can send data.  If the request is internal, we trust</span></span><br><span class="line">         <span class="comment">// that that internal code has done this validation.  Validation</span></span><br><span class="line">         <span class="comment">// will be slightly different for some internal requests (for</span></span><br><span class="line">         <span class="comment">// example, ApiVersionsRequests can be sent prior to being in</span></span><br><span class="line">         <span class="comment">// READY state.)</span></span><br><span class="line">         <span class="keyword">if</span> (!canSendRequest(nodeId))</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Attempt to send a request to node &quot;</span> + nodeId + <span class="string">&quot; which is not ready.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">AbstractRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     AbstractRequest.Builder&lt;?&gt; builder = clientRequest.requestBuilder();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">NodeApiVersions</span> <span class="variable">versionInfo</span> <span class="operator">=</span> nodeApiVersions.get(nodeId);</span><br><span class="line">         <span class="comment">// Note: if versionInfo is null, we have no server version information. This would be</span></span><br><span class="line">         <span class="comment">// the case when sending the initial ApiVersionRequest which fetches the version</span></span><br><span class="line">         <span class="comment">// information itself.  It is also the case when discoverBrokerVersions is set to false.</span></span><br><span class="line">         <span class="keyword">if</span> (versionInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (discoverBrokerVersions &amp;&amp; log.isTraceEnabled())</span><br><span class="line">                 log.trace(<span class="string">&quot;No version information found when sending message of type &#123;&#125; to node &#123;&#125;. &quot;</span> +</span><br><span class="line">                         <span class="string">&quot;Assuming version &#123;&#125;.&quot;</span>, clientRequest.apiKey(), nodeId, builder.version());</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="type">short</span> <span class="variable">version</span> <span class="operator">=</span> versionInfo.usableVersion(clientRequest.apiKey());</span><br><span class="line">             builder.setVersion(version);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// The call to build may also throw UnsupportedVersionException, if there are essential</span></span><br><span class="line">         <span class="comment">// fields that cannot be represented in the chosen version.</span></span><br><span class="line">         request = builder.build();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (UnsupportedVersionException e) &#123;</span><br><span class="line">         <span class="comment">// If the version is not supported, skip sending the request over the wire.</span></span><br><span class="line">         <span class="comment">// Instead, simply add it to the local queue of aborted requests.</span></span><br><span class="line">         log.debug(<span class="string">&quot;Version mismatch when attempting to send &#123;&#125; to &#123;&#125;&quot;</span>,</span><br><span class="line">                 clientRequest.toString(), clientRequest.destination(), e);</span><br><span class="line">         <span class="type">ClientResponse</span> <span class="variable">clientResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientResponse</span>(clientRequest.makeHeader(),</span><br><span class="line">                 clientRequest.callback(), clientRequest.destination(), now, now,</span><br><span class="line">                 <span class="literal">false</span>, e, <span class="literal">null</span>);</span><br><span class="line">         abortedSends.add(clientResponse);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">RequestHeader</span> <span class="variable">header</span> <span class="operator">=</span> clientRequest.makeHeader();</span><br><span class="line">     <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">latestClientVersion</span> <span class="operator">=</span> ProtoUtils.latestVersion(clientRequest.apiKey().id);</span><br><span class="line">         <span class="keyword">if</span> (header.apiVersion() == latestClientVersion) &#123;</span><br><span class="line">             log.trace(<span class="string">&quot;Sending &#123;&#125; to node &#123;&#125;.&quot;</span>, request, nodeId);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;Using older server API v&#123;&#125; to send &#123;&#125; to node &#123;&#125;.&quot;</span>,</span><br><span class="line">                 header.apiVersion(), request, nodeId);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Send</span> <span class="variable">send</span> <span class="operator">=</span> request.toSend(nodeId, header);</span><br><span class="line">     <span class="type">InFlightRequest</span> <span class="variable">inFlightRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InFlightRequest</span>(</span><br><span class="line">             header,</span><br><span class="line">             clientRequest.createdTimeMs(),</span><br><span class="line">             clientRequest.destination(),</span><br><span class="line">             clientRequest.callback(),</span><br><span class="line">             clientRequest.expectResponse(),</span><br><span class="line">             isInternalRequest,</span><br><span class="line">             send,</span><br><span class="line">             now);</span><br><span class="line">     <span class="built_in">this</span>.inFlightRequests.add(inFlightRequest);</span><br><span class="line">     selector.send(inFlightRequest.send);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Queue the given request for sending in the subsequent &#123;<span class="doctag">@link</span> #poll(long)&#125; calls</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> send The request to send</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Send send)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">connectionId</span> <span class="operator">=</span> send.destination();</span><br><span class="line">     <span class="keyword">if</span> (closingChannels.containsKey(connectionId))</span><br><span class="line">         <span class="built_in">this</span>.failedSends.add(connectionId);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="type">KafkaChannel</span> <span class="variable">channel</span> <span class="operator">=</span> channelOrFail(connectionId, <span class="literal">false</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             channel.setSend(send);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">             <span class="built_in">this</span>.failedSends.add(connectionId);</span><br><span class="line">             close(channel, <span class="literal">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSend</span><span class="params">(Send send)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">this</span>.send != <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Attempt to begin a send operation with prior send operation still in progress.&quot;</span>);</span><br><span class="line">     <span class="built_in">this</span>.send = send;</span><br><span class="line">     <span class="built_in">this</span>.transportLayer.addInterestOps(SelectionKey.OP_WRITE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">代码的入口main方法中Producer类是一个多线程，在main中对producerThread进行start。表示开始了这个线程，Producer类中的run方法被获得被执行。</summary>
    
    
    
    <category term="Kafka" scheme="https://yuanxw.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://yuanxw.github.io/tags/Kafka/"/>
    
    <category term="Kafka源码分析" scheme="https://yuanxw.github.io/tags/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Kafka源码分析(三)Sender线程获取metadata数据</title>
    <link href="https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)Sender%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96metadata%E6%95%B0%E6%8D%AE/"/>
    <id>https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)Sender%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96metadata%E6%95%B0%E6%8D%AE/</id>
    <published>2025-07-02T16:00:00.000Z</published>
    <updated>2025-09-03T17:04:00.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka源码分析-三-Sender线程获取metadata数据"><a href="#Kafka源码分析-三-Sender线程获取metadata数据" class="headerlink" title="Kafka源码分析(三)Sender线程获取metadata数据"></a>Kafka源码分析(三)Sender线程获取metadata数据</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><ul><li>前面<code>KafkaProducer</code> 类里面开启sender线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">KafkaProducer</span><span class="params">(ProducerConfig config, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer)</span> &#123;</span><br><span class="line"><span class="comment">// .....省略....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动Kafka网络线程</span></span><br><span class="line"><span class="built_in">this</span>.ioThread = <span class="keyword">new</span> <span class="title class_">KafkaThread</span>(ioThreadName, <span class="built_in">this</span>.sender, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">this</span>.ioThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .....省略....</span></span><br></pre></td></tr></table></figure><h2 id="二、Sender线程执行流程图"><a href="#二、Sender线程执行流程图" class="headerlink" title="二、Sender线程执行流程图"></a>二、Sender线程执行流程图</h2><pre><code class="mermaid">sequenceDiagramautonumberKafkaProducer -&gt;&gt; Sender: ioThread.start()Sender-&gt;&gt;Sender: run()多线程方法loop while (running)[死循环]    Sender-&gt;&gt;Sender: 获取当前集群metadata信息 metadata.fetch();    Sender-&gt;&gt;Sender: 获取已准备好发送数据的分区请求    Sender-&gt;&gt;Sender: 创建批次请求this.accumulator.drain    Sender-&gt;&gt;Sender: 保证消息顺序，guaranteeMessageOrder：false    Sender-&gt;&gt;Sender: 准备待发送请求的数据，sendProduceRequests(batches, now);    Sender-&gt;&gt;NetworkClient: this.client.poll(pollTimeout, now);    NetworkClient-&gt;&gt; NetworkClient: 封装要拉取元数据的请求metadataUpdater.maybeUpdate(now);    NetworkClient-&gt;&gt; Selector: 阻塞等待，直到有可用连接或超时select(timeout);end</code></pre><h2 id="三、源代码分析"><a href="#三、源代码分析" class="headerlink" title="三、源代码分析"></a>三、源代码分析</h2><ul><li>Sender线程的run方法被执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * producer线程的主 run 循环</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     log.debug(<span class="string">&quot;Starting Kafka producer I/O thread.&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// main 循环，一直运行直到调用 close</span></span><br><span class="line">     <span class="keyword">while</span> (running) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             run(time.milliseconds());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             log.error(<span class="string">&quot;Uncaught error in kafka producer I/O thread: &quot;</span>, e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     log.debug(<span class="string">&quot;Beginning shutdown of Kafka producer I/O thread, sending remaining records.&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// okay we stopped accepting requests but there may still be</span></span><br><span class="line">     <span class="comment">// requests in the accumulator or waiting for acknowledgment,</span></span><br><span class="line">     <span class="comment">// wait until these are completed.</span></span><br><span class="line">     <span class="keyword">while</span> (!forceClose &amp;&amp; (<span class="built_in">this</span>.accumulator.hasUnsent() || <span class="built_in">this</span>.client.inFlightRequestCount() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             run(time.milliseconds());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             log.error(<span class="string">&quot;Uncaught error in kafka producer I/O thread: &quot;</span>, e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (forceClose) &#123;</span><br><span class="line">         <span class="comment">// We need to fail all the incomplete batches and wake up the threads waiting on</span></span><br><span class="line">         <span class="comment">// the futures.</span></span><br><span class="line">         <span class="built_in">this</span>.accumulator.abortIncompleteBatches();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.client.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;Failed to close network client&quot;</span>, e);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     log.debug(<span class="string">&quot;Shutdown of Kafka producer I/O thread has completed.&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run a single iteration of sending</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now</span></span><br><span class="line"><span class="comment"> *            The current POSIX time in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前集群metadata信息</span></span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> metadata.fetch();</span><br><span class="line">    <span class="comment">// 获取已准备好发送数据的节点</span></span><br><span class="line">    RecordAccumulator.<span class="type">ReadyCheckResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.accumulator.ready(cluster, now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有任何分区的 leader 尚不清楚，则强制元数据更新。第一次执行topic，不会走</span></span><br><span class="line">    <span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// The set of topics with unknown leader contains topics with leader election pending as well as</span></span><br><span class="line">        <span class="comment">// topics which may have expired. Add the topic again to metadata to ensure it is included</span></span><br><span class="line">        <span class="comment">// and request metadata update, since there are messages to send to the topic.</span></span><br><span class="line">        <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</span><br><span class="line">            <span class="built_in">this</span>.metadata.add(topic);</span><br><span class="line">        <span class="built_in">this</span>.metadata.requestUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断节点有没有准备好，并移除没有准备的节点</span></span><br><span class="line">    <span class="comment">// remove any nodes we aren&#x27;t ready to send to</span></span><br><span class="line">    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</span><br><span class="line">    <span class="type">long</span> <span class="variable">notReadyTimeout</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">            iter.remove();</span><br><span class="line">            notReadyTimeout = Math.min(notReadyTimeout, <span class="built_in">this</span>.client.connectionDelay(node, now));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建批次请求</span></span><br><span class="line">    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="built_in">this</span>.accumulator.drain(cluster,</span><br><span class="line">                                                                     result.readyNodes,</span><br><span class="line">                                                                     <span class="built_in">this</span>.maxRequestSize,</span><br><span class="line">                                                                     now);</span><br><span class="line">    <span class="comment">// 保证消息顺序，第一次执行guaranteeMessageOrder为false，不会走</span></span><br><span class="line">    <span class="keyword">if</span> (guaranteeMessageOrder) &#123;</span><br><span class="line">        <span class="comment">// Mute all the partitions drained</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (RecordBatch batch : batchList)</span><br><span class="line">                <span class="built_in">this</span>.accumulator.mutePartition(batch.topicPartition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查超时的批次，第一次执行没expiredBatches为空</span></span><br><span class="line">    List&lt;RecordBatch&gt; expiredBatches = <span class="built_in">this</span>.accumulator.abortExpiredBatches(<span class="built_in">this</span>.requestTimeout, now);</span><br><span class="line">    <span class="comment">// 更新超时批次的错误计数</span></span><br><span class="line">    <span class="keyword">for</span> (RecordBatch expiredBatch : expiredBatches)</span><br><span class="line">        <span class="built_in">this</span>.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);</span><br><span class="line"></span><br><span class="line">    sensors.updateProduceRequestMetrics(batches);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have any nodes that are ready to send + have sendable data, poll with 0 timeout so this can immediately</span></span><br><span class="line">    <span class="comment">// loop and try sending more data. Otherwise, the timeout is determined by nodes that have partitions with data</span></span><br><span class="line">    <span class="comment">// that isn&#x27;t yet sendable (e.g. lingering, backing off). Note that this specifically does not include nodes</span></span><br><span class="line">    <span class="comment">// with sendable data that aren&#x27;t ready to send since they would cause busy looping.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">pollTimeout</span> <span class="operator">=</span> Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</span><br><span class="line">    <span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Nodes with data ready to send: &#123;&#125;&quot;</span>, result.readyNodes);</span><br><span class="line">        pollTimeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备待发送请求的数据</span></span><br><span class="line">    sendProduceRequests(batches, now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行网络请求</span></span><br><span class="line">    <span class="comment">// if some partitions are already ready to be sent, the select time would be 0;</span></span><br><span class="line">    <span class="comment">// otherwise if some partition already has some data accumulated but not ready yet,</span></span><br><span class="line">    <span class="comment">// the select time will be the time difference between now and its linger expiry time;</span></span><br><span class="line">    <span class="comment">// otherwise the select time will be the time difference between now and the metadata expiry time;</span></span><br><span class="line">    <span class="built_in">this</span>.client.poll(pollTimeout, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拉取元数据的请求，在第一次执行的时候，不会返回任何的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do actual reads and writes to sockets.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout The maximum amount of time to wait (in ms) for responses if there are none immediately,</span></span><br><span class="line"><span class="comment"> *                must be non-negative. The actual timeout will be the minimum of timeout, request timeout and</span></span><br><span class="line"><span class="comment"> *                metadata timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> now The current time in milliseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The list of responses received</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">// 封装要拉取元数据的请求</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">metadataTimeout</span> <span class="operator">=</span> metadataUpdater.maybeUpdate(now);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error during I/O&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理已完成请求的操作</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">updatedNow</span> <span class="operator">=</span> <span class="built_in">this</span>.time.milliseconds();</span><br><span class="line">    List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    handleAbortedSends(responses);</span><br><span class="line">    handleCompletedSends(responses, updatedNow);</span><br><span class="line">    handleCompletedReceives(responses, updatedNow);</span><br><span class="line">    handleDisconnections(responses, updatedNow);</span><br><span class="line">    handleConnections();</span><br><span class="line">    handleInitiateApiVersionRequests(updatedNow);</span><br><span class="line">    handleTimedOutRequests(responses, updatedNow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke callbacks</span></span><br><span class="line">    <span class="keyword">for</span> (ClientResponse response : responses) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.onComplete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Uncaught error in request completion:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>拉取元数据，给定超时间返回可用的通道或超时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout should be &gt;= 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasStagedReceives() || !immediatelyConnectedKeys.isEmpty())</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check ready keys */</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startSelect</span> <span class="operator">=</span> time.nanoseconds();</span><br><span class="line">    <span class="comment">// 阻塞等待，直到有可用连接或超时</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readyKeys</span> <span class="operator">=</span> select(timeout);</span><br><span class="line">    <span class="type">long</span> <span class="variable">endSelect</span> <span class="operator">=</span> time.nanoseconds();</span><br><span class="line">    <span class="built_in">this</span>.sensors.selectTime.record(endSelect - startSelect, time.milliseconds());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readyKeys &gt; <span class="number">0</span> || !immediatelyConnectedKeys.isEmpty()) &#123;</span><br><span class="line">        pollSelectionKeys(<span class="built_in">this</span>.nioSelector.selectedKeys(), <span class="literal">false</span>, endSelect);</span><br><span class="line">        pollSelectionKeys(immediatelyConnectedKeys, <span class="literal">true</span>, endSelect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addToCompletedReceives();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endIo</span> <span class="operator">=</span> time.nanoseconds();</span><br><span class="line">    <span class="built_in">this</span>.sensors.ioTime.record(endIo - endSelect, time.milliseconds());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we use the time at the end of select to ensure that we don&#x27;t close any connections that</span></span><br><span class="line">    <span class="comment">// have just been processed in pollSelectionKeys</span></span><br><span class="line">    maybeCloseOldestConnection(endSelect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前面`KafkaProducer` 类里面开启sender线程</summary>
    
    
    
    <category term="Kafka" scheme="https://yuanxw.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://yuanxw.github.io/tags/Kafka/"/>
    
    <category term="Kafka源码分析" scheme="https://yuanxw.github.io/tags/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Kafka源码分析(二)KafkaProducer初始化</title>
    <link href="https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)KafkaProducer%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)KafkaProducer%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-09-03T17:02:14.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka源码分析-二-KafkaProducer初始化"><a href="#Kafka源码分析-二-KafkaProducer初始化" class="headerlink" title="Kafka源码分析(二)KafkaProducer初始化"></a>Kafka源码分析(二)KafkaProducer初始化</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Kafka的源码中附带了一个examples模块，我们从<code>KafkaConsumerProducerDemo</code>类中作为Producer生产者入口进入源码。</p><h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><ul><li><code>KafkaConsumerProducerDemo</code> 在Demo中创建Producer实例，并且开启多线程start</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConsumerProducerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否是异步：如果参数个数为0，或者第一个参数不是&quot;sync&quot;，则是异步。生产环境一般是异步的数据处理。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAsync</span> <span class="operator">=</span> args.length == <span class="number">0</span> || !args[<span class="number">0</span>].trim().equalsIgnoreCase(<span class="string">&quot;sync&quot;</span>);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(KafkaProperties.TOPIC, isAsync);</span><br><span class="line">        producerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本章节只看Producer，因此把Consumer相关的代码暂时注释掉</span></span><br><span class="line">        <span class="comment">// Consumer consumerThread = new Consumer(KafkaProperties.TOPIC);</span></span><br><span class="line">        <span class="comment">// consumerThread.start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>KafkaProducer初始化流程图</li></ul><pre><code class="mermaid">sequenceDiagramautonumberNote right of Producer: Producer初始化Producer-&gt;&gt; Producer: KafkaProducer实例化，传入props配置信息Producer-&gt;&gt; KafkaProducer: KafkaProducer实例化，传入props配置信息KafkaProducer-&gt;&gt; ProducerConfig: ProducerConfig初始化配置并验证参数信息KafkaProducer-&gt;&gt; KafkaProducer: 获取clientId属性，如果没有设置，则生成一个唯一的idKafkaProducer-&gt;&gt; KafkaProducer: 从配置中获取分区器，如果没有设置，则使用默认分区器KafkaProducer-&gt;&gt; KafkaProducer: 获取重试的间隔时间，默认100msKafkaProducer-&gt;&gt; KafkaProducer: 获取序列化器KafkaProducer-&gt;&gt; KafkaProducer: 初始化metadata元数据，并设置集群资源监听器KafkaProducer-&gt;&gt; KafkaProducer: 初始化缓存对象accumulator，用于缓存待发送的记录KafkaProducer-&gt;&gt; KafkaProducer: 更新元数据，设置cluster信息，cluster信息来自于配置文件中的bootstrap.serversKafkaProducer-&gt;&gt; KafkaProducer: 初始化网络客户端，用于发送请求。KafkaProducer-&gt;&gt; KafkaProducer: 初始化网络线程sender，用于发送请求。KafkaProducer-&gt;&gt; KafkaProducer: 启动Kafka网络线程this.ioThread.start();</code></pre><ul><li>生产者构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者构造函数</span></span><br><span class="line"><span class="comment"> * topic: 主题名称</span></span><br><span class="line"><span class="comment"> * isAsync: 是否异步发送</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isAsync</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(String topic, Boolean isAsync)</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 连接kafka集群地址，这里使用默认配置：localhost:9092</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, KafkaProperties.KAFKA_SERVER_URL + <span class="string">&quot;:&quot;</span> + KafkaProperties.KAFKA_SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client.id: 客户端ID，用于标识当前生产者实例</span></span><br><span class="line">    props.put(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;DemoProducer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key.serializer: key序列化器，这里使用IntegerSerializer</span></span><br><span class="line">    <span class="comment">// value.serializer: value序列化器，这里使用StringSerializer</span></span><br><span class="line">    props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.IntegerSerializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KafkaProducer实例化，传入配置信息</span></span><br><span class="line">    producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line">    <span class="built_in">this</span>.topic = topic;</span><br><span class="line">    <span class="built_in">this</span>.isAsync = isAsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>构建KafkaProducer</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 通过提供一组键值对作为配置来实例化创建者。有效的配置字符串</span></span><br><span class="line"><span class="comment">  * 记录在 &lt;a href=“http://kafka.apache.org/documentation.html#producerconfigs”&gt;这里&lt;/a&gt;。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> properties   生产者配置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">KafkaProducer</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">ProducerConfig</span>(properties), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 通过提供一组键值对作为配置、一个键和一个值 &#123;<span class="doctag">@link</span> Serializer&#125; 来实例化生产者。</span></span><br><span class="line"><span class="comment">  * 此处记录了有效的配置字符串&lt;a href=“http://kafka.apache.org/documentation.html#producerconfigs”&gt;&lt;/a&gt;。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> properties 生产者配置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keySerializer 实现 &#123;<span class="doctag">@link</span> Serializer&#125; 的 key 的序列化器。configure（） 方法不会是</span></span><br><span class="line"><span class="comment">  * 在直接传入序列化程序时在 producer 中调用。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> valueSerializer 实现 &#123;<span class="doctag">@link</span> Serializer&#125; 的值的序列化器。configure（） 方法不会</span></span><br><span class="line"><span class="comment">  * 当直接传入序列化程序时，在 producer 中调用。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">KafkaProducer</span><span class="params">(Properties properties, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">ProducerConfig</span>(ProducerConfig.addSerializerToConfig(properties, keySerializer, valueSerializer)),</span><br><span class="line">          keySerializer, valueSerializer);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>KafkaProducer实例化</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">KafkaProducer</span><span class="params">(ProducerConfig config, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Starting the Kafka producer&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; userProvidedConfigs = config.originals();</span><br><span class="line">        <span class="built_in">this</span>.producerConfig = config;</span><br><span class="line">        <span class="built_in">this</span>.time = Time.SYSTEM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取clientId属性，如果没有设置，则生成一个唯一的id</span></span><br><span class="line">        clientId = config.getString(ProducerConfig.CLIENT_ID_CONFIG);</span><br><span class="line">        <span class="keyword">if</span> (clientId.length() &lt;= <span class="number">0</span>)</span><br><span class="line">            clientId = <span class="string">&quot;producer-&quot;</span> + PRODUCER_CLIENT_ID_SEQUENCE.getAndIncrement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指标、监控相关代码</span></span><br><span class="line">        Map&lt;String, String&gt; metricTags = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        metricTags.put(<span class="string">&quot;client-id&quot;</span>, clientId);</span><br><span class="line">        <span class="type">MetricConfig</span> <span class="variable">metricConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetricConfig</span>().samples(config.getInt(ProducerConfig.METRICS_NUM_SAMPLES_CONFIG))</span><br><span class="line">                .timeWindow(config.getLong(ProducerConfig.METRICS_SAMPLE_WINDOW_MS_CONFIG), TimeUnit.MILLISECONDS)</span><br><span class="line">                .tags(metricTags);</span><br><span class="line">        List&lt;MetricsReporter&gt; reporters = config.getConfiguredInstances(ProducerConfig.METRIC_REPORTER_CLASSES_CONFIG,</span><br><span class="line">                MetricsReporter.class);</span><br><span class="line">        reporters.add(<span class="keyword">new</span> <span class="title class_">JmxReporter</span>(JMX_PREFIX));</span><br><span class="line">        <span class="built_in">this</span>.metrics = <span class="keyword">new</span> <span class="title class_">Metrics</span>(metricConfig, reporters, time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从配置中获取分区器，如果没有设置，则使用默认分区器</span></span><br><span class="line">        <span class="built_in">this</span>.partitioner = config.getConfiguredInstance(ProducerConfig.PARTITIONER_CLASS_CONFIG, Partitioner.class);</span><br><span class="line">        <span class="comment">// 获取重试的间隔时间，默认100ms</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">retryBackoffMs</span> <span class="operator">=</span> config.getLong(ProducerConfig.RETRY_BACKOFF_MS_CONFIG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取序列化器</span></span><br><span class="line">        <span class="keyword">if</span> (keySerializer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.keySerializer = config.getConfiguredInstance(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                    Serializer.class);</span><br><span class="line">            <span class="built_in">this</span>.keySerializer.configure(config.originals(), <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            config.ignore(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG);</span><br><span class="line">            <span class="built_in">this</span>.keySerializer = keySerializer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valueSerializer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.valueSerializer = config.getConfiguredInstance(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                    Serializer.class);</span><br><span class="line">            <span class="built_in">this</span>.valueSerializer.configure(config.originals(), <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            config.ignore(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG);</span><br><span class="line">            <span class="built_in">this</span>.valueSerializer = valueSerializer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置拦截器</span></span><br><span class="line">        userProvidedConfigs.put(ProducerConfig.CLIENT_ID_CONFIG, clientId);</span><br><span class="line">        List&lt;ProducerInterceptor&lt;K, V&gt;&gt; interceptorList = (List) (<span class="keyword">new</span> <span class="title class_">ProducerConfig</span>(userProvidedConfigs, <span class="literal">false</span>)).getConfiguredInstances(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG,</span><br><span class="line">                ProducerInterceptor.class);</span><br><span class="line">        <span class="built_in">this</span>.interceptors = interceptorList.isEmpty() ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">ProducerInterceptors</span>&lt;&gt;(interceptorList);</span><br><span class="line">        <span class="comment">// 集群资源监听器</span></span><br><span class="line">        <span class="type">ClusterResourceListeners</span> <span class="variable">clusterResourceListeners</span> <span class="operator">=</span> configureClusterResourceListeners(keySerializer, valueSerializer, interceptorList, reporters);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化metadata元数据结构，并设置集群资源监听器</span></span><br><span class="line"><span class="comment">         * retryBackoffMs:重试的间隔时间，默认100ms</span></span><br><span class="line"><span class="comment">         * metadataMaxAgeMs:元数据最大存活时间，默认5分钟</span></span><br><span class="line"><span class="comment">         * allowAutoTopicCreation:是否允许自动创建主题，默认true</span></span><br><span class="line"><span class="comment">         * clusterResourceListeners:集群资源监听器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.metadata = <span class="keyword">new</span> <span class="title class_">Metadata</span>(retryBackoffMs, config.getLong(ProducerConfig.METADATA_MAX_AGE_CONFIG), <span class="literal">true</span>, clusterResourceListeners);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取maxRequestSize属性，(最大请求大小)，默认1M</span></span><br><span class="line"><span class="comment">         * 获取totalMemorySize属性，(缓冲区总大小)，默认32M</span></span><br><span class="line"><span class="comment">         * 获取compressionType属性，(压缩类型)，默认none</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">this</span>.maxRequestSize = config.getInt(ProducerConfig.MAX_REQUEST_SIZE_CONFIG);</span><br><span class="line">        <span class="built_in">this</span>.totalMemorySize = config.getLong(ProducerConfig.BUFFER_MEMORY_CONFIG);</span><br><span class="line">        <span class="built_in">this</span>.compressionType = CompressionType.forName(config.getString(ProducerConfig.COMPRESSION_TYPE_CONFIG));</span><br><span class="line">        <span class="comment">/* 检查用户定义的设置。</span></span><br><span class="line"><span class="comment">         * 如果 BLOCK_ON_BUFFER_FULL 设置为 true，则不执行 METADATA_FETCH_TIMEOUT_CONFIG。</span></span><br><span class="line"><span class="comment">         * 当已弃用的配置被删除时，这应该在 0.9 版本中删除。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (userProvidedConfigs.containsKey(ProducerConfig.BLOCK_ON_BUFFER_FULL_CONFIG)) &#123;</span><br><span class="line">            log.warn(ProducerConfig.BLOCK_ON_BUFFER_FULL_CONFIG + <span class="string">&quot; config is deprecated and will be removed soon. &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Please use &quot;</span> + ProducerConfig.MAX_BLOCK_MS_CONFIG);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">blockOnBufferFull</span> <span class="operator">=</span> config.getBoolean(ProducerConfig.BLOCK_ON_BUFFER_FULL_CONFIG);</span><br><span class="line">            <span class="keyword">if</span> (blockOnBufferFull) &#123;</span><br><span class="line">                <span class="built_in">this</span>.maxBlockTimeMs = Long.MAX_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (userProvidedConfigs.containsKey(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG)) &#123;</span><br><span class="line">                log.warn(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG + <span class="string">&quot; config is deprecated and will be removed soon. &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Please use &quot;</span> + ProducerConfig.MAX_BLOCK_MS_CONFIG);</span><br><span class="line">                <span class="built_in">this</span>.maxBlockTimeMs = config.getLong(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.maxBlockTimeMs = config.getLong(ProducerConfig.MAX_BLOCK_MS_CONFIG);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (userProvidedConfigs.containsKey(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG)) &#123;</span><br><span class="line">            <span class="comment">// 获取元数据超时时间，默认60s</span></span><br><span class="line">            log.warn(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG + <span class="string">&quot; config is deprecated and will be removed soon. &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Please use &quot;</span> + ProducerConfig.MAX_BLOCK_MS_CONFIG);</span><br><span class="line">            <span class="built_in">this</span>.maxBlockTimeMs = config.getLong(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取最大阻塞时间，默认60s</span></span><br><span class="line">            <span class="built_in">this</span>.maxBlockTimeMs = config.getLong(ProducerConfig.MAX_BLOCK_MS_CONFIG);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检查用户定义的设置。</span></span><br><span class="line"><span class="comment">         * 如果设置了 TIME_OUT 配置，请将其用于请求超时。</span></span><br><span class="line"><span class="comment">         * 这应该在 0.9 版中删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (userProvidedConfigs.containsKey(ProducerConfig.TIMEOUT_CONFIG)) &#123;</span><br><span class="line">            log.warn(ProducerConfig.TIMEOUT_CONFIG + <span class="string">&quot; config is deprecated and will be removed soon. Please use &quot;</span> +</span><br><span class="line">                    ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG);</span><br><span class="line">            <span class="built_in">this</span>.requestTimeoutMs = config.getInt(ProducerConfig.TIMEOUT_CONFIG);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取请求超时时间，默认30s</span></span><br><span class="line">            <span class="built_in">this</span>.requestTimeoutMs = config.getInt(ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化缓存对象，用于缓存待发送的记录。</span></span><br><span class="line">        <span class="built_in">this</span>.accumulator = <span class="keyword">new</span> <span class="title class_">RecordAccumulator</span>(config.getInt(ProducerConfig.BATCH_SIZE_CONFIG),</span><br><span class="line">                <span class="built_in">this</span>.totalMemorySize,</span><br><span class="line">                <span class="built_in">this</span>.compressionType,</span><br><span class="line">                config.getLong(ProducerConfig.LINGER_MS_CONFIG),</span><br><span class="line">                retryBackoffMs,</span><br><span class="line">                metrics,</span><br><span class="line">                time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新元数据，设置cluster信息，cluster信息来自于配置文件中的bootstrap.servers</span></span><br><span class="line">        List&lt;InetSocketAddress&gt; addresses = ClientUtils.parseAndValidateAddresses(config.getList(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG));</span><br><span class="line">        <span class="built_in">this</span>.metadata.update(Cluster.bootstrap(addresses), Collections.&lt;String&gt;emptySet(), time.milliseconds());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化管理网络组件NetworkClient</span></span><br><span class="line"><span class="comment">         * connections.max.idle.ms : 连接最大空闲时间，默认9分钟</span></span><br><span class="line"><span class="comment">         * max.in.flight.requests.per.connection : 单个连接最大未确认请求数，默认5。如果需要有序，需要设置：为1</span></span><br><span class="line"><span class="comment">         * reconnect.backoff.ms : 重连间隔时间，默认50毫秒</span></span><br><span class="line"><span class="comment">         * send.buffer.bytes : 发送缓冲区大小，默认128K</span></span><br><span class="line"><span class="comment">         * receive.buffer.bytes : 接收缓冲区大小，默认32K</span></span><br><span class="line"><span class="comment">         * requestTimeoutMs：请求超时时间，默认5分钟</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ChannelBuilder</span> <span class="variable">channelBuilder</span> <span class="operator">=</span> ClientUtils.createChannelBuilder(config.values());</span><br><span class="line">        <span class="type">NetworkClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NetworkClient</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Selector</span>(config.getLong(ProducerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG), <span class="built_in">this</span>.metrics, time, <span class="string">&quot;producer&quot;</span>, channelBuilder),</span><br><span class="line">                <span class="built_in">this</span>.metadata,</span><br><span class="line">                clientId,</span><br><span class="line">                config.getInt(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION),</span><br><span class="line">                config.getLong(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG),</span><br><span class="line">                config.getInt(ProducerConfig.SEND_BUFFER_CONFIG),</span><br><span class="line">                config.getInt(ProducerConfig.RECEIVE_BUFFER_CONFIG),</span><br><span class="line">                <span class="built_in">this</span>.requestTimeoutMs,</span><br><span class="line">                time,</span><br><span class="line">                <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  初始化网络Sender线程，用于发送请求。</span></span><br><span class="line"><span class="comment">         *  acks：确认模式：默认值为：1</span></span><br><span class="line"><span class="comment">         *      0：不确认，即使集群中有leader，也不会等待确认。</span></span><br><span class="line"><span class="comment">         *      1：leader确认，即使集群中有follower，也不会等待确认。</span></span><br><span class="line"><span class="comment">         *      2：leader和follower都确认，等待所有副本确认。</span></span><br><span class="line"><span class="comment">         * retries：重试次数，默认值为：0。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">this</span>.sender = <span class="keyword">new</span> <span class="title class_">Sender</span>(client,</span><br><span class="line">                <span class="built_in">this</span>.metadata,</span><br><span class="line">                <span class="built_in">this</span>.accumulator,</span><br><span class="line">                config.getInt(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION) == <span class="number">1</span>,</span><br><span class="line">                config.getInt(ProducerConfig.MAX_REQUEST_SIZE_CONFIG),</span><br><span class="line">                (<span class="type">short</span>) parseAcks(config.getString(ProducerConfig.ACKS_CONFIG)),</span><br><span class="line">                config.getInt(ProducerConfig.RETRIES_CONFIG),</span><br><span class="line">                <span class="built_in">this</span>.metrics,</span><br><span class="line">                Time.SYSTEM,</span><br><span class="line">                <span class="built_in">this</span>.requestTimeoutMs);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ioThreadName</span> <span class="operator">=</span> <span class="string">&quot;kafka-producer-network-thread&quot;</span> + (clientId.length() &gt; <span class="number">0</span> ? <span class="string">&quot; | &quot;</span> + clientId : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动Kafka网络线程</span></span><br><span class="line">        <span class="built_in">this</span>.ioThread = <span class="keyword">new</span> <span class="title class_">KafkaThread</span>(ioThreadName, <span class="built_in">this</span>.sender, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.ioThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.errors = <span class="built_in">this</span>.metrics.sensor(<span class="string">&quot;errors&quot;</span>);</span><br><span class="line"></span><br><span class="line">        config.logUnused();</span><br><span class="line">        AppInfoParser.registerAppInfo(JMX_PREFIX, clientId);</span><br><span class="line">        log.debug(<span class="string">&quot;Kafka producer started&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// this is to prevent resource leak. see KAFKA-2121</span></span><br><span class="line">        close(<span class="number">0</span>, TimeUnit.MILLISECONDS, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KafkaException</span>(<span class="string">&quot;Failed to construct kafka producer&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Kafka的源码中附带了一个examples模块，我们从`KafkaConsumerProducerDemo`类中作为Producer生产者入口进入源码</summary>
    
    
    
    <category term="Kafka" scheme="https://yuanxw.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://yuanxw.github.io/tags/Kafka/"/>
    
    <category term="Kafka源码分析" scheme="https://yuanxw.github.io/tags/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Kafka源码分析(一)环境搭建</title>
    <link href="https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://yuanxw.github.io/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2025-06-30T16:00:00.000Z</published>
    <updated>2025-09-03T16:42:04.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka源码分析-一-环境搭建"><a href="#Kafka源码分析-一-环境搭建" class="headerlink" title="Kafka源码分析(一)环境搭建"></a>Kafka源码分析(一)环境搭建</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>源码的思路是先分析老版本，再分析新版本。因为老版本的架构是稳定的，基础特性都是有的。最后我们对比Feature提升对Kafka理解。<br>由浅入深：假设我们认为Kafka是一个单体的，首先分析一条消息从Producer发到Kafka再到Consumer的一个消费，再到集群的处理的消费。</p><h2 id="二、前置条件"><a href="#二、前置条件" class="headerlink" title="二、前置条件"></a>二、前置条件</h2><h3 id="2-1-安装和配置JDK"><a href="#2-1-安装和配置JDK" class="headerlink" title="2.1 安装和配置JDK"></a>2.1 <strong>安装和配置JDK</strong></h3><ul><li><p>JDK配置要求JDK1.8，使用java -version命令来查看当前JDK的版本，示例如下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\yuanxw&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_241&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_241-b07)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-下载并安装配置Gradle"><a href="#2-2-下载并安装配置Gradle" class="headerlink" title="2.2 下载并安装配置Gradle"></a><strong>2.2 下载并安装配置Gradle</strong></h3><ul><li><p>下载地址为：<a href="https://gradle.org/releases/">https://gradle.org/releases/</a>，笔者使用的版本是5.6.4。一般只需要将下载的包解压，然后再将GRADLE_HOME&#x2F;bin的路径添加到环境变量Path中即可，其中;GRADLE_HOME指的是Gradle的根目录。可以使用gradle -v命令来验证Gradle是否已经配置完成，示例如下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\yuanxw&gt;gradle -v</span><br><span class="line"></span><br><span class="line">Welcome to Gradle 5.6.4!</span><br><span class="line"></span><br><span class="line">Here are the highlights of this release:</span><br><span class="line"> - Incremental Groovy compilation</span><br><span class="line"> - Groovy compile avoidance</span><br><span class="line"> - Test fixtures <span class="keyword">for</span> Java projects</span><br><span class="line"> - Manage plugin versions via settings script</span><br><span class="line"></span><br><span class="line">For more details see https://docs.gradle.org/5.6.4/release-notes.html</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 5.6.4</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build <span class="keyword">time</span>:   2019-11-01 20:42:00 UTC</span><br><span class="line">Revision:     dd870424f9bd8e195d614dc14bb140f43c22da98</span><br><span class="line"></span><br><span class="line">Kotlin:       1.3.41</span><br><span class="line">Groovy:       2.5.4</span><br><span class="line">Ant:          Apache Ant(TM) version 1.9.14 compiled on March 12 2019</span><br><span class="line">JVM:          1.8.0_241 (Oracle Corporation 25.241-b07)</span><br><span class="line">OS:           Windows 10 10.0 amd64</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-下载并安装配置Scala"><a href="#2-3-下载并安装配置Scala" class="headerlink" title="2.3 下载并安装配置Scala"></a><strong>2.3 下载并安装配置Scala</strong></h3><ul><li><p>在win上安装Scala 2.10.6，上官网找到2.10.6版本对应的下载地址，kafka的服务器端的源码是scala写的，但是新版本的客户端的源码是java写的<a href="https://www.scala-lang.org/download/2.10.6.html">https://www.scala-lang.org/download/2.10.6.html</a>然后就可以下载win上的安装包，scala.msi，下载好之后傻瓜式安装就可以了，接着必须配置SCALA_HOME和PATH两个环境变量，首先必须得有Java和Scala两种编程语言的支持才可以。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\yuanxw&gt;scala -version</span><br><span class="line">Scala code runner version 2.10.6 -- Copyright 2002-2013, LAMP/EPFL</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-构建Kafka源码环境"><a href="#2-4-构建Kafka源码环境" class="headerlink" title="2.4 构建Kafka源码环境"></a><strong>2.4 构建Kafka源码环境</strong></h3><ul><li><p>在GitHub上fork一份kafka源码到自已仓库，从自己的仓库中下载，下载地址：<a href="https://github.com/apache/kafka.git">https://github.com/apache/kafka.git</a></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 E： 盘新建一个 kafka 目录，然后把 Kafka 项目 Clone 到这里。(作者位置：E:\workspace\IdeaWork\github)</span></span><br><span class="line">E:\workspace\IdeaWork\github&gt;**git <span class="built_in">clone</span> git@github.com:yuanxw/kafka.git**</span><br><span class="line">Cloning into <span class="string">&#x27;kafka&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 451197, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 451197 (delta 0), reused 0 (delta 0), pack-reused 451197 (from 1)</span><br><span class="line">Receiving objects: 100% (451197/451197), 227.47 MiB | 81.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (220962/220962), <span class="keyword">done</span>.</span><br><span class="line">Updating files: 100% (6890/6890), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 0.10.2 版本*</span></span><br><span class="line">git checkout origin/0.10.2</span><br></pre></td></tr></table></figure></li><li><p>Gradle 构建 Kafka 项目之前确认事项：</p><ol><li><p>确保 gradle.properties 配置文件中的 scalaVersion 与 Windows 中 Scala 版本一致，0.10.2 版本的 Kafka 是 2.10.6 版本的 Scala。</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">group=org.apache.kafka</span><br><span class="line"># <span class="attr">NOTE:</span> When you change <span class="variable language_">this</span> version number, you should also make sure to update</span><br><span class="line"># the version numbers <span class="keyword">in</span> tests<span class="regexp">/kafkatest/</span>__init__.py and kafka-merge-pr.py.</span><br><span class="line">version=<span class="number">0.10</span><span class="number">.2</span><span class="number">.3</span>-SNAPSHOT</span><br><span class="line">scalaVersion=<span class="number">2.10</span><span class="number">.6</span></span><br><span class="line">task=build</span><br><span class="line">org.gradle.jvmargs=-<span class="attr">XX:</span>MaxPermSize=<span class="number">512</span>m -Xmx1024m -Xss2m</span><br></pre></td></tr></table></figure></li><li><p>配置 Gradle 的仓库为阿里的镜像仓库</p><ul><li>改之前遇到的错误：</li></ul> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">E:\workspace\IdeaWork\github\kafka&gt;gradle idea</span><br><span class="line">Starting a Gradle Daemon (subsequent builds will be faster)</span><br><span class="line"></span><br><span class="line">&gt; Configure project :</span><br><span class="line">[<span class="type">Fatal</span> <span class="type">Error</span>] gradle<span class="literal">-versions-plugin-0</span>.<span class="number">13.0</span>.pom:<span class="number">7</span>:<span class="number">3</span>: 元素类型 <span class="string">&quot;hr&quot;</span> 必须由匹配的结束标记 <span class="string">&quot;&lt;/hr&gt;&quot;</span> 终止。</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">A problem occurred configuring root project <span class="string">&#x27;kafka&#x27;</span>.</span><br><span class="line">&gt; Could not resolve all artifacts <span class="keyword">for</span> configuration <span class="string">&#x27;:classpath&#x27;</span>.</span><br><span class="line">   &gt; Could not resolve com.github.ben<span class="literal">-manes</span>:gradle<span class="literal">-versions-plugin</span>:<span class="number">0.13</span>.<span class="number">0</span>.</span><br><span class="line">     Required by:</span><br><span class="line">         project :</span><br><span class="line">      &gt; Could not resolve com.github.ben<span class="literal">-manes</span>:gradle<span class="literal">-versions-plugin</span>:<span class="number">0.13</span>.<span class="number">0</span>.</span><br><span class="line">         &gt; Could not parse POM http://dl.bintray.com/content/netflixoss/external<span class="literal">-gradle-plugins</span>/com/github/ben<span class="literal">-manes</span>/gradle<span class="literal">-versions-plugin</span>/<span class="number">0.13</span>.<span class="number">0</span>/gradle<span class="literal">-versions-plugin-0</span>.<span class="number">13.0</span>.pom</span><br><span class="line">            &gt; 元素类型 <span class="string">&quot;hr&quot;</span> 必须由匹配的结束标记 <span class="string">&quot;&lt;/hr&gt;&quot;</span> 终止。</span><br><span class="line"></span><br><span class="line">* <span class="keyword">Try</span>:</span><br><span class="line">Run with <span class="literal">--stacktrace</span> option to get the stack trace. Run with <span class="literal">--info</span> or <span class="literal">--debug</span> option to get more log output. Run with <span class="literal">--scan</span> to get full insights.</span><br><span class="line"></span><br><span class="line">* Get more help at https://help.gradle.org</span><br><span class="line"></span><br><span class="line">BUILD FAILED <span class="keyword">in</span> <span class="number">12</span>s</span><br></pre></td></tr></table></figure></li><li><p>修改 org.scoverage:gradle-scoverage 的版本号</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// For Apache Rat plugin to ignore non-Git files</span></span><br><span class="line">  classpath <span class="string">&quot;org.ajoberstar:grgit:1.7.0&quot;</span></span><br><span class="line">  classpath <span class="string">&#x27;com.github.ben-manes:gradle-versions-plugin:0.13.0&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里原来是 2.1.0 修改为 2.5.0</span></span><br><span class="line">  <span class="comment">// classpath &#x27;org.scoverage:gradle-scoverage:2.1.0&#x27;</span></span><br><span class="line">  classpath <span class="string">&#x27;org.scoverage:gradle-scoverage:2.5.0&#x27;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改之前遇到的错误：</li></ul> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; Configure project :\github\kafka&gt;gradle idea</span><br><span class="line">Building project <span class="string">&#x27;core&#x27;</span> with Scala version <span class="number">2.10</span>.<span class="number">6</span></span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* <span class="built_in">Where</span>:</span><br><span class="line">Build file <span class="string">&#x27;E:\workspace\IdeaWork\github\kafka\build.gradle&#x27;</span> line: <span class="number">388</span></span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">A problem occurred evaluating root project <span class="string">&#x27;kafka&#x27;</span>.</span><br><span class="line">&gt; Failed to apply plugin [<span class="type">id</span> <span class="string">&#x27;org.scoverage&#x27;</span>]</span><br><span class="line">   &gt; Could not create an instance of <span class="built_in">type</span> org.scoverage.ScoverageExtension.</span><br><span class="line">      &gt; You can<span class="string">&#x27;t map a property that does not exist: propertyName=testClassesDir</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* Try:</span></span><br><span class="line"><span class="string">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* Get more help at https://help.gradle.org</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Deprecated Gradle features were used in this build, making it incompatible with Gradle 6.0.</span></span><br><span class="line"><span class="string">Use &#x27;</span><span class="literal">--warning-mode</span> all<span class="string">&#x27; to show the individual deprecation warnings.</span></span><br><span class="line"><span class="string">See https://docs.gradle.org/5.6.4/userguide/command_line_interface.html#sec:command_line_warnings</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">BUILD FAILED in 1s</span></span><br></pre></td></tr></table></figure></li><li><p>修改好上面的文件之后就可以在 kafka 根目录直接执行 <code>gradle idea</code>，等成功之后就可以用 IDEA 打开了。</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">E:</span>\workspace\IdeaWork\github\kafka&gt;gradle idea</span><br><span class="line"></span><br><span class="line">&gt; Configure <span class="attr">project :</span></span><br><span class="line">Building project <span class="string">&#x27;core&#x27;</span> with Scala version <span class="number">2.10</span><span class="number">.6</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="attr">Task :</span>idea</span><br><span class="line">Generated IDEA project at <span class="attr">file:</span><span class="comment">///E:/workspace/IdeaWork/github/kafka/kafka.ipr</span></span><br><span class="line"></span><br><span class="line">Deprecated Gradle features were used <span class="keyword">in</span> <span class="variable language_">this</span> build, making it incompatible with Gradle <span class="number">6.0</span>.</span><br><span class="line">Use <span class="string">&#x27;--warning-mode all&#x27;</span> to show the individual deprecation warnings.</span><br><span class="line">See <span class="attr">https:</span><span class="comment">//docs.gradle.org/5.6.4/userguide/command_line_interface.html#sec:command_line_warnings</span></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> <span class="number">3</span>m <span class="number">19</span>s</span><br><span class="line"><span class="number">19</span> actionable <span class="attr">tasks:</span> <span class="number">19</span> executed</span><br></pre></td></tr></table></figure><p> <img src="/images/kafak_source/chapter1/image.png" alt="image.png"></p></li></ol></li></ul><h3 id="2-5-Idea配置Kafka源码环境"><a href="#2-5-Idea配置Kafka源码环境" class="headerlink" title="2.5 Idea配置Kafka源码环境"></a><strong>2.5 Idea配置Kafka源码环境</strong></h3><ul><li><p>IDEA 安装 Scala 插件，在 File -&gt; Settings -&gt; Plugin 中搜索 Scala 并安装。</p><p>  <img src="/images/kafak_source/chapter1/image1.png" alt="image.png"></p></li><li><p>配置 Scala SDK，在 File -&gt; Settings -&gt; ProjectStructure</p><p>  <img src="/images/kafak_source/chapter1/image2.png" alt="image.png"></p></li><li><p>将 config 目录下的 log4j.properties 文件拷贝到 core&#x2F;src&#x2F;main&#x2F;scala 目录下，这样可以让 Kafka 在运行时能够输出日志信息。</p><p>  <img src="/images/kafak_source/chapter1/image3.png" alt="image.png"></p></li><li><p>配置 server.properties 文件</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启这个功能方便Kafka在运行一段时间之后，能够删除一些不需要的临时topic</span></span><br><span class="line"><span class="string">delete.topic.enable=true</span></span><br><span class="line"><span class="comment"># 禁用自动创建topic的功能</span></span><br><span class="line"><span class="string">auto.create.topics.enable=false</span></span><br><span class="line"><span class="comment"># 在Windows环境下运行，所以需要修改这个配置，注意这里的双反斜杠</span></span><br><span class="line"><span class="string">log.dirs=E:\\workspace\\IdeaWork\\github\\kafka\\tmp\\kafka-logs</span></span><br><span class="line"><span class="comment"># 配置kafka依赖的zookeeper路径地址，这里的前提是在本地开启了一个zookeeper的服务</span></span><br><span class="line"><span class="string">zookeeper.connect=localhost:2181/kafka</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6-Zookeeper的安装、配置及启动"><a href="#2-6-Zookeeper的安装、配置及启动" class="headerlink" title="2.6 Zookeeper的安装、配置及启动"></a><strong>2.6 Zookeeper的安装、配置及启动</strong></h3><p>Kafka需要使用Zookeeper来管理元数据，比如记录topic、partitions（分区）以及replica（副本）的分配信息。由于这里只是阐述如何构建Kafka的源码环境搭建，所以这里的Zookeeper的安装也以极简为主，即采用单机配置。Zookeeper下载地址为：<a href="http://zookeeper.apache.org/releases.html">http://zookeeper.apache.org/releases.html</a>，下载之后解压，然后将**$ZOOKEEPER_HOME<strong>目录下的conf&#x2F;zoo_sample.cfg重命名为zoo.cfg，其中</strong>$ZOOKEEPER_HOME**指的是ZooKeeper的根目录。</p><p>修改**$ZOOKEEPER_HOME**&#x2F;conf&#x2F;zoo.cfg配置，示例配置如下（其余配置可以不做修改）：</p><ul><li><p>本地下载Zookeeper</p><ul><li>下载版本：apache-zookeeper-3.6.1</li><li>修改配置：dataDir&#x3D;D:\software\apache-zookeeper-3.6.1\data</li></ul></li><li><p>配置zookeeper环境变量</p><p>  将$ZOOKEEPER_HOME&#x2F;bin配置到Path中，之后直接运行zkServer命令即可开启Zookeeper服务。示例如下：</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\yuanxw&gt;zkServer</span><br><span class="line"></span><br><span class="line">C:\Users\yuanxw&gt;call <span class="string">&quot;D:\software\Java\jdk1.8\jdk1.8.0_241&quot;</span>\bin\java <span class="string">&quot;-Dzookeeper.log.dir=D:\software\apache-zookeeper-3.6.1\bin\..\logs&quot;</span> <span class="string">&quot;-Dzookeeper.root.logger=INFO,CONSOLE&quot;</span> <span class="string">&quot;-Dzookeeper.log.file=zookeeper-yuanxw-server-DESKTOP-EDMKNEI.log&quot;</span> <span class="string">&quot;-XX:+HeapDumpOnOutOfMemoryError&quot;</span> <span class="string">&quot;-XX:OnOutOfMemoryError=cmd /c taskkill /pid %%p /t /f&quot;</span> -cp <span class="string">&quot;D:\software\apache-zookeeper-3.6.1\bin\..\build\classes;D:\software\apache-zookeeper-3.6.1\bin\..\build\lib\*;D:\software\apache-zookeeper-3.6.1\bin\..\*;D:\software\apache-zookeeper-3.6.1\bin\..\lib\*;D:\software\apache-zookeeper-3.6.1\bin\..\conf&quot;</span> org<span class="variable">.apache</span><span class="variable">.zookeeper</span><span class="variable">.server</span><span class="variable">.quorum</span><span class="variable">.QuorumPeerMain</span> <span class="string">&quot;D:\software\apache-zookeeper-3.6.1\bin\..\conf\zoo.cfg&quot;</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">539</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">173</span>] - Reading configuration from: D:\software\apache-zookeeper-<span class="number">3</span><span class="variable">.6</span><span class="variable">.1</span>\bin\..\conf\zoo<span class="variable">.cfg</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">566</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">459</span>] - clientPortAddress is <span class="number">0</span><span class="variable">.0</span><span class="variable">.0</span><span class="variable">.0</span>:<span class="number">2181</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">567</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">463</span>] - secureClientPort is <span class="keyword">not</span> set</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">567</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">479</span>] - observerMasterPort is <span class="keyword">not</span> set</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">569</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">496</span>] - metricsProvider<span class="variable">.className</span> is org<span class="variable">.apache</span><span class="variable">.zookeeper</span><span class="variable">.metrics</span><span class="variable">.impl</span><span class="variable">.DefaultMetricsProvider</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">570</span> [myid:] - INFO  [main:DatadirCleanupManager@<span class="number">78</span>] - autopurge<span class="variable">.snapRetainCount</span> set to <span class="number">3</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">570</span> [myid:] - INFO  [main:DatadirCleanupManager@<span class="number">79</span>] - autopurge<span class="variable">.purgeInterval</span> set to <span class="number">0</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">570</span> [myid:] - INFO  [main:DatadirCleanupManager@<span class="number">101</span>] - Purge <span class="keyword">task</span> is <span class="keyword">not</span> scheduled.</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">570</span> [myid:] - WARN  [main:QuorumPeerMain@<span class="number">138</span>] - Either no <span class="keyword">config</span> <span class="keyword">or</span> no quorum defined in <span class="keyword">config</span>, running in standalone mode</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">574</span> [myid:] - INFO  [main:ManagedUtil@<span class="number">44</span>] - Log4j <span class="number">1</span><span class="variable">.2</span> jmx support found <span class="keyword">and</span> enabled.</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">630</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">173</span>] - Reading configuration from: D:\software\apache-zookeeper-<span class="number">3</span><span class="variable">.6</span><span class="variable">.1</span>\bin\..\conf\zoo<span class="variable">.cfg</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">631</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">459</span>] - clientPortAddress is <span class="number">0</span><span class="variable">.0</span><span class="variable">.0</span><span class="variable">.0</span>:<span class="number">2181</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">631</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">463</span>] - secureClientPort is <span class="keyword">not</span> set</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">632</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">479</span>] - observerMasterPort is <span class="keyword">not</span> set</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">632</span> [myid:] - INFO  [main:QuorumPeerConfig@<span class="number">496</span>] - metricsProvider<span class="variable">.className</span> is org<span class="variable">.apache</span><span class="variable">.zookeeper</span><span class="variable">.metrics</span><span class="variable">.impl</span><span class="variable">.DefaultMetricsProvider</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">632</span> [myid:] - INFO  [main:ZooKeeperServerMain@<span class="number">122</span>] - Starting server</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">680</span> [myid:] - INFO  [main:ServerMetrics@<span class="number">62</span>] - ServerMetrics initialized <span class="keyword">with</span> provider org<span class="variable">.apache</span><span class="variable">.zookeeper</span><span class="variable">.metrics</span><span class="variable">.impl</span><span class="variable">.DefaultMetricsProvider</span>@<span class="number">7</span>a92922</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">683</span> [myid:] - INFO  [main:FileTxnSnapLog@<span class="number">124</span>] - zookeeper<span class="variable">.snapshot</span><span class="variable">.trust</span><span class="variable">.empty</span> : false</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">691</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">691</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -   ______                  _</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">691</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -  |___  /                 | |</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">692</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -     / /    ___     ___   | | __   ___    ___   _ __     ___   _ __</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">692</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -    / /    / _ \   / _ \  | |/ /  / _ \  / _ \ | &#x27;_ \   / _ \ | &#x27;__|</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">692</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -   / /__  | (_) | | (_) | |   &lt;  |  __/ |  __/ | |_) | |  __/ | |</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">693</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -  /_____|  \___/   \___/  |_|\_\  \___|  \___| | <span class="variable">.__</span>/   \___| |_|</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">693</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -                                               | |</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">693</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -                                               |_|</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">694</span> [myid:] - INFO  [main:ZookeeperBanner@<span class="number">42</span>] -</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">705</span> [myid:] - INFO  [main:Environment@<span class="number">98</span>] - Server environment:zookeeper<span class="variable">.version</span>=<span class="number">3</span><span class="variable">.6</span><span class="variable">.1</span>--<span class="number">104</span>dcb3e3fb464b30c5186d229e00af9f332524b, built on <span class="number">04</span>/<span class="number">21</span>/<span class="number">2020</span> <span class="number">15</span>:<span class="number">01</span> GMT</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">705</span> [myid:] - INFO  [main:Environment@<span class="number">98</span>] - Server environment:host<span class="variable">.name</span>=DESKTOP-EDMKNEI</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">705</span> [myid:] - INFO  [main:Environment@<span class="number">98</span>] - Server environment:java<span class="variable">.version</span>=<span class="number">1</span><span class="variable">.8</span><span class="variable">.0_241</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">706</span> [myid:] - INFO  [main:Environment@<span class="number">98</span>] - Server environment:java<span class="variable">.vendor</span>=Oracle Corporation</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">708</span> [myid:] - INFO  [main:Environment@<span class="number">98</span>] - Server environment:java<span class="variable">.home</span>=D:\software\Java\jdk1<span class="variable">.8</span>\jdk1<span class="variable">.8</span><span class="variable">.0_241</span>\jre</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32</span>,<span class="number">874</span> [myid:] - INFO  [main:ContextHandler@<span class="number">825</span>] - Started o<span class="variable">.e</span><span class="variable">.j</span><span class="variable">.s</span><span class="variable">.ServletContextHandler</span>@<span class="number">887</span>af79&#123;/,<span class="literal">null</span>,AVAILABLE&#125;</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">262</span> [myid:] - INFO  [main:AbstractConnector@<span class="number">330</span>] - Started ServerConnector@<span class="number">57</span>baeedf&#123;HTTP/<span class="number">1</span><span class="variable">.1</span>,[http/<span class="number">1</span><span class="variable">.1</span>]&#125;&#123;<span class="number">0</span><span class="variable">.0</span><span class="variable">.0</span><span class="variable">.0</span>:<span class="number">8080</span>&#125;</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">263</span> [myid:] - INFO  [main:Server@<span class="number">399</span>] - Started @<span class="number">925</span>ms</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">264</span> [myid:] - INFO  [main:JettyAdminServer@<span class="number">178</span>] - Started AdminServer on address <span class="number">0</span><span class="variable">.0</span><span class="variable">.0</span><span class="variable">.0</span>, port <span class="number">8080</span> <span class="keyword">and</span> command URL /commands</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">268</span> [myid:] - INFO  [main:ServerCnxnFactory@<span class="number">169</span>] - Using org<span class="variable">.apache</span><span class="variable">.zookeeper</span><span class="variable">.server</span><span class="variable">.NIOServerCnxnFactory</span> as server connection factory</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">269</span> [myid:] - WARN  [main:ServerCnxnFactory@<span class="number">309</span>] - maxCnxns is <span class="keyword">not</span> configured, using <span class="keyword">default</span> value <span class="number">0</span>.</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">271</span> [myid:] - INFO  [main:NIOServerCnxnFactory@<span class="number">666</span>] - Configuring NIO connection handler <span class="keyword">with</span> <span class="number">10</span>s sessionless connection timeout, <span class="number">2</span> selector thread(s), <span class="number">16</span> worker threads, <span class="keyword">and</span> <span class="number">64</span> kB direct buffers.</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">272</span> [myid:] - INFO  [main:NIOServerCnxnFactory@<span class="number">674</span>] - binding to port <span class="number">0</span><span class="variable">.0</span><span class="variable">.0</span><span class="variable">.0</span>/<span class="number">0</span><span class="variable">.0</span><span class="variable">.0</span><span class="variable">.0</span>:<span class="number">2181</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">285</span> [myid:] - INFO  [main:WatchManagerFactory@<span class="number">42</span>] - Using org<span class="variable">.apache</span><span class="variable">.zookeeper</span><span class="variable">.server</span><span class="variable">.watch</span><span class="variable">.WatchManager</span> as watch manager</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">286</span> [myid:] - INFO  [main:WatchManagerFactory@<span class="number">42</span>] - Using org<span class="variable">.apache</span><span class="variable">.zookeeper</span><span class="variable">.server</span><span class="variable">.watch</span><span class="variable">.WatchManager</span> as watch manager</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">286</span> [myid:] - INFO  [main:ZKDatabase@<span class="number">132</span>] - zookeeper<span class="variable">.snapshotSizeFactor</span> = <span class="number">0</span><span class="variable">.33</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">286</span> [myid:] - INFO  [main:ZKDatabase@<span class="number">152</span>] - zookeeper<span class="variable">.commitLogCount</span>=<span class="number">500</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">290</span> [myid:] - INFO  [main:SnapStream@<span class="number">61</span>] - zookeeper<span class="variable">.snapshot</span><span class="variable">.compression</span><span class="variable">.method</span> = CHECKED</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">291</span> [myid:] - INFO  [main:FileSnap@<span class="number">85</span>] - Reading snapshot D:\software\apache-zookeeper-<span class="number">3</span><span class="variable">.6</span><span class="variable">.1</span>\data\version-<span class="number">2\s</span>napshot<span class="variable">.0</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">293</span> [myid:] - INFO  [main:DataTree@<span class="number">1737</span>] - The digest value is empty in snapshot</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">298</span> [myid:] - INFO  [main:ZKDatabase@<span class="number">289</span>] - Snapshot loaded in <span class="number">11</span> ms, highest zxid is <span class="number">0</span>x0, digest is <span class="number">1371985504</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">299</span> [myid:] - INFO  [main:FileTxnSnapLog@<span class="number">470</span>] - Snapshotting: <span class="number">0</span>x0 to D:\software\apache-zookeeper-<span class="number">3</span><span class="variable">.6</span><span class="variable">.1</span>\data\version-<span class="number">2\s</span>napshot<span class="variable">.0</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">301</span> [myid:] - INFO  [main:ZooKeeperServer@<span class="number">519</span>] - Snapshot taken in <span class="number">2</span> ms</span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">315</span> [myid:] - INFO  [main:RequestThrottler@<span class="number">74</span>] - zookeeper<span class="variable">.request_throttler</span><span class="variable">.shutdownTimeout</span> = <span class="number">10000</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">326</span> [myid:] - INFO  [main:ContainerManager@<span class="number">83</span>] - Using checkIntervalMs=<span class="number">60000</span> maxPerMinute=<span class="number">10000</span> maxNeverUsedIntervalMs=<span class="number">0</span></span><br><span class="line"><span class="number">2025</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">33</span>,<span class="number">328</span> [myid:] - INFO  [main:ZKAuditProvider@<span class="number">42</span>] - ZooKeeper audit is disabled.</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">源码的思路是先分析老版本，再分析新版本。因为老版本的架构是稳定的，基础特性都是有的。最后我们对比Feature提升对Kafka理解。由浅入深：假设我们认为Kafka是一个单体的，首先分析一条消息从Producer发到Kafka再到Consumer的一个消费，再到集群的处理的消费。</summary>
    
    
    
    <category term="Kafka" scheme="https://yuanxw.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://yuanxw.github.io/tags/Kafka/"/>
    
    <category term="Kafka源码分析" scheme="https://yuanxw.github.io/tags/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor并发框架(三)Getting Started开始</title>
    <link href="https://yuanxw.github.io/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6(%E4%B8%89)Getting%20Started%E5%BC%80%E5%A7%8B/"/>
    <id>https://yuanxw.github.io/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6(%E4%B8%89)Getting%20Started%E5%BC%80%E5%A7%8B/</id>
    <published>2025-06-02T16:00:00.000Z</published>
    <updated>2025-09-03T17:28:26.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Disruptor并发框架-三-Getting-Started开始"><a href="#Disruptor并发框架-三-Getting-Started开始" class="headerlink" title="Disruptor并发框架(三)Getting Started开始"></a><strong>Disruptor并发框架(三)Getting Started开始</strong></h2><h2 id="1-获取Disruptor"><a href="#1-获取Disruptor" class="headerlink" title="1. 获取Disruptor"></a>1. 获取Disruptor</h2><p>Disruptor jar 包可以从 maven 仓库 <a href="https://mvnrepository.com/artifact/com.lmax/disruptor">Maven Central</a> 获取。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-基本生产和消费-Basic-Event-Produce-and-Consume"><a href="#2-基本生产和消费-Basic-Event-Produce-and-Consume" class="headerlink" title="2. 基本生产和消费 Basic Event Produce and Consume"></a>2. <strong>基本生产和消费</strong> Basic Event Produce and Consume</h2><p>为了学习 Disruptor 的使用，这里以非常简单的例子入手：生产者生产单个 long 型 value 传递给消费者。为了简化消费者逻辑，这里只打印消费的 value。</p><ul><li><p>首先定义携带数据的 Event：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.disruptor.event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LongEvent&#123;&quot;</span> + <span class="string">&quot;value=&quot;</span> + value + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了使用 Disruptor 的内存预分配 event，我们需要定义一个 EventFactory：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.disruptor.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventFactory;</span><br><span class="line"><span class="keyword">import</span> com.peppa.disruptor.event.LongEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventFactory</span> <span class="keyword">implements</span> <span class="title class_">EventFactory</span>&lt;LongEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LongEvent <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LongEvent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义事件后，我们需要创建一个将处理这些事件的消费者。例如，我们将创建一个 <code>EventHandler</code>，将值打印到控制台。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.disruptor.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventHandler;</span><br><span class="line"><span class="keyword">import</span> com.peppa.disruptor.event.LongEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventHandler</span> <span class="keyword">implements</span> <span class="title class_">EventHandler</span>&lt;LongEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(LongEvent event, <span class="type">long</span> sequence, <span class="type">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Event: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  有了事件消费者，我们还需要事件生产者产生事件。为了简单起见，我们假设数据来源于 I&#x2F;O，如：网络或者文件。由于不同版本的 Disruptor，提供了不同的方式编写生产者。</p></li></ul><h3 id="2-1-Publishing-Using-Translators"><a href="#2-1-Publishing-Using-Translators" class="headerlink" title="2.1 Publishing Using Translators"></a>2.1 Publishing Using Translators</h3><p>在 Disruptor 的 3.0 版本中，由于加入了丰富的 Lambda 风格的API，可以用来帮助开发人员简化流程。所以在 3.0 版本后首选使用 Event Publisher&#x2F;Event Translator 来发布事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.translator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventTranslatorOneArg;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.peppa.disruptor.event.LongEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventProducerWithTranslator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongEventProducerWithTranslator</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventTranslatorOneArg&lt;LongEvent, ByteBuffer&gt; TRANSLATOR =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EventTranslatorOneArg</span>&lt;LongEvent, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">translateTo</span><span class="params">(LongEvent event, <span class="type">long</span> sequence, ByteBuffer bb)</span> &#123;</span><br><span class="line">                    event.set(bb.getLong(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(ByteBuffer bb)</span> &#123;</span><br><span class="line">        ringBuffer.publishEvent(TRANSLATOR, bb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方式的另一个优势在于 Translator 代码可以被分离在单独的类中，同时也比较容易进行无依赖的单元测试。Disruptor 提供了许多不同的接口(EventTranslator, EventTranslatorOneArg, EventTranslatorTwoArg, etc.)，可以通过实现这些接口提供 translators。原因是当转换方法的参数通过对 RingBuffer 的调用传递给转换程序时，允许将转换程序表示为静态类或不捕获的 lambda（ when Java 8 rolls around ）。</p><h3 id="2-2-Publishing-Using-the-Legacy-API"><a href="#2-2-Publishing-Using-the-Legacy-API" class="headerlink" title="2.2 Publishing Using the Legacy API"></a>2.2 Publishing Using the Legacy API</h3><p>也可以使用 3.0 版本之前的遗留 API 构建生产者发布消息，这种方式比较原始（不推荐）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.translator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.peppa.disruptor.event.LongEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 3.0 版本之前的遗留 API 构建生产者发布消息，这种方式比较原始（不推荐）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongEventProducer</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(ByteBuffer bb)</span> &#123;</span><br><span class="line">        <span class="comment">// Grab the next sequence</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> ringBuffer.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Get the entry in the Disruptor for the sequence</span></span><br><span class="line">            <span class="type">LongEvent</span> <span class="variable">event</span> <span class="operator">=</span> ringBuffer.get(sequence);</span><br><span class="line">            <span class="comment">// Fill with data</span></span><br><span class="line">            event.set(bb.getLong(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从以上的代码流程编写可以看出，事件的发布比使用一个简单的队列要复杂。这是由于需要对事件预分配导致。对于消息的发布有两个阶段，首先在 RingBuffer 中声明需要的槽位，然后再发布可用的数据。必须使用 try&#x2F;finally 语句块包裹消息的发布。必须先在 try 块中声明使用 RingBuffer 的槽位，然后在 finally 块中发布使用的 sequece。如果不这样做，将可能导致 Disruptor 状态的错误。具体来说，在多生产者的情况下，这将导致消费者停滞并且只有重新启动才能恢复。因此推荐使用 EventTranslator 编写 producer。</p><p>最后一步需要将以上编写的组件连接起来。虽然可以手动连接各个组件，然而那样可能比较复杂，因此提供了一个 DSL 用于构造以便简化过程。一些更复杂的选项无法通过 DSL 设置，但是对于大多数情况 DSL 还是非常适合的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.util.DaemonThreadFactory;</span><br><span class="line"><span class="keyword">import</span> com.peppa.disruptor.event.LongEvent;</span><br><span class="line"><span class="keyword">import</span> com.peppa.disruptor.factory.LongEventFactory;</span><br><span class="line"><span class="keyword">import</span> com.peppa.disruptor.handler.LongEventHandler;</span><br><span class="line"><span class="keyword">import</span> com.peppa.translator.LongEventProducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventFactoryMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// The factory for the event</span></span><br><span class="line">        <span class="type">LongEventFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Specify the size of the ring buffer, must be power of 2.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct the Disruptor</span></span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> <span class="title class_">Disruptor</span>&lt;&gt;(factory, bufferSize, DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect the handler</span></span><br><span class="line">        disruptor.handleEventsWith(<span class="keyword">new</span> <span class="title class_">LongEventHandler</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the Disruptor, starts all threads running</span></span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the ring buffer from the Disruptor to be used for publishing.</span></span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="type">LongEventProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventProducer</span>(ringBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; <span class="literal">true</span>; l++) &#123;</span><br><span class="line">            bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">            producer.onData(bb);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-Using-Java-8"><a href="#2-3-Using-Java-8" class="headerlink" title="2.3 Using Java 8"></a>2.3 Using Java 8</h3><p>关于对 Disruptor 的接口设计的影响之一是 Java 8，因为它使用了 Functional Interfaces 去实现 Java Lambdas。Disruptor API 中的大多数接口定义都符合 Functional Interfaces 的要求，因此可以使用 Lambda 代替自定义类，可以减少所需的代码量。以上的 LongEventMain 使用 Lambdas 简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.util.DaemonThreadFactory;</span><br><span class="line"><span class="keyword">import</span> com.peppa.disruptor.event.LongEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventMain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 指定ringBuffer的大小，必须是 2 的幂。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建Disruptor</span></span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> <span class="title class_">Disruptor</span>&lt;&gt;(LongEvent::<span class="keyword">new</span>, bufferSize, DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接handle处理类</span></span><br><span class="line">        disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">&quot;Event: &quot;</span> + event));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 Disruptor，启动所有线程运行</span></span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从Disruptor获得RingBuffer，用于发布事件</span></span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; <span class="literal">true</span>; l++) &#123;</span><br><span class="line">            bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">            ringBuffer.publishEvent((event, sequence, buffer) -&gt; event.set(buffer.getLong(<span class="number">0</span>)), bb);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出使用 Lambdas 有大量的类将不再需要，如 handler，translator 等。也可以看出使用 Lambdas 简化 publishEvent() 只仅仅涉及到参数传递。上面的代码还可以简化成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; <span class="literal">true</span>; l++) &#123;</span><br><span class="line">    bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">    ringBuffer.publishEvent((event, sequence) -&gt; event.set(bb.getLong(<span class="number">0</span>)));</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这样会实例化一个对象去持有 ByteBuffer bb 并将其传递给 lambda。这会产生不必要的垃圾，如果对 GC 压力有严格要求的情况下， 则应首选将参数传递给 lambda 的调用。</p><p>假定可以使用方法引用代替匿名 lamdbas，则可以以这种方式重写示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.util.DaemonThreadFactory;</span><br><span class="line"><span class="keyword">import</span> com.peppa.disruptor.event.LongEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">translate</span><span class="params">(LongEvent event, <span class="type">long</span> sequence, ByteBuffer buffer)</span> &#123;</span><br><span class="line">        event.set(buffer.getLong(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 指定ringBuffer的大小，必须是 2 的幂。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建Disruptor</span></span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> <span class="title class_">Disruptor</span>&lt;&gt;(LongEvent::<span class="keyword">new</span>, bufferSize, DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接handle处理类</span></span><br><span class="line">        disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">&quot;Event: &quot;</span> + event));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 Disruptor，启动所有线程运行</span></span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从Disruptor获得RingBuffer，用于发布事件</span></span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; <span class="literal">true</span>; l++) &#123;</span><br><span class="line">            bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">            ringBuffer.publishEvent(LongEventMain::translate, bb);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里对 RingBuffer 的 publishEvent() 参数使用了方法引用替换了 lambda，使其更进一步简化。</p><h2 id="3-Basic-Tuning-Options"><a href="#3-Basic-Tuning-Options" class="headerlink" title="3.Basic Tuning Options"></a>3.Basic Tuning Options</h2><p>如果你能确定硬件和软件的环境便可以进一步对 Disruptor 的参数进行调整以提高性能。 主要有两种参数可以被调整：producer 类型和 wait strategy。</p><h3 id="3-1-Single-vs-Multiple-Producers"><a href="#3-1-Single-vs-Multiple-Producers" class="headerlink" title="3.1 Single vs. Multiple Producers"></a>3.1 Single vs. Multiple Producers</h3><p>提高并发系统的性能的最好方式是遵循 Single Writer Principle，这也适用于 Disruptor。如果在你的场景中只仅仅是单生产者，那么你可以显式设置成单生产者来提升性能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="comment">// Construct the Disruptor with a SingleProducerSequencer</span></span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> <span class="title class_">Disruptor</span>(</span><br><span class="line">            factory, bufferSize, DaemonThreadFactory.INSTANCE, ProducerType.SINGLE, <span class="keyword">new</span> <span class="title class_">BlockingWaitStrategy</span>());</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了说明通过这种技术方式能提升多少性能优势，这里有一份测试类 OneToOne performance test，在 i7 Sandy Bridge MacBook Air的运行结果：</p><ul><li><em>1.多生产者</em></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Run 0, Disruptor=26,553,372 ops/sec</span><br><span class="line">Run 1, Disruptor=28,727,377 ops/sec</span><br><span class="line">Run 2, Disruptor=29,806,259 ops/sec</span><br><span class="line">Run 3, Disruptor=29,717,682 ops/sec</span><br><span class="line">Run 4, Disruptor=28,818,443 ops/sec</span><br><span class="line">Run 5, Disruptor=29,103,608 ops/sec</span><br><span class="line">Run 6, Disruptor=29,239,766 ops/sec</span><br></pre></td></tr></table></figure><ul><li>单生产者</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Run 0, Disruptor=89,365,504 ops/sec</span><br><span class="line">Run 1, Disruptor=77,579,519 ops/sec</span><br><span class="line">Run 2, Disruptor=78,678,206 ops/sec</span><br><span class="line">Run 3, Disruptor=80,840,743 ops/sec</span><br><span class="line">Run 4, Disruptor=81,037,277 ops/sec</span><br><span class="line">Run 5, Disruptor=81,168,831 ops/sec</span><br><span class="line">Run 6, Disruptor=81,699,346 ops/sec</span><br></pre></td></tr></table></figure><h2 id="4-等待策略Alternative-Wait-Strategies"><a href="#4-等待策略Alternative-Wait-Strategies" class="headerlink" title="4. 等待策略Alternative Wait Strategies"></a>4. 等待策略Alternative Wait Strategies</h2><p>Disruptor 默认使用的等待策略是 <strong>BlockingWaitStrategy</strong>。内部的 BlockingWaitStrategy 使用锁和 Condition 处理线程的 wake-up。BlockingWaitStrategy 是等待策略中最慢的，但是其对 CPU 的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现。</p><p>然而，如果你对部署系统比较熟悉的话，可以通过调整等待策略参数来获取额外的性能。</p><h3 id="4-1-SleepingWaitStrategy"><a href="#4-1-SleepingWaitStrategy" class="headerlink" title="4.1 SleepingWaitStrategy"></a>4.1 SleepingWaitStrategy</h3><p>SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，通过使用简单的忙等循环，即 LockSupport.parkNanos(1) 来实现循环等待，在典型的 Linux 系统上会暂停一个线程约 60µs。</p><p>这样做的好处是，生产线程不需要采取任何其他增加适当计数器的动作，并且不需要发信号通知条件变量的成本。但是，生产者线程和使用者线程之间数据传递的平均延迟会更高。它适用于不需要低延迟并且对生产线程的影响较小的情况下，一个常见的用例是异步日志记录。</p><h3 id="4-2-YieldingWaitStrategy"><a href="#4-2-YieldingWaitStrategy" class="headerlink" title="4.2 YieldingWaitStrategy"></a>4.2 YieldingWaitStrategy</h3><p>YieldingWaitStrategy 是可以使用在低延迟系统的策略之一。YieldingWaitStrategy 通过自旋（ busy spin ）以等待序列增加到适当的值。通过在循环内部调用 Thread.yield() 以允许其他队列的线程运行。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略。例如，CPU 开启了超线程。</p><h3 id="4-3-BusySpinWaitStrategy"><a href="#4-3-BusySpinWaitStrategy" class="headerlink" title="4.3 BusySpinWaitStrategy"></a>4.3 BusySpinWaitStrategy</h3><p>BusySpinWaitStrategy 是性能最好的等待策略，但是对环境有更高的限制 。在要求极高性能且事件处理线程数小于 CPU 物理核心数的场景中，才应该使用此策略；例如，CPU 禁用了超线程。</p><h2 id="5-Clearing-Objects-From-the-Ring-Buffer"><a href="#5-Clearing-Objects-From-the-Ring-Buffer" class="headerlink" title="5. Clearing Objects From the Ring Buffer"></a>5. Clearing Objects From the Ring Buffer</h2><p>当通过 Disruptor 传递数据时，对象的存活时间可能超过预期。为了避免这种情况，在事件处理结束后应当清理下事件对象。如果只有单个事件处理程序，则需要在该处理器中清除对应的对象。如果有一连串的事件处理程序，就需要在链的最末尾放置一个特定的处理程序用于清理事件对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectEvent</span>&lt;T&gt; &#123;</span><br><span class="line">    T val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        val = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClearingEventHandler</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">EventHandler</span>&lt;ObjectEvent&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(ObjectEvent&lt;T&gt; event, <span class="type">long</span> sequence, <span class="type">boolean</span> endOfBatch)</span> &#123;</span><br><span class="line">        <span class="comment">// Failing to call clear here will result in the </span></span><br><span class="line">        <span class="comment">// object associated with the event to live until</span></span><br><span class="line">        <span class="comment">// it is overwritten once the ring buffer has wrapped</span></span><br><span class="line">        <span class="comment">// around to the beginning.</span></span><br><span class="line">        event.clear(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Disruptor&lt;ObjectEvent&lt;String&gt;&gt; disruptor = <span class="keyword">new</span> <span class="title class_">Disruptor</span>&lt;&gt;(</span><br><span class="line">        () -&gt; ObjectEvent&lt;String&gt;(), bufferSize, DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line">    disruptor</span><br><span class="line">        .handleEventsWith(<span class="keyword">new</span> <span class="title class_">ProcessingEventHandler</span>())</span><br><span class="line">        .then(<span class="keyword">new</span> <span class="title class_">ClearingObjectHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Disruptor jar 包可以从 maven 仓库 [Maven Central](https://mvnrepository.com/artifact/com.lmax/disruptor) 获取。</summary>
    
    
    
    <category term="Disruptor" scheme="https://yuanxw.github.io/categories/Disruptor/"/>
    
    
    <category term="Disruptor" scheme="https://yuanxw.github.io/tags/Disruptor/"/>
    
    <category term="Disruptor并发框架" scheme="https://yuanxw.github.io/tags/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor并发框架(二)Disruptor用户指南</title>
    <link href="https://yuanxw.github.io/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6(%E4%BA%8C)Disruptor%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"/>
    <id>https://yuanxw.github.io/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6(%E4%BA%8C)Disruptor%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/</id>
    <published>2025-06-01T16:00:00.000Z</published>
    <updated>2025-09-03T17:27:35.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Disruptor并发框架-二-Disruptor用户指南"><a href="#Disruptor并发框架-二-Disruptor用户指南" class="headerlink" title="Disruptor并发框架(二)Disruptor用户指南"></a><strong>Disruptor并发框架(二)Disruptor用户指南</strong></h1><p>理解 Disruptor 是什么最好方式就是将其与现有的比较好理解的东西比较 。Disruptor 就相当于 Java 中 BlockingQueue。同队列一样，Disruptor 用于在不同的线程之间进行数据交互，然而 Disruptor 也提供了一些关键的不同于队列的特性，如：</p><ul><li>广播事件至消费者，并且能遵循消费者依赖关系</li><li>预分配用于存储事件内容的内存空间</li><li>针对极高的性能目标而实现的极度优化和无锁的设计</li></ul><h2 id="1-Core-Concepts-核心概念"><a href="#1-Core-Concepts-核心概念" class="headerlink" title="1. Core Concepts  核心概念"></a><strong>1. Core Concepts  核心概念</strong></h2><p>在理解 Disruptor 如何工作之前，定义一些普遍存在于文档和源代码中的术语，对于倾向 DDD 的人而言，它们就是 Disruptor 领域的无处不在的语言。</p><h3 id="1-1-核心组件"><a href="#1-1-核心组件" class="headerlink" title="1.1 核心组件"></a>1.1 核心组件</h3><ul><li><p><strong>Disruptor</strong></p><p>  持有 RingBuffer、消费者线程池 Executor、消费者集合 CounsumerRepository 等引用。</p></li><li><p><strong>RingBuffer 环形缓冲</strong></p><p>  RingBuffer 在 3.0 版本之前被认为是 Disruptor 的主要概念。但从 Diruptor 3.0 开始，RingBuffer 只负责存储和更新 Disruptor 的数据，在一些高级的使用场景中用户也可以自定义它。</p><p>  RingBuffer 是基于数组的缓存实现，存储生产和消费的 Event，它实现了阻塞队列的语义，也是创建 sequencer 与定义 WaitStartegy 的入口。如果 RingBuffer 满了，则生产者会阻塞等待；如果 RingBuffer 空了，则消费者会阻塞等待。</p></li><li><p><strong>Sequence 序列</strong></p><p>  Disruptor 使用 Sequence 来标记特定组件的处理进度，通过顺序递增的序号来编号，管理进行交换的 Event。一个 Sequence 用于跟踪标识某个特定的事件处理者（RingBuffer、Producer、Consumer）的处理进度。</p><p>  Sequence 具有许多 AtomicLong 的特征，虽然使用 AtomicLong 也可以用于标识进度，但它可以防止不同的 Sequence 之间的 CPU 缓存伪共享(Flase Sharing)问题。</p></li><li><p><strong>Sequencer 序列器</strong></p><p>  Sequencer 是 Disruptor 中的真正核心，主要实现生产者和消费者之间快速、正确地传递数据的并发算法。</p><p>  它具有 SingleProducerSequencer 和 MultiProducerSequencer 这两个实现。</p></li><li><p><strong>Sequence Barrier 序列屏障</strong></p><p>  Sequence Barrier 由 Sequencer 创建，它包含了来自 Sequencer 的已经发布的主要 sequence 的引用，或者包含了依赖的消费者的 sequence。</p><p>  用于保持对 RingBuffer 的 Main Published Sequence(Producer) 和 Consumer 之间的平衡关系，它决定了 Consumer 是否还有可处理的 Event 的逻辑。</p></li><li><p><strong>WaitStrategy 等待策略</strong></p><p>  WaitStrategy 决定了消费者以何种方式等待生产者将 Event 放进 Disruptor 中。</p></li><li><p><strong>Event 事件</strong><br>从生产者传到消费者的数据单元叫做 Event。它不是一个被 Disruptor 定义的特定类型，而是由 Disruptor 的使用者自行定义。</p></li><li><p><strong>Event Processor 事件处理器</strong><br>持有特定的消费者的 Sequence，并且拥有一个主事件循环（main event loop）用于处理 Disruptor 的 Event。</p><p>  其中 BatchEventProcessor 是其具体实现，实现了事件循环（event loop），并且会回调到实现了 EventHandler 的接口对象中。</p></li><li><p><strong>EventHandler 事件处理逻辑</strong><br>由用户实现并且代表了 Disruptor 中的一个消费者的接口，消费者相关的逻辑都需要写在这里。</p></li><li><p><strong>Producer 生产者</strong><br>生产者，泛指调用 Disruptor 发布事件的用户代码，它不是一个被 Disruptor 定义的特定类型，而是由 Disruptor 的使用者自行定义。</p></li></ul><h3 id="1-2-官方示例"><a href="#1-2-官方示例" class="headerlink" title="1.2 官方示例"></a>1.2 官方示例</h3><p>为了将这些元素置于上下文中，下面是一个示例，说明 LMAX 如何在其高性能核心服务（例如交易所）中使用 Disruptor。<em>图 1.具有一组依赖消费者的颠覆者。</em></p><p><img src="/images/disruptor/chapter2/image.png" alt="图 1.具有一组依赖消费者的颠覆者。"></p><p><em><strong>图 1.具有一组依赖消费者的颠覆者。</strong></em></p><p>在该示例中为我们展示了一个多生产者多消费者的模型，生产者和消费者的交互核心为 <strong>RingBuffer</strong> 和 <strong>Sequencer</strong>。</p><p>生产者本身不需要维护 Sequence 序列，这两个生产者只需要直接使用 RingBuffer 的 Sequence 即可，不论谁先生产出数据，都只需要对 RingBuffer 的 Sequence 作 CAS 操作递增即可。</p><p>消费者本身需要维护 Sequence 序列，因为每个消费者的消费进度不同，自身的 Sequence 序列标识了当前消费者的消费进度。当各个消费者需要消费更多的数据时，需要通过 Sequence Barrier 进行协调。</p><h2 id="2-事件广播-Multicast-Events"><a href="#2-事件广播-Multicast-Events" class="headerlink" title="2.事件广播 Multicast Events"></a>2.事件广播 Multicast Events</h2><p>事件广播是 Disruptor 和队列最大的区别。当你有多个消费者监听了同一个 Disruptor，所有的事件将会被发布到所有的消费者中，相比之下队列的一个事件只能被发到一个消费者中。Disruptor 这一特性被用来需要对同一数据进行多个并行操作的情况。如在 LMAX 系统中有三个操作可以同时进行：日志（ journalling，将数据持久到日志文件中），复制（ replication，将数据发送到其他的机器上，以确保存在数据远程副本），业务逻辑处理（business logic，实际的处理工作）。也可以使用 WokrerPool 来并行处理不同的事件 。</p><p>再看上图 图1，有三个EventHandler（JournalConsumer, ReplicationConsumer 和 ApplicationConsumer）监听 Disruptor，每一个都将接受 Disruptor 中所有的可用消息，这允许三个消费者并行的工作。</p><h3 id="2-1-消费者依赖图-Consumer-Dependency-Graph"><a href="#2-1-消费者依赖图-Consumer-Dependency-Graph" class="headerlink" title="2.1 消费者依赖图 Consumer Dependency Graph"></a>2.1 消费者依赖图 Consumer Dependency Graph</h3><p>为了支持实际业务中并行的处理流程，Disruptor 提供了多个消费者之间的协助功能。回到上面的 LMAX 的例子，我们可以让日志处理和远程副本赋值先执行完之后再执行业务处理流程，这个功能被称之为 gating。</p><p>gating 发生在两种场景中：</p><ul><li>第一：我们需要确保生产者不要超过消费者。通过调用 RingBuffer.addGatingConsumers() 增加相关的消费者至Disruptor来完成。</li><li>第二：就是之前所说的场景，通过构造包含需要必须先完成的消费者的 Sequence 的 SequenceBarrier 来实现。</li></ul><p>引用上图1， 有三个消费者监听来自 RingBuffer 的事件。这里有一个依赖关系图。ApplicationConsumer 依赖 JournalConsumer 和 ReplicationConsumer。这个意味着 JournalConsumer 和 ReplicationConsumer 可以自由的并发运行。依赖关系可以看成是从 ApplicationConsumer 的 SequenceBarrier 到 JournalConsumer 和 ReplicationConsumer 的 Sequence 的连接。</p><p>还有一点值得关注，Sequencer 与下游的消费者之间的关系。它的作用之一是确保发布（publication）不会包裹（wrap） RingBuffer。为此，所有下游消费者的Sequence 不能比 RingBuffer 的 Sequence 小且不能小于 RingBuffer 的 size。因为 ApplicationConsumers 的 Sequence 确保小于等于 JournalConsumer 和 ReplicationConsumer 的 Sequence，因此 Sequencer 只需要检查 ApplicationConsumers 的 Sequence。从更一般的意义上讲，Sequencer 只需了解依赖（dependency）树中叶节点的消费者的 Sequence 即可。</p><h2 id="3-事件预分配-Event-Preallocation"><a href="#3-事件预分配-Event-Preallocation" class="headerlink" title="3.事件预分配 Event Preallocation"></a>3.事件预分配 Event Preallocation</h2><p>Disruptor 的目标之一是被用在低延迟的环境中，在低延迟系统中有必要减少和降低内存的占用。在基于 Java 的系统中，需要减少由于 GC 导致的停顿次数（在低延迟的 C&#x2F;C++ 系统中，由于内存分配器的争用，大量的内存分配也会导致问题）。</p><p>为了满足这点，用户可以在 Disruptor 中为事件预分配内存。 在初始构造期间，EventFactory 由用户提供，并将在 Disruptor 的 RingBuffer 中为每个条目（ entry）调用其 newInstance() 方法。 当将新的数据发布到 Disruptor 中时， API 允许用户获取已经被构造的对象，以便可以调用方法更新该对象的域。Disruptor 将确保这些操作是线程安全。</p><h2 id="4-可选择的无锁-Optionally-Lock-free"><a href="#4-可选择的无锁-Optionally-Lock-free" class="headerlink" title="4. 可选择的无锁 Optionally Lock-free"></a>4. 可选择的无锁 Optionally Lock-free</h2><p>对于低延迟的需求推动的另一个关键实现细节是广泛使用无锁算法来实现 Disruptor。所有的内存可见性和正确性都使用内存屏障和 CAS 操作实现。除了 BlockingWaitStrategy 中使用到了锁以外，而这仅仅是为了使用 Condition，以便消费者线程在等待一个新的事件到来的时候能被 park 住。</p><aside>💡<p>许多低延迟系统都使用自旋（busy-wait）来避免使用 Condition 造成的抖动，但是自旋（busy-wait）的数量变多时将会导致性能的下降，特别是 CPU 资源严重受限的情况下。例如，在虚拟环境中的 Web 服务器。</p></aside>]]></content>
    
    
    <summary type="html">理解 Disruptor 是什么最好方式就是将其与现有的比较好理解的东西比较 。Disruptor 就相当于 Java 中 BlockingQueue。同队列一样，Disruptor 用于在不同的线程之间进行数据交互，然而 Disruptor 也提供了一些关键的不同于队列的特性。</summary>
    
    
    
    <category term="Disruptor" scheme="https://yuanxw.github.io/categories/Disruptor/"/>
    
    
    <category term="Disruptor" scheme="https://yuanxw.github.io/tags/Disruptor/"/>
    
    <category term="Disruptor并发框架" scheme="https://yuanxw.github.io/tags/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor并发框架(一)Disruptor介绍</title>
    <link href="https://yuanxw.github.io/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6(%E4%B8%80)Disruptor%E4%BB%8B%E7%BB%8D/"/>
    <id>https://yuanxw.github.io/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6(%E4%B8%80)Disruptor%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-05-31T16:00:00.000Z</published>
    <updated>2025-09-03T17:24:44.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Disruptor并发框架-一-Disruptor介绍"><a href="#Disruptor并发框架-一-Disruptor介绍" class="headerlink" title="Disruptor并发框架(一)Disruptor介绍"></a><strong>Disruptor并发框架</strong>(一)<strong>Disruptor介绍</strong></h2><h2 id="1-什么是Disruptor"><a href="#1-什么是Disruptor" class="headerlink" title="1. 什么是Disruptor?"></a>1. 什么是<strong>Disruptor</strong>?</h2><p>LMAX 的成立旨在打造一个高性能金融交易所。作为我们工作的一部分，我们评估了多种方案去设计这个系统以求达到高性能目标，最后我们发现在传统的解决方案中遇到了基础上的瓶颈。</p><p>许多应用程序依赖队列在处理阶段之间交换数据。我们的性能测试表明，以这种方式使用队列时，延迟成本与磁盘IO操作（基于RAID或SSD的磁盘系统）的成本处于同一数量级——速度非常慢。如果端到端操作中有多个队列，这将使整体延迟增加数百微秒。这显然存在优化空间。</p><p>进一步的研究和对计算机科学的关注使我们意识到传统方法中固有的关注点的混合（例如队列和处理节点）导致了多线程实现中的争用，这表明可能存在更好的方法。结合现代 CPU 的工作原理，也就是我们常说的**“机制共鸣”（mechanical sympathy）**【注：意为参考现代 CPU 的设计思想，顺应底层设计思路，来做上层的应用设计，以便使用底层设计的优势，从而达到一个最佳的设计结果，得到一个‘共鸣’】，通过隔离关注，我们提出了一个数据结构和基于该数据结构的模式，这就是 Disruptor。</p><p>测试结果显示，对于一个三阶段的任务管道，Disruptor 的平均延时的数量级要小于基于传统队列的方法三个数量级。另外 Disruptor 的吞吐量是传统方法的 8 倍。</p><p>这些性能改进也意味着对于并发编程我们前进了一大步。对于高吞吐量和低延时的异步事件处理系统，这种新的模式是一个非常理想的基础组件。</p><p>在 LMAX 中，我们已经建立起一个订单匹配引擎，实时风险管理系统，以及一个高可用性的内存事务处理系统，这些系统在 Disruptor 下都取得了巨大的成功。这些系统中的每一个都建立了新的性能标准，据我们所知，这些标准是无与伦比的。</p><p>Disruptor 不只是专门为金融行业设计的，它具有相当的通用性，它能够解决并发编程中的一个复杂问题：如何最大化性能。这个系统的实现非常简单，尽管这里面的有些概念不是那么直观，但相比于其他机制，基于这种模式的系统往往更加简单。</p><p>相比于其他方法，Disruptor 的写竞争比较少，并发开销更低，而且更加缓存友好，吞吐量更高，延时抖动更低。对于一个普通时钟频率的处理器，Disruptor 每秒处理的消息量为 2500 万，延时低于 50 纳秒。 这个性能指标已经接近于现代处理器在多核之间交换数据的上限。</p><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h2><p>Disruptor 是 LMAX 开发的世界上最快的金融交易系统的产物。早期的设计思路主要借鉴 SEDA [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_1">1</a>] 和 Actors[<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_2">2</a>] 的实现，希望使用 pipeline 来提升吞吐量。通过测试各种实现，我们发现管道（pipeline）在不同阶段（stage）之间，事件排队是性能的主要杀手。我们发现队列带入了剧烈的延时抖动。我们为了达到更好的性能于是花了很多精力来开发一个新的队列实现。然而最终发现队列有其局限性——耦合了生产者、消费者、数据存储等多个关注点。Disruptor 的实现很好地隔离上述关注点。</p><h2 id="3-并发的复杂性"><a href="#3-并发的复杂性" class="headerlink" title="3. 并发的复杂性"></a>3. 并发的复杂性</h2><p>本文遵循计算机科学的通用定义：并发不仅是说有两个或者多个任务同时执行，还意味着对资源的竞争访问。这些竞争的资源可能是数据库、文件、Socket 或者内存中的某个地址。</p><p>代码的并发执行主要有两个方面：互斥和变化的可见性。 互斥主要用来管理对某些资源的竞争更新。变化的可见性主要是用来控制什么时候这些变化对其他线程可见。如果你能够在应用层面上限制并发更新那么你就有可能避免互斥。比如，如果你的算法能够确保任何资源只会被一个线程更新，那么互斥就是不必要的。读或者写要求所有的变化对其他线程可见，但实际上只有竞争写操作才真正需要互斥。</p><p>并发环境中最耗费时间的操作其实就是并发写。多线程对同一个资源的写需要复杂昂贵的协调，通常会通过某种锁来实现资源协调。</p><h3 id="3-1-锁的代价"><a href="#3-1-锁的代价" class="headerlink" title="3.1 锁的代价"></a><strong>3.1 锁的代价</strong></h3><p>锁提供了互斥，并确保以有序的方式发生更改。锁其实是很昂贵的，因为它们在竞争的时候需要进行仲裁。这个仲裁会涉及到操作系统的上下文切换，操作系统会挂起所有在等待这把锁的线程，直到锁持有者释放该锁。上下文切换期间，执行线程会丧失对操作系统的控制，导致执行线程的执行上下文丢失之前缓存的数据和指令集，这会给现代处理器带来严重的性能损耗。 当然效率更高的用户态锁是另一种选择，但用户锁只有在没有竞争的时候才真正会带来益处【注：因为用户态的锁往往是通过自旋锁来实现（或者带休眠的自旋锁），而自旋在竞争激烈的时候开销是很大的（一直在消耗CPU资源）】。</p><p>为了探究影响到底有多大，我们写了一个程序，这个程序很简单，就是调用一个循环 5 亿次递增操作的函数。这个 Java 函数在单线程，2.4G Intel Westmere EP 的 CPU 上只需要 300ms。</p><p>一旦引入锁来提供互斥，即使锁还没有发生竞争，程序的执行时间也会发生显著的增加。当两个或多个线程开始竞争时，成本将再次增加几个数量级。实验结果如下：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>时间（毫秒）</strong></th></tr></thead><tbody><tr><td>Single thread</td><td>300</td></tr><tr><td>Single thread with lock</td><td>10,000</td></tr><tr><td>Two threads with lock</td><td>224,000</td></tr><tr><td>Single thread with CAS</td><td>5,700</td></tr><tr><td>Two threads with CAS</td><td>30,000</td></tr><tr><td>Single thread with volatile write</td><td>4,700</td></tr></tbody></table><h3 id="3-2-CAS的代价"><a href="#3-2-CAS的代价" class="headerlink" title="3.2 CAS的代价"></a><strong>3.2 CAS的代价</strong></h3><p>除了锁之外，另外一种方法是 CAS。CAS 依赖于处理器的支持，当然大部分现代处理器都支持的。CAS 相对于锁是非常高效的，因为它不需要涉及内核上下文切换进行仲裁。但 CAS 并不是免费的，处理器需要对指令 pipeline 加锁以确保原子性，并且会用到内存栅栏（Memory Barrier）以确保对其他线程的可见性。 JAVA中的 java.util.concurrent.Automaic 类用到了 CAS 操作。</p><p>如果程序的关键部分比计数器的简单递增更为复杂，则可能需要使用多个 CAS 操作来协调竞争的复杂状态机。用锁进行并发编程就已经很头疼了，使用 CAS 操作和内存屏障开发无锁算法要复杂很多倍，且很难保证正确性。</p><p>最理想的算法就是只有一个线程来负责对单个资源的所有写，而其它所有的线程都是读结果。要在多处理器环境中读取结果，需要有内存栅栏，以使更改对其他处理器上运行的线程可见。</p><h3 id="3-3-内存栅栏-Memory-Barriers"><a href="#3-3-内存栅栏-Memory-Barriers" class="headerlink" title="3.3 内存栅栏 Memory Barriers"></a>3.3 内存栅栏 Memory Barriers</h3><p>现代处理器为了获得更高的性能会做指令重排，在内存和执行单元中，指令执行、数据的加载和存储都会被进行<code>指令重排</code>。处理器只需要确保程序逻辑能得到相同的结果，它不会关心指令的执行顺序。对于单线程程序，指令重排不会有问题，但对于共享状态的多线程程序而言，内存有序变化就变得非常重要。处理器用内存栅栏来标识对内存更新顺序敏感的代码片段，它们确保确保指令的硬件执行顺序和内存变化在线程间的可见性。编译器可以在代码的合适位置放置额外的软件栅栏（software barriers）来确保被编译代码的执行顺序，这些软件内存栅栏是附加在处理器自身的硬件栅栏之上的。</p><p>现代 CPU 相比内存系统来讲速度是非常快的。为了桥接（ bridge ）其各个 CPU，现代处理器使用了复杂的缓存系统，这些缓存实际上是一些高效的独立的硬件哈希表。不同 CPU 之间的缓存是通过消息传输协议来保证一致性。另外，处理器还会使用“存储缓冲区”缓解对缓存的写压力，使用<code>“无效队列”</code>确保在写操作发生时，缓存一致性协议能快速知道无效队列，从而提高效率。</p><p>对于此种实现方式，最近写入的数据可能处于任何存储中：在寄存器里、在存储缓冲区中、在各级缓存中、在主存中。如果多个线程要共享这个值，那么这个值必须要按照一定的顺序对其它线程可见，这种可见性是通过交换缓存一致性消息来协调完成的。内存栅栏可以控制这些消息的适时产生。</p><p>**读内存栅栏（a read barrier）**确保 CPU 上的加载指令有序，当缓存发生变化时，读内存栅栏会在<code>“无效队列”</code>上标记一个点。读内存栅栏标记点之前的写操作可以通过内存栅栏提供一致性视图（view）【注：读内存栅栏会在<code>“无效队列”</code>中标记一个节点，这个节点意味着read barrier 之前读取的所有数据都已不可靠（这也就告诉我们可能有变化发生），之后的所有读操作都需要重新从内存中加载，因此之后的操作从而能够看到数据的最新变化，barrier 之前的所有线程的写指令和 barrier 之后的读指令就有了一个先后顺序。Read memory barrier 使得排在 read memory barrier 之前的写操作成为一个整体，在这个整体内部写操作的顺序是不确定的，但这个整体形成了一个完整的视图，整个整体的结果对后面的操作是可见】。</p><p>**写内存栅栏（a write barrier）**用来确保 CPU 的存储指令有序，写内存栅栏会在存储缓冲区（store buffer）中标记一个点，这个标记点之前的数据变化（write 操作）会通过缓存刷新（flush）到主存。写内存栅栏标记点之前发生的存储操作可以通过写内存栅栏提供有序性视图。</p><p>一个**完整的内存屏障（a full barrier）**命令的加载&#x2F;存储操作只能在执行它的 CPU 上执行。</p><aside>💡<p>注：综上所述，实际上 read barrier 意味着 read 操作不能穿越这个 read barrier，write barrier 意味着 write 操作不能穿越这个 write barrier。执行 read barrier 的 CPU 是多线程中的消费者的角色，它通过 read barrier 能够尽快看到生产者线程的执行结果。而执行 write barrier 的 CPU 往往充当生产者的角色，它通过 write barrier 把自己执行的结果尽可能快得让其它线程看见。</p></aside><p>一些 CPU 在上述三个基础栅栏基础上引入了很多变化，但是通过这三个基础栅栏足以理解内存栅栏期望解决问题的复杂性。在 Java 内存模型中，对 volatile 域的读取和写入实际上就是对应的 read barrier 和 write barrier。Java 内存模型[<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_3">3</a>]规范对此有明确的定义。</p><h3 id="3-4-缓存行-Cache-Lines"><a href="#3-4-缓存行-Cache-Lines" class="headerlink" title="3.4 缓存行 Cache Lines"></a>3.4 缓存行 Cache Lines</h3><p>在现代处理器中使用缓存的方式对于性能的影响非常重要。这样处理器在处理缓存中保存的数据和指令时非常高效，但是，当发生高速缓存未命中时，就会导致效率极低。</p><p>硬件并不是以字节或字为单位操作缓存，为了效率考虑，缓存通常以缓存行（cache line）的形式进行组织（ organised ），缓存行通常有 32-256 字节，最常见的是 64 字节。缓存行也是缓存一致性协议操作的最小粒度。这就意味着：如果两个变量不幸在同一个缓存行里，而且它们分别由不同的线程写入，那么这两个变量的写入会发生竞争，就好像多线程在竞争写入同一个变量一样。这种现象被称之为**“伪共享”（false sharing）**。出于高性能的考虑，需要确保独立但被并发写入的变量之间不会共享同一个缓存行，以求将资源竞争降到最低。</p><p>可预测式的 CPU 访问主存【注：这里的 memory 译为主存，以便和缓存（cache）区分开来】时，通常会预测接下来将被访问到的主存内容并在后台将它加载到缓存中，从而将主存访问产生的时延降至最低。主存预读取发生的前提是：处理器能够检测到主存访问的模式&#x2F;规律，主存预读取就像是以一个可预测的‘步幅’（stride）在主存中行走。比如说：当对一个数组的内容进行迭代时，‘步幅’是可预测的，这样主存中的内容就能预读取到缓存行中，最大化访问主存的效率。在处理器能感知到的任何方向中，‘步幅’通常要小于 2048 字节。然而，像链表（linked lists）和树（trees）这样的数据结构在主存中拥有分布广泛的节点，从而没有可预测的访问‘步幅’【注：由于链表或者树各个节点之间分布并不是顺序的，相邻节点的存储地址相隔很远，所以处理器找不到对应的读取规律，无法进行预读取。】，由于主存中缺乏一致的模式限制了系统预取缓存行的能力，导致主存访问的效率可能低了 2 个数量级。</p><h3 id="3-5-队列的问题"><a href="#3-5-队列的问题" class="headerlink" title="3.5 队列的问题"></a>3.5 队列的问题</h3><p>队列通常使用链表或数组作为元素的底层存储。如果允许内存队列不受限制，那么对于许多类型的问题来说，它可能会不受控制地增长，直到耗尽内存而导致灾难性故障。当生产者的速度超过消费者的速度时，就会发生这种情况。在生产者的速度保证不超过消费者且内存是宝贵资源的系统中，无界队列非常有用，但如果此假设不成立且队列无限制增长，则始终存在风险。为了避免这种灾难性后果，通常会限制队列的大小（有界）。保持队列有界需要它基于数组或主动跟踪其大小。</p><p>队列实现往往会在队列头、队列尾和队列大小变量上存在写入争用。由于消费者和生产者的速度差异，队列在使用过程中通常总是接近满或接近空。它们很少能达到生产和消费速率均衡的平衡点。这种总是满或总是空的倾向会导致高水平的争用和&#x2F;或昂贵的缓存一致性。问题在于，即使使用不同的并发对象（例如锁或CAS变量）来区分队列头和队列尾，它们通常也占用相同的缓存行。</p><p>除了在队列上使用单个大粒度锁之外，管理队列头的生产者、队列尾的消费者以及两者之间节点的存储等问题，使得并发实现的设计非常复杂。对于 put 和 take 操作，在整个队列上使用大粒度锁虽然实现起来很简单，但却会严重影响吞吐量。如果在队列的语义中将并发问题分开处理，那么除了单生产者-单消费者实现之外，其他任何实现都会变得非常复杂。</p><p>在 Java 中使用队列还有一个问题，因为它们是垃圾的重要来源。首先，必须分配对象并将其放入队列。其次，如果使用链表，则必须分配表示链表节点的对象。当不再被引用时，所有为支持队列实现而分配的对象都需要被回收。</p><h3 id="3-6-管道和图-Pipelines-and-Graphs"><a href="#3-6-管道和图-Pipelines-and-Graphs" class="headerlink" title="3.6 管道和图 Pipelines and Graphs"></a>3.6 管道和图 Pipelines and Graphs</h3><p>很多问题场景下，需要将多个处理阶段绑定在一起组成管道，这个管道通常以并行地方式组织成图的拓扑结构。各个阶段之间通常使用队列来连接，同时每个阶段会有自己的处理线程。</p><p>这种处理方式并不便宜（ cheap ）——每个阶段都会有入队和出队的开销，当路径必须分叉（fork）时，有多少个目标消费者，就会增加多少倍的成本【注：到每个消费者都会有入队操作】；同时，分叉之后还需要合并，这时候会因为不可避免的资源竞争产生额外的成本。</p><h2 id="4-LMAX-Disruptor-的设计"><a href="#4-LMAX-Disruptor-的设计" class="headerlink" title="4. LMAX Disruptor 的设计"></a>4. LMAX Disruptor 的设计</h2><p>为了解决上面提出的问题，该设计严格地实现了关注分离（separation of the concerns）。该设计确保任何数据只被一个线程进行写访问，从而避免写冲突。这个设计就是 Disruptor，之所以叫这个名字是因为它和Java 7 中为支持 Fork-Join 而引入的“Phasers” [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_4">4</a>]有很多相似之处。</p><p>Disruptor 的设计初衷就是为了解决上面提到的问题【<strong>注：锁代价过大、CAS代价过大、缓存行导致的伪共享、队列存在的问题</strong>】，以求最优化内存分配，使用缓存友好的方式来最佳使用现代硬件资源。</p><p>Disruptor 的核心机制在于：以 RingBuffer 的形式预分配有界的数据结构，单个或者多个生产者可以向 RingBuffer 中写入数据，单个或者多个消费者可以从 RingBuffer 读取数据。</p><h3 id="4-1-内存分配-Memory-Allocation"><a href="#4-1-内存分配-Memory-Allocation" class="headerlink" title="4.1 内存分配 Memory Allocation"></a>4.1 内存分配 Memory Allocation</h3><p>Ringbuffer 的内存是在启动时预先分配的。Ringbuffer 要么是一个引用数组，每个元素是指向对象的引用【注：针对C#、 java这样的语言】，要么是一个结构数组，每个元素（entry）代表的就是对象实体【注：针对C、C++这样的语言】。由于 Java 语言的限制，Java 实现的 Ringbuffer 实际上只能是一个引用数组。每个元素只能是一个数据的容器，而不是数据本身。这种预先分配的策略就能够避免 Java 内存回收引起的一些性能问题，因为这些元素对象（enries）在能够在 Disruptor 实例中的整个生命周期存活和被复用【注：这些元素（enties）一直被 RingBuffer 对象持有，而 RingBuffer 实例对象又被 Disruptor 持有，故只要 Disruptor 存在，则这些 enties 便不会被 GC】。由于这些对象是在开始阶段同时分配的，很大程度上被连续分布在主存中，即使不连续它们在内存中的间隔也有可能是固定的，从而支持缓存步幅，非常有利于缓存的数据预取。John Rose 提出了一个草案希望未来 JAVA 能够支持所谓的 “value type”[<a href="https://jitwxs.cn/17fac167.html#fn5">5</a>]，就像C语言那样，如果这样的话，Disruptor 就能够确保对象在内存中一定是连续的，而不仅仅只是有很大可能性了。</p><p>对于 Java 这样的运行环境来讲，垃圾回收对于低延时系统是一个严重的挑战。内存越大，垃圾回收造成的性能压力也就越大。垃圾回收喜欢的对象要么寿命非常短，要么对象干脆是永生的。Ringbuffer 的预先分配使得我们的对象变成了永生的对象，大大减轻垃圾回收的压力。</p><p>在高负载的情况下，基于队列的系统可以 back up，这会降低处理效率，进而导致被分配的对象比原本存活得更长，在使用分代垃圾收集器的 JVM 中，这些对象将会从年轻代进入老年代。这就意味着：</p><ul><li>这些对象被不断地在各代之间【注：年轻代 eden gen 和 survivor area，以及 young gen 和 old gen 之间】进行拷贝，造成延时波动；</li><li>进入老年代的对象回收成本会更高，GC 带来的内存碎片也会更多，引起 ‘stop the world’ 的概率会更大；越多的临时对象进入到老年代，也更可能带来性能上的损耗。</li></ul><p>【注：如果对象是永生的。那么第一点的代价无法避免，但第二点的代价就会大大降低，因为这些对象一直会存在，那么老年代触发 major collection 时它扫描一下所有对象，发现这些对象都无法释放，什么都不用干，那就直接收工。由于对象不会被释放，那也就不会有碎片，那么 stop the world 的概率也就大大降低了。永生对象在第二点中所做的只不过是进行一次扫描，这个代价非常小。】</p><p>下面通过分析 ArrayBlockingQueue 和 RingBuffer 来加深 Disruptor 内存预分配所带来的好处。</p><p>在 ArrayBlockingQueue 中，数组 Object[] items 负责存储队列中的所有元素，如下图所示，当消费者消费完 items[0] 元素，紧接着生产者向 items[0] 放入新的元素 entity1，这时候 items[0] 存储的是对象 entity1 的引用，items[0] 到 entity0 对象的引用被切断，entity0 等待被 GC。生产者不断地向 items[0] 中写入消息，则老的 entity 将不断地需要被 GC，一旦队列阻塞，items 可能熬过多次minor GC，幸存下来，并进入到老年代，带来更严重的性能隐患。</p><p><img src="/images/disruptor/chapter1/image.png" alt="ArrayBlockQueue Memory Allocation"></p><p><em><strong>ArrayBlockQueue Memory Allocation</strong></em></p><p>再来看看 RingBuffer 预分配内存方式的精妙之处。RingBuffer 同样使用数组 Object[] entries 作为存储元素。如下图所示，初始化RingBuffer 时，会将所有的 entries 的每个元素指定为特定的 Event，这时候 event 中的 detail 属性是 null；后面生产者向 RingBuffer中写入消息时，RingBuffer 不是直接将 enties[7] 指向其他的 event 对象，而是先获取 event 对象，然后更改 event 对象的 detail 属性；消费者在消费时，也是从 RingBuffer 中读取出 event，然后取出其 detail 属性。可以看出，生产&#x2F;消费过程中，RingBuffer 的 entities[7] 元素并未发生任何变化，未产生临时对象，entities 及其元素对象一直存活，直到 RingBuffer 消亡。故而可以最小化 GC 的频率，提升性能。</p><p><img src="/images/disruptor/chapter1/image1.png" alt="Disruptor Memory Allocation"></p><p><em><strong>Disruptor Memory Allocation</strong></em></p><h3 id="4-2-隔离关注-Teasing-Apart-the-Concerns"><a href="#4-2-隔离关注-Teasing-Apart-the-Concerns" class="headerlink" title="4.2 隔离关注 Teasing Apart the Concerns"></a>4.2 隔离关注 Teasing Apart the Concerns</h3><p>我们认为以下问题在所有队列实现中都是混杂在一起的，在某种程度上，这种独特行为的集合倾向于定义队列实现的接口：</p><ol><li>队列元素的存储</li><li>队列协调生产者声明下一个需要交换的队列元素的序号</li><li>队列协调并告知消费者等待的元素已经就绪</li></ol><p>在使用带有垃圾回收特性语言来设计金融用的交易所（exchange）时，过多的内存分配会带来麻烦，所以，我们基于链表的队列不是一个好的解决方案。如果用于存储各个阶段交换数据的节点（entries）可以被预先分配内存，则可以最大限度地减少垃圾回收。如果节点被统一分配为相同大小的块，那么在遍历节点时，将会以一种缓存友好的方式进行，效率会更高。预分配内存的数组满足上述的要求，在创建 RingBuffer 时，DIsruptor 使用抽象工厂模式预分配了所有节点，当一个节点被声明时，生产者只需要将它的数据拷贝到这个预分配的数据空间中即可。</p><p>对于现代处理器而言，取余操作是一种比较昂贵的操作。但在 RingBuffer 中取余是一个使用频率很高的操作，因为需要计算某一个序号在 RingBuffer 中的位置需要用到取余。一个替代的方法是将 RingBuffer 的长度设置为2的幂次方，这样通过简单的位操作就可以获取余数。</p><p>我们前面提到，有界队列会在队列头和队列尾形成激烈的竞争。但是 RingBuffer 使用的数据结构则没有这种竞争和并发，因为RingBuffer 将这些竞争的焦点（concerns）转移到了生产者&#x2F;消费者栅栏（barriers）上去，接下来我们将详细阐述这一逻辑。</p><p>Disruptor 的典型应用场景通常只有一个生产者，典型的生产者是文件读取或者网络侦听。如果只有一个生产者，那么队列元素分配或者序号分配不会存在竞争。</p><p>但在一些特别的场景，Disruptor 会有多个生产者，这种情况下生产者们可能会彼此竞争来获取 RingBuffer 中下一个可用的位置，这里的竞争问题可以通过 CAS 操作来处理。</p><p>当生产者将相关的数据拷贝到 RingBuffer 的位置（entry）中后，生产者提交这个序号，告知消费者这个位置的数据可以消费了。这里可以不使用 CAS 操作，而是用简单地自旋直到等待的其他生产者都到达了这个序号便可提交。【注：RingBuffer 通过一个游标（cursor）来告知消费者当前那些位置可以被消费，多个生产者时，需要确保游标之前的 seq 都已经提交，故而这里需要协调各个生产者】。为了避免覆盖情况发生【注：覆盖是指生产者速度快于消费者速度，导致生产者写入消费者还未来得及消费的位置】，生产者在写入前会检查所有消费者最小的 seq，确保写入的 seq不 会大于这个最小的消费者 seq。</p><p>消费者在读取元素之前需要等待一个序号，该序号指示了有效的可以读取的元素。怎么样等待这个序号，有很多种策略。如果 CPU资源比较宝贵，那么消费者可以等待某一个锁的条件变量，由生产者来唤醒消费者。这种方式明显会带来竞争，只适用于 CPU 资源的稀缺性比系统的延时&#x2F;吞吐量重要的场景。另外一种策略是所有消费者线程循环检查游标（cursor），该游标表示 RingBuffer 中当前有效的可供读取的元素的位置，这种策略使用更多消耗 CPU 资源来换取低时延。这种方法由于没有用锁和条件变量，因此打破了生产者和消费者之间的竞争依赖关系。如果你想支持多生产者-多消费者的场景，你就不得不采用很多 CAS 操作，这些 CAS 操作作用在头、尾、队列长度等等，这就带来了复杂性。但 Disruptor 避免了这种复杂的 CAS 竞争。</p><h3 id="4-3-序列化-Sequencing"><a href="#4-3-序列化-Sequencing" class="headerlink" title="4.3 序列化 Sequencing"></a>4.3 序列化 Sequencing</h3><p>顺序化是 Disruptor 管理并发的核心概念。每个生产者和消费者都维护自己的序号，这个序号用来和 RingBuffer 交互。当一个生产者希望在 RingBuffer 中添加一个元素时，它首先要做的是声明一个序号【注：这个序号被称之为生产者的声明序号，该序号用来指示下一个空闲的插槽（slot ）的位置，一旦序号被声明，那么该序号就不会被其它生产者重复操作，生产者就可以操作该声明序号的 slot 数据】。单生产者的场景下，这个声明序号可以是一个简单的整数；多生产者的场景，这个序号必须是一个支持 CAS 的原子变量。当一个生产者序号被声明，这个序号对应的位置就可以被声明该序号的生产者写入了；当生产者完成更新元素后，它就通过更新一个单独的序号来提交变化，这个单独的序号是一个游标（cursor），用来指示消费者可以消费的最新的元素。生产者可以通过一种自旋的方式来读取和更新 RingBuffer 的游标，这里只需要使用内存栅栏而不需要使用 CAS 操作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">expectedSequence</span> <span class="operator">=</span> claimedSequence – <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cursor != expectedSequence) &#123; <span class="comment">//this is a memory Barrier</span></span><br><span class="line">    <span class="comment">// busy spin</span></span><br><span class="line">&#125;</span><br><span class="line">cursor = claimedSequence;</span><br></pre></td></tr></table></figure><p>消费者等待指定的消费者序号变得可用，它通过内存栅栏（memory barrier）来读取游标（cursor），一旦游标的值被更新，内存栅栏会确保 RingBuffer 中的这一变化会被所有在游标上等待的消费者可见。【注：通过这种机制，消费者能够及时知道生产者提交了新的消息，并尝试进行消费】。</p><p>每个消费者都各自维护一个序号来表示自己最新消费的位置序号。生产者通过跟踪这些序号来确保不会覆盖消费者还未来得及消费的位置，同时这些序号也可以用于协调消费者之间的执行顺序【注：Disruptor 中的多消费者实际上是指对于同一个 event，有多个处理阶段，每个阶段被认为是一个独立的消费者，各个阶段的执行通常是有顺序要求的】。</p><p>单生产者场景下，不管消费者有多么复杂的依赖，Disruptor 都无需使用锁和 CAS 操作，它通过多个序号（Sequences）上的内存栅栏就可以协调整个并发场景。【注：Disruptor 中有两类 Sequence——生产者序号（又叫 cursor）和消费者序号，通过在这两个序号上建立内存栅栏，达到协调并发的目的】。</p><h3 id="4-4-批量效应-Batching-Effect"><a href="#4-4-批量效应-Batching-Effect" class="headerlink" title="4.4 批量效应 Batching Effect"></a>4.4 批量效应 Batching Effect</h3><p>当消费者等待 RingBuffer 中可用的前进游标序号时，如果消费者发现 RingBuffer 游标自上次检查以来已经前进了多个序号，消费者可以直接处理所有可用的多个序号，而不用引入并发机制， 这样滞后的消费者能够迅速跟上生产者的步伐，从而平衡系统，这一特性是队列（queues）不具有的。这种类型的批处理增加了吞吐量，同时减少和平滑了延迟。 根据我们的观察结果，无论负载如何，时延都会维持在一个常数时间值上，直到存储子系统饱和，曲线是线性的，遵循 Little’s Law[<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_6">6</a>] 定律。 这与在负载增加时观察队列所得到时延 “J” 曲线效应非常不同。</p><h3 id="4-5-依赖图-Dependency-Graphs"><a href="#4-5-依赖图-Dependency-Graphs" class="headerlink" title="4.5 依赖图 Dependency Graphs"></a>4.5 依赖图 Dependency Graphs</h3><p>队列从本质上来讲表示一个简单的消费者和生产者之间的只具有一步的管道（pipeline）。如果消费者形成了一个链条，或者一个图状的依赖关系，那么图中的每个阶段之间都会需要一个队列。大量的队列就带来了开销。在设计 LMAX 金融交易系统的过程中，我们发现基于队列的设计方法会导致大量的队列开销，而这些为数众多的队列所带来的开销耗费了事务处理的大部分时间。</p><p>在 Disruptor 设计模式中，生产者和消费者的竞争被很好得隔离开了，因此通过使用一个简单的 RingBuffer 也可以在消费者之间构造复杂的依赖关系。这样降低了执行时延，从而提高了吞吐量。</p><p>一个 RingBuffer 可以用来处理一个具有复杂的依赖关系图的流程。设计 RingBuffer 的时候需要特别注意，需要避免消费者之间错误的共享缓存行。</p><h3 id="4-6-Disruptor-类图"><a href="#4-6-Disruptor-类图" class="headerlink" title="4.6 Disruptor 类图"></a>4.6 Disruptor 类图</h3><p>下图是 Disruptor 框架的核心类图。此图省略了一些可用于简化编程模型的便捷类。依赖关系图构建完成后，那么编程模型就变简单了。生产者通过 ProducerBarrier 来顺序申请 entry，同时将数据变化写入 entry 中，然后再通过 ProducerBarrier 来提交数据变化并使得这些变化对消费者可见。作为一个消费者，它所需要做的只不过是提供一个 BatchHandler 实现，当一个新的 entry 可见时，这个回调会被触发。这使得 Disruptor 编程模型是一个基于事件的模型，和 Actor 模型类似。</p><p>为了更灵活的设计，队列通常将关注点组合起来考虑。RingBuffer 是 Disruptor 模式的核心，它为数据交换提供了存储，同时又避免了竞争。通过 RingBuffer，生产者和消费者之间的并发问题被隔离开了。ProducerBarrier 就是用来管理RingBuffer中的位置槽（slot）声明，同时跟踪相关的消费者从而避免冲突覆盖。而 ConsumerBarrier 在有新的元素有效时会负责通知消费者。通过这些barrier，消费者之间就构造成了一个依赖关系图，这个依赖关系关系图实际上代表了流程处理过程中的各个阶段。</p><p>【注：本篇文章是基于 Disruptor1.0 的，因此下面的类图也是 1.0 版本的，现在已经更新到 4.0 版本，类图已经有了很大的改变。】</p><p><img src="/images/disruptor/chapter1/image2.png" alt="image.png"></p><h3 id="4-7-代码示例"><a href="#4-7-代码示例" class="headerlink" title="4.7 代码示例"></a>4.7 代码示例</h3><p>下面的代码示例是一个单生产者和单消费者的场景，它通过 BatchHandler 来实现消费者。消费者运行在一个单独的线程上，当元素可用时，它被用来接收元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callback handler which can be implemented by consumers</span></span><br><span class="line"><span class="keyword">final</span> BatchHandler&lt;ValueEntry&gt; batchHandler = <span class="keyword">new</span> <span class="title class_">BatchHandler</span>&lt;ValueEntry&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAvailable</span><span class="params">(<span class="keyword">final</span> ValueEntry entry)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// process a new entry as it becomes available.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEndOfBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// useful for flushing results to an IO device if necessary.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do any necessary clean up before shutdown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RingBuffer&lt;ValueEntry&gt; ringBuffer =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RingBuffer</span>&lt;ValueEntry&gt;(ValueEntry.ENTRY_FACTORY, SIZE,</span><br><span class="line">                               ClaimStrategy.Option.SINGLE_THREADED,</span><br><span class="line">                               WaitStrategy.Option.YIELDING);</span><br><span class="line">ConsumerBarrier&lt;ValueEntry&gt; consumerBarrier = ringBuffer.createConsumerBarrier();       </span><br><span class="line">BatchConsumer&lt;ValueEntry&gt; batchConsumer = </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BatchConsumer</span>&lt;ValueEntry&gt;(consumerBarrier, batchHandler);</span><br><span class="line">ProducerBarrier&lt;ValueEntry&gt; producerBarrier = ringBuffer.createProducerBarrier(batchConsumer);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// Each consumer can run on a separate thread</span></span><br><span class="line">EXECUTOR.submit(batchConsumer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producers claim entries in sequence</span></span><br><span class="line"><span class="type">ValueEntry</span> <span class="variable">entry</span> <span class="operator">=</span> producerBarrier.nextEntry();</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy data into the entry container</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// make the entry available to consumers</span></span><br><span class="line">producerBarrier.commit(entry);</span><br></pre></td></tr></table></figure><h2 id="5-吞吐量性能测试-Throughput-Performance-Testing"><a href="#5-吞吐量性能测试-Throughput-Performance-Testing" class="headerlink" title="5. 吞吐量性能测试 Throughput Performance Testing"></a>5. 吞吐量性能测试 Throughput Performance Testing</h2><p>作为参考，我们选择了 Doug Lea 的 java.util.concurrent.ArrayBlockingQueue[<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_7">7</a>]，根据我们的测试，它在所有有界队列中具有最高的性能。测试是按照阻塞的方式进行的以匹配 Disruptor。以下详细描述的测试用例可在 Disruptor 开源项目中找到。注意：运行测试需要一个能够并行执行至少 4 个线程的系统。</p><aside>💡<p>运行测试需要能够并行执行至少 4 个线程的系统。</p></aside><p><img src="/images/disruptor/chapter1/image3.png" alt="图 1. 单播：1P – 1C"></p><p><em>图 1. 单播：1P – 1C</em></p><p><img src="/images/disruptor/chapter1/image4.png" alt="图 2. 三步流水线：1P – 3C"></p><p><em>图 2. 三步流水线：1P – 3C</em></p><p><img src="/images/disruptor/chapter1/image5.png" alt="图 3. 序列器：3P – 1C"></p><p><em>图 3. 序列器：3P – 1C</em></p><p><img src="/images/disruptor/chapter1/image6.png" alt="图 4. 多播：1P – 3C"></p><p><em>图 4. 多播：1P – 3C</em></p><p><img src="/images/disruptor/chapter1/image7.png" alt="图 5. 钻石：1P – 3C"></p><p><em>图 5. 钻石：1P – 3C</em></p><p>对于上述配置，我们<code>ArrayBlockingQueue</code>针对每条数据流弧应用了与 Disruptor 屏障配置进行比较。下表显示了使用 Java 1.6.0_25 64 位 Sun JVM、Windows 7、Intel Core i7 860 @ 2.8 GHz（不带超线程）和 Intel Core i7-2720QM、Ubuntu 11.04 操作系统，处理 5 亿条消息时，以每秒操作数为单位的性能结果，并取 3 次运行中的最佳结果。不同的 JVM 执行结果可能会有很大差异，以下数据并非我们观察到的最高值。</p><ul><li><em>表 2. 比较吞吐量（以每秒操作数为单位）</em></li></ul><table><thead><tr><th><strong>Nehalem 2.8Ghz – Windows 7 SP1 64-bit</strong></th><th></th><th><strong>Sandy Bridge 2.2Ghz – Linux 2.6.38 64-bit</strong></th><th></th></tr></thead><tbody><tr><td></td><td><strong>ABQ</strong></td><td><strong>Disruptor</strong></td><td><strong>ABQ</strong></td></tr><tr><td>Unicast: 1P – 1C</td><td>5,339,256</td><td>25,998,336</td><td>4,057,453</td></tr><tr><td>Pipeline: 1P – 3C</td><td>2,128,918</td><td>16,806,157</td><td>2,006,903</td></tr><tr><td>Sequencer: 3P – 1C</td><td>5,539,531</td><td>13,403,268</td><td>2,056,118</td></tr><tr><td>Multicast: 1P – 3C</td><td>1,077,384</td><td>9,377,871</td><td>260,733</td></tr><tr><td>Diamond: 1P – 3C</td><td>2,113,941</td><td>16,143,613</td><td>2,082,725</td></tr></tbody></table><ul><li><em>表 3. 针对现代硬件更新的比较吞吐量（以每秒操作数为单位）</em></li></ul><table><thead><tr><th><strong>AMD EPYC 9374F – Linux 5.4.277 – OpenJDK 11.0.24</strong></th><th></th><th></th></tr></thead><tbody><tr><td></td><td><strong>ABQ</strong></td><td><strong>Disruptor 3</strong></td></tr><tr><td>Unicast: 1P – 1C</td><td>20,895,148</td><td>134,553,283</td></tr><tr><td>Pipeline: 1P – 3C</td><td>5,216,647</td><td>76,068,766</td></tr><tr><td>Sequencer: 3P – 1C</td><td>18,791,340</td><td>16,010,759</td></tr><tr><td>Multicast: 1P – 3C</td><td>2,355,379</td><td>68,157,033</td></tr><tr><td>Diamond: 1P – 3C</td><td>3,433,665</td><td>61,229,488</td></tr></tbody></table><h2 id="6-延迟性能测试-Latency-Performance-Testing"><a href="#6-延迟性能测试-Latency-Performance-Testing" class="headerlink" title="6. 延迟性能测试 Latency Performance Testing"></a>6. 延迟性能测试 Latency Performance Testing</h2><p>为了测量延时，我们采用 3 个阶段的 pipeline 作为测试场景，为了能够测出系统的最佳状态，我们让吞吐量压力维持在一个合适的水准，这个压力不至于耗尽队列资源。这个压力是通过每插入一个事件就等待 1ms 的方式来实现的，然后一直这样重复 5000 万次。为了精确测量延时，我们需要精确考量 CPU 的时间戳计数器（TSC）。我们采用了那些 TSC 恒定的 CPU 来作为测试机器，因为老的 CPU 为了节省功耗，往往会自动调节 TSC。Intel Nehalem 之后的 CPU 都支持恒定的TSC。可以使用运行于 Ubuntu 11.04 上的 Oracle 最新版本的 JVM 进行测试，本测试未做 CPU 绑定。为了进行比较，我们再次使用 ArrayBlockingQueue。我们本可以使用 ConcurrentLinkedQueue [ <a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_8">8</a> ]，它可能会给出更好的结果，但我们希望使用有界队列实现，以确保生产者不会通过产生背压而超过消费者。以下结果基于 2.2GHz Core i7-2720QM 处理器，在 Ubuntu 11.04 系统上运行 Java 1.6.0_25 64 位版本。Disruptor 的平均每跳延迟为 52 纳秒，而 ArrayBlockingQueue 的平均每跳延迟为 32,757 纳秒。性能分析显示，使用锁和通过条件变量发送信号是 ArrayBlockingQueue 延迟的主要原因。</p><table><thead><tr><th></th><th><strong>Array Blocking Queue (ns)</strong></th><th><strong>Disruptor (ns)</strong></th></tr></thead><tbody><tr><td>最小延迟</td><td>145</td><td>29</td></tr><tr><td>平均延迟</td><td>32,757</td><td>52</td></tr><tr><td>99% 的观测值低于</td><td>2,097,152</td><td>128</td></tr><tr><td>99.99% 的观测值小于</td><td>4,194,304</td><td>8,192</td></tr><tr><td>最大延迟</td><td>5,069,086</td><td>175,567</td></tr></tbody></table><p><img src="/images/disruptor/chapter1/image8.png" alt="image.png"></p><h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p>Disruptor 在提升吞吐量、降低并发执行上下文之间的延迟以及确保可预测的延迟方面迈出了重要一步，而可预测的延迟是许多应用程序中的一个重要考虑因素。我们的测试表明，它的性能优于其他类似的线程间数据交换方法。我们相信，这是此类数据交换中性能最高的机制。通过专注于清晰地分离跨线程数据交换所涉及的关注点，消除写入争用、最大限度地减少读取争用，并确保代码能够与现代处理器使用的缓存良好兼容，我们创建了一种高效的机制，可用于在任何应用程序中的线程间交换数据。</p><p>批处理效应允许消费者在无竞争的情况下处理达到给定阈值的条目，这为高性能系统带来了新的特性。对于大多数系统而言，随着负载和竞争的增加，延迟会呈指数级增长，即典型的“J”曲线。随着 Disruptor 负载的增加，延迟几乎保持平稳，直到内存子系统达到饱和。</p><p>我们相信，Disruptor 为高性能计算设立了新的基准，并且非常适合继续利用处理器和计算机设计的当前趋势。</p><p>资料来源：</p><hr><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnoteref_1"><strong>1.</strong></a>分阶段事件驱动架构 – <a href="https://en.wikipedia.org/wiki/Staged_event-driven_architecture">https://en.wikipedia.org/wiki/Staged_event-driven_architecture</a></p><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnoteref_2"><strong>2.</strong></a>演员模型 – <a href="http://dspace.mit.edu/handle/1721.1/6952">http://dspace.mit.edu/handle/1721.1/6952</a></p><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnoteref_3"><strong>3.</strong></a> Java 内存模型 - <a href="https://jcp.org/en/jsr/detail?id=133">https://jcp.org/en/jsr/detail?id=133</a></p><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnoteref_4"><strong>4.</strong></a> Phasers - <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Phaser.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Phaser.html</a></p><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnoteref_5"><strong>5.</strong></a>值类型 - <a href="https://blogs.oracle.com/jrose/tuples-in-the-vm">https://blogs.oracle.com/jrose/tuples-in-the-vm</a></p><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnoteref_6"><strong>6.</strong></a>利特尔定律 - <a href="https://en.wikipedia.org/wiki/Little%27s_law">https://en.wikipedia.org/wiki/Little%27s_law</a></p><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnoteref_7"><strong>7.</strong></a> ArrayBlockingQueue - <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ArrayBlockingQueue.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ArrayBlockingQueue.html</a></p><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnoteref_8"><strong>8</strong></a> . ConcurrentLinkedQueue - <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html">http://download.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html</a></p>]]></content>
    
    
    <summary type="html">LMAX 的成立旨在打造一个高性能金融交易所。作为我们工作的一部分，我们评估了多种方案去设计这个系统以求达到高性能目标，最后我们发现在传统的解决方案中遇到了基础上的瓶颈。许多应用程序依赖队列在处理阶段之间交换数据。我们的性能测试表明，以这种方式使用队列时，延迟成本与磁盘IO操作（基于RAID或SSD的磁盘系统）的成本处于同一数量级——速度非常慢。如果端到端操作中有多个队列，这将使整体延迟增加数百微秒。这显然存在优化空间。</summary>
    
    
    
    <category term="Disruptor" scheme="https://yuanxw.github.io/categories/Disruptor/"/>
    
    
    <category term="Disruptor" scheme="https://yuanxw.github.io/tags/Disruptor/"/>
    
    <category term="Disruptor并发框架" scheme="https://yuanxw.github.io/tags/Disruptor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(十一)Redis缓存穿透和雪崩</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%8D%81%E4%B8%80)Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%8D%81%E4%B8%80)Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/</id>
    <published>2023-04-10T16:00:00.000Z</published>
    <updated>2025-09-03T16:22:07.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-十一-Redis缓存穿透和雪崩"><a href="#Redis基础入门-十一-Redis缓存穿透和雪崩" class="headerlink" title="Redis基础入门(十一)Redis缓存穿透和雪崩"></a>Redis基础入门(十一)Redis缓存穿透和雪崩</h2><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。<br>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p><p><img src="/images/redis_basics_beginners/chapter11/image.png" alt="Untitled"></p><h3 id="2-缓存穿透（查不到）"><a href="#2-缓存穿透（查不到）" class="headerlink" title="2. 缓存穿透（查不到）"></a>2. 缓存穿透（查不到）</h3><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒<br>杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了——<strong>缓存穿透</strong>。</p><ul><li><p>解决方案</p><ul><li><p>布隆过滤器</p><p>  布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p><p>  <img src="/images/redis_basics_beginners/chapter11/image1.png" alt="Untitled"></p></li><li><p>缓存空对象</p><p>  当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数<br>  据将会从缓存中获取，保护了后端数据源；</p><p>  <img src="/images/redis_basics_beginners/chapter11/image2.png" alt="Untitled"></p></li></ul><p>  但是这种方法会存在两个问题：<br>  1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多<br>  的空值的键；<br>  2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于<br>  需要保持一致性的业务会有影响。</p></li></ul><h3 id="缓存击穿（量太大，缓存过期！）"><a href="#缓存击穿（量太大，缓存过期！）" class="headerlink" title="缓存击穿（量太大，缓存过期！）"></a><strong>缓存击穿（量太大，缓存过期！）</strong></h3><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一<br>个屏障上凿开了一个洞。</p><p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><ul><li><p>设置热点数据永不过期</p><ul><li>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</li></ul></li><li><p>加互斥锁</p><ul><li>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</li></ul><p>  <img src="/images/redis_basics_beginners/chapter11/image3.png" alt="Untitled"></p></li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="/images/redis_basics_beginners/chapter11/image4.png" alt="Untitled"></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就<br>是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><ul><li>解决方案<ul><li><p>redis高可用</p><p>  这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</p></li><li><p>限流降级</p><p>  这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>数据预热</p><p>  数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(十)Redis主从复制</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%8D%81)Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%8D%81)Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2023-04-09T16:00:00.000Z</published>
    <updated>2025-09-03T16:22:02.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-十-Redis主从复制"><a href="#Redis基础入门-十-Redis主从复制" class="headerlink" title="Redis基础入门(十)Redis主从复制"></a>Redis基础入门(十)Redis主从复制</h2><h3 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1. 主从复制"></a>1. 主从复制</h3><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower)；数据的复制是单向的，只能由主节点到从节点。<br>Master以写为主，Slave 以读为主。默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><ul><li>主从复制的作用主要包括：<ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ol></li></ul><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p><ol><li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</li><li>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。<br>对于这种场景，我们可以使如下这种架构：</li></ol><p><img src="/images/redis_basics_beginners/chapter10/image.png" alt="Untitled"></p><p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主<br>二从！<br>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p><h3 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2. 环境配置"></a>2. 环境配置</h3><ul><li>只配置从库，不用配置主库！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication <span class="comment"># 查看当前库的信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色 master</span></span><br><span class="line">connected_slaves:0 <span class="comment"># 没有从机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:b63c90e6c501143759cb0e7f450bd1eb0c70882a</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><ul><li>复制3个配置文件，然后修改对应的信息<ul><li>端口</li><li>pid 名字</li><li>log文件名字</li><li>dump.rdb 名字<br>  修改完毕之后，启动我们的3个redis服务器，可以通过进程信息查看！</li></ul></li></ul><h3 id="3-一主二从配置"><a href="#3-一主二从配置" class="headerlink" title="3. 一主二从配置"></a>3. 一主二从配置</h3><p><strong><code>默认情况下，每台Redis服务器都是主节点</code></strong>； 我们一般情况下只用配置从机就好了！<br>认老大！ 一主 （79）二从（80，81）</p><ul><li>服务器：6380、6381节点，命令：SLAVEOF 127.0.0.1 6379</li><li>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:11</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:14</span><br><span class="line">slave_repl_offset:14</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:b0d63cc54f188f3c8a92cc65e88134759417b18e</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:14</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></table></figure><ul><li>在主机节点：【6379】中查看！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2   <span class="comment"># 多了从机的配置</span></span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=14,lag=1  <span class="comment"># 多了从机的配置</span></span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=14,lag=0  <span class="comment"># 多了从机的配置</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:b0d63cc54f188f3c8a92cc65e88134759417b18e</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:14</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></table></figure><ul><li><p>主从测试</p><p>  主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！</p><p>  主机写：</p><p>  <img src="/images/redis_basics_beginners/chapter10/image1.png" alt="Untitled"></p></li><li><p>从机只能读取内容：</p><p>  <img src="/images/redis_basics_beginners/chapter10/image2.png" alt="Untitled"></p><p>  测试：</p><ul><li>主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</li><li>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！</li></ul></li><li><p>复制原理</p><ul><li>Slave 启动成功连接到 master 后会发送一个sync同步命令。</li><li>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步。但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</li></ul></li><li><p>手动选对主节点</p><p>  如果主机断开了连接，我们可以使用 <strong><code>SLAVEOF no one</code></strong> 让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接（重新设置**<code>SLAVEOF命令</code>**）！</p></li></ul><h3 id="4-哨兵模式"><a href="#4-哨兵模式" class="headerlink" title="4. 哨兵模式"></a>4. 哨兵模式</h3><p>概述：自动选举master的模式</p><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。</p><p>后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。<br>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="/images/redis_basics_beginners/chapter10/image3.png" alt="Untitled"></p><ul><li><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>  然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。<br>  各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p>  <img src="/images/redis_basics_beginners/chapter10/image4.png" alt="Untitled"></p><p>  假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。  </p></li><li><p>测试</p><p>  我们目前的状态是 一主二从！</p><ul><li><p>配置哨兵配置文件 sentinel.conf</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>  后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！</p></li><li><p>启动哨兵</p></li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# ./redis-sentinel config/sentinel.conf </span><br><span class="line">23283:X 12 Jan 2022 07:06:19.119 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">23283:X 12 Jan 2022 07:06:19.119 <span class="comment"># Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=23283, just started</span></span><br><span class="line">23283:X 12 Jan 2022 07:06:19.119 <span class="comment"># Configuration loaded</span></span><br><span class="line">23283:X 12 Jan 2022 07:06:19.121 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._                                             </span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.6 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._                                  </span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 23283</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io       </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |                                  </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>                                       </span><br><span class="line">          `-._        _.-<span class="string">&#x27;                                           </span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span>                                               </span><br><span class="line"></span><br><span class="line">23283:X 12 Jan 2022 07:06:19.122 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">23283:X 12 Jan 2022 07:06:19.122 <span class="comment"># Sentinel ID is 4cc0f01814993b512993fe592448af8fb6590b01</span></span><br><span class="line">23283:X 12 Jan 2022 07:06:19.122 <span class="comment"># +monitor master myredis 127.0.0.1 6379 quorum 1</span></span><br><span class="line">23283:X 12 Jan 2022 07:06:19.123 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379</span><br><span class="line">23283:X 12 Jan 2022 07:06:19.125 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379</span><br></pre></td></tr></table></figure><ul><li>如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）</li></ul><p>  <img src="/images/redis_basics_beginners/chapter10/image5.png" alt="Untitled"></p><p>  <img src="/images/redis_basics_beginners/chapter10/image6.png" alt="Untitled"></p><p>  如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！  </p></li><li><p>优点缺点</p><ul><li>优点<ul><li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li><li>主从可以切换，故障可以转移，系统的可用性就会更好</li><li>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</li></ul></li><li>缺点：<ul><li>Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</li></ul></li></ul></li><li><p>哨兵模式的全部配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line"><span class="built_in">dir</span> /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，</span></span><br><span class="line"><span class="comment"># 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span></span><br><span class="line"><span class="comment"># 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，</span></span><br><span class="line"><span class="comment"># slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line"></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），</span></span><br><span class="line"><span class="comment">#将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信</span></span><br><span class="line"><span class="comment">#息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配</span></span><br><span class="line"><span class="comment">#置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment"># 通知脚本</span></span><br><span class="line"><span class="comment"># shell编程</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="comment"># 一般都是由运维来配置！</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(九)Redis发布订阅</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B9%9D)Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B9%9D)Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</id>
    <published>2023-04-08T16:00:00.000Z</published>
    <updated>2025-09-03T16:16:24.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-九-Redis发布订阅"><a href="#Redis基础入门-九-Redis发布订阅" class="headerlink" title="Redis基础入门(九)Redis发布订阅"></a>Redis基础入门(九)Redis发布订阅</h2><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、微博、关注系统！<br>Redis 客户端可以订阅任意数量的频道。<br>订阅&#x2F;发布消息图：<br>第一个：消息发送者， 第二个：频道 第三个：消息订阅者！</p><p><img src="/images/redis_basics_beginners/chapter9/image.png" alt="Untitled"></p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的</p><p><img src="/images/redis_basics_beginners/chapter9/image1.png" alt="Untitled"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="/images/redis_basics_beginners/chapter9/image2.png" alt="Untitled"></p><ul><li><p>命令</p><ul><li>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。</li></ul><p>  <img src="/images/redis_basics_beginners/chapter9/image3.png" alt="Untitled">  </p></li><li><p>测试</p><ul><li>订阅端</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE peppa <span class="comment"># 订阅一个频道 peppa</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;peppa&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 等待读取推送的信息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 消息</span></span><br><span class="line">2) <span class="string">&quot;peppa&quot;</span> <span class="comment"># 那个频道的消息</span></span><br><span class="line">3) <span class="string">&quot;hello,kuangshen&quot;</span> <span class="comment"># 消息的具体内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;peppa&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello,redis&quot;</span></span><br></pre></td></tr></table></figure><ul><li>发送端：</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH peppa <span class="string">&quot;hello,kuangshen&quot;</span> <span class="comment"># 发布者发布消息到频道！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH peppa <span class="string">&quot;hello,redis&quot;</span> <span class="comment"># 发布者发布消息到频道！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></li><li><p>原理</p><p>  Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。</p><p>  Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。<br>  微信：<br>  通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p><p>  <img src="/images/redis_basics_beginners/chapter9/image4.png" alt="Untitled"></p></li></ul><p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p><p>Pub&#x2F;Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应<br>的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p><ul><li><strong>使用场景</strong><ul><li>实时消息系统！</li><li>事实聊天！（频道当做聊天室，将信息回显给所有人即可！）</li><li>订阅，关注系统都是可以的！<code>稍微复杂的场景我们就会使用 消息中间件</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、微博、关注系统！Redis 客户端可以订阅任意数量的频道。</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(八)Redis持久化</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%85%AB)Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%85%AB)Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2023-04-07T16:00:00.000Z</published>
    <updated>2025-09-03T16:21:03.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-八-Redis持久化"><a href="#Redis基础入门-八-Redis持久化" class="headerlink" title="Redis基础入门(八)Redis持久化"></a>Redis基础入门(八)Redis持久化</h2><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p><h3 id="1-RDB（Redis-DataBase）"><a href="#1-RDB（Redis-DataBase）" class="headerlink" title="1. RDB（Redis DataBase）"></a>1. RDB（Redis DataBase）</h3><ul><li><p><strong>什么是RDB</strong></p><ul><li>在主从复制中，rdb就是备用了！从机上面！</li></ul><p>  <img src="/images/redis_basics_beginners/chapter8/image.png" alt="Untitled"></p><p>  在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。<br>  Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。<br>  这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是<br>  RDB，一般情况下不需要修改这个配置！<br>  有时候在生产环境我们会将这个文件进行备份！<br>  <strong><code>rdb保存的文件是dump.rdb</code></strong> 都是在我们的配置文件中快照中进行配置的！</p><p>  <img src="/images/redis_basics_beginners/chapter8/image1.png" alt="Untitled"></p><p>  <img src="/images/redis_basics_beginners/chapter8/image2.png" alt="Untitled">  </p></li><li><p><strong>触发机制</strong></p><ul><li>save的规则满足的情况下，会自动触发rdb规则</li><li>执行 flushall 命令，也会触发我们的rdb规则！</li><li>退出redis，也会产生 rdb 文件！备份就自动生成一个 dump.rdb</li></ul><p>  <img src="/images/redis_basics_beginners/chapter8/image3.png" alt="Untitled"></p></li><li><p><strong>如果恢复rdb文件</strong></p><ul><li>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</li><li>查看需要存在的位置</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get <span class="built_in">dir</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/bin&quot;</span> <span class="comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure></li><li><p>优点缺点：</p><ul><li>优点：<ul><li>适合大规模的数据恢复！</li><li>对数据的完整性要不高！</li></ul></li><li>缺点：<ul><li>需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！</li><li>fork进程的时候，会占用一定的内容空间！！</li></ul></li></ul></li></ul><h3 id="2-AOF（Append-Only-File）"><a href="#2-AOF（Append-Only-File）" class="headerlink" title="2. AOF（Append Only File）"></a>2. <strong>AOF（Append Only File）</strong></h3><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！</p><ul><li><p><strong>什么是AOF</strong></p><p>  <img src="/images/redis_basics_beginners/chapter8/image4.png" alt="Untitled"></p></li></ul><p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件<br>的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p><strong><code>Aof保存的是 appendonly.aof 文件</code></strong></p><ul><li><p><strong>append</strong></p><p>  <img src="/images/redis_basics_beginners/chapter8/image5.png" alt="Untitled"></p><p>  默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！重启，redis 就可以生效了！<br>  如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件<br>  redis 给我们提供了一个工具：<strong><code>redis-check-aof --fix</code></strong></p><p>  <img src="/images/redis_basics_beginners/chapter8/image6.png" alt="Untitled"></p></li><li><p>重写规则说明</p><ul><li><p>aof 默认就是文件的无限追加，文件会越来越大！，如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，</span></span><br><span class="line">rdb完全够用！</span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># 持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会 sync。消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync，可能会丢失这1s的数据！</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br><span class="line"><span class="comment"># rewrite 重写，</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>优点和缺点</p><ul><li>优点：<ul><li>每一次修改都同步，文件的完整会更加好！</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高的！</li></ul></li><li>缺点：<ul><li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</li><li>Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化！</li></ul></li></ul></li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li><li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重<br>写，使得AOF文件的体积不至于过大。</li><li>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</li><li>同时开启两种持久化方式：<ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有<br>  AOF可能潜在的Bug，留着作为一个万一的手段。</li></ul></li><li>性能建议<ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。</li><li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产<br>  生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重<br>  写可以改到适当的数值。</li><li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时倒掉，会丢失十几分钟的数据，<br>  启动脚本也要比较两个 Master&#x2F;Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(七)Redis.conf详解</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%83)Redis%20conf%E8%AF%A6%E8%A7%A3/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%83)Redis%20conf%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-04-06T16:00:00.000Z</published>
    <updated>2025-09-03T16:22:07.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-七-Redis-conf详解"><a href="#Redis基础入门-七-Redis-conf详解" class="headerlink" title="Redis基础入门(七)Redis.conf详解"></a>Redis基础入门(七)Redis.conf详解</h2><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><ul><li><p><strong>单位</strong></p><ul><li>配置文件 unit单位 对大小写不敏感！</li></ul><p>  <img src="/images/redis_basics_beginners/chapter7/image.png" alt="Untitled"></p></li><li><p><strong>include(包含)</strong></p><ul><li>就是好比我们学习Spring、Improt， include</li></ul><p>  <img src="/images/redis_basics_beginners/chapter7/image1.png" alt="Untitled"></p></li><li><p>NETWORK（网络）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1      <span class="comment"># 绑定的ip</span></span><br><span class="line">protected-mode <span class="built_in">yes</span>  <span class="comment"># 保护模式</span></span><br><span class="line">port 6379           <span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure></li><li><p>GENERAL(通用 )</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span> <span class="comment"># 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！</span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 如果以后台的方式运行，我们就需要指定一个 pid 文件！</span></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably) 生产环境</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice</span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment"># 日志的文件位置名</span></span><br><span class="line">databases 16 <span class="comment"># 数据库的数量，默认是 16 个数据库</span></span><br><span class="line">always-show-logo <span class="built_in">yes</span> <span class="comment"># 是否总是显示LOGO</span></span><br></pre></td></tr></table></figure></li><li><p>SNAPSHOTTING（快照）</p><ul><li>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof。Redis 是内存数据库，如果没有持久化，那么数据断电及失！</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"><span class="comment"># 我们之后学习持久化，会自己定义这个测试！</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span> <span class="comment"># 持久化如果出错，是否还需要继续工作！</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span> <span class="comment"># 是否压缩 rdb 文件，需要消耗一些cpu资源！</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span> <span class="comment"># 保存rdb文件的时候，进行错误的检查校验！</span></span><br><span class="line"><span class="built_in">dir</span> ./ <span class="comment"># rdb 文件保存的目录！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>SECURITY (安全)</strong></p><p>  可以在这里设置redis的密码，默认是没有密码！</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 获取redis的密码</span></span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span> <span class="comment"># 设置redis的密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 发现所有的命令都没有权限了</span></span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456 <span class="comment"># 使用密码进行登录！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>CLIENTS(限制 )</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000 <span class="comment"># 设置能连接上redis的最大客户端的数量</span></span><br><span class="line">maxmemory &lt;bytes&gt; <span class="comment"># redis 配置最大的内存容量</span></span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存到达上限之后的处理策略</span></span><br></pre></td></tr></table></figure><ul><li>内存到达上限之后的处理策略：<ol><li>volatile-lru：  只对设置了过期时间的key进行LRU（默认值）</li><li>allkeys-lru ： 删除lru算法的key</li><li>volatile-random：随机删除即将过期key</li><li>allkeys-random：随机删除</li><li>volatile-ttl ： 删除即将过期的</li><li>noeviction ： 永不过期，返回错误</li></ol></li></ul></li></ul><h3 id="APPEND-ONLY-模式-aof配置"><a href="#APPEND-ONLY-模式-aof配置" class="headerlink" title="APPEND ONLY 模式 aof配置"></a>APPEND ONLY 模式 aof配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ppendonly no <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># 持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会 sync。消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync，可能会丢失这1s的数据！</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Redis基础入门(七)Redis.conf详解</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(六)SpringBoot整合</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%85%AD)SpringBoot%E6%95%B4%E5%90%88/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%85%AD)SpringBoot%E6%95%B4%E5%90%88/</id>
    <published>2023-04-05T16:00:00.000Z</published>
    <updated>2025-09-03T16:21:08.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-六-SpringBoot整合"><a href="#Redis基础入门-六-SpringBoot整合" class="headerlink" title="Redis基础入门(六)SpringBoot整合"></a>Redis基础入门(六)SpringBoot整合</h2><p>SpringBoot 操作数据，添加Spring Data下</p><p>Spring Data:  Spring 的一个子项目。用于简化数据库访问，支持<strong>NoSQL</strong>和<strong>关系数据库存储</strong>。其主要目标是使数据库的访问变得方便快捷。</p><p>Spring Data 项目所支持<strong>NoSQL存储</strong>：</p><ul><li><ul><li>MongoDB（文档数据库）</li></ul></li><li><ul><li>Neo4j （图形数据库）</li></ul></li><li><ul><li>Redis（键&#x2F;值存储）</li></ul></li><li><ul><li>Hbase（列族数据库）</li></ul></li></ul><p>Spring Data 项目所支持的<strong>关系数据存储技术</strong>：</p><ul><li><ul><li>JDBC</li></ul></li><li><p>- <strong>JPA</strong></p></li></ul><h3 id="1-创建Springboot模块"><a href="#1-创建Springboot模块" class="headerlink" title="1. 创建Springboot模块"></a>1. 创建Springboot模块</h3><ul><li>选择创建Module ⇒ Spring Initializr</li></ul><p><img src="/images/redis_basics_beginners/chapter6/image.png" alt="Untitled"></p><ul><li>配置参数及JDK版本</li></ul><p><img src="/images/redis_basics_beginners/chapter6/image1.png" alt="Untitled"></p><ul><li>选择开发工具</li></ul><p><img src="/images/redis_basics_beginners/chapter6/image2.png" alt="Untitled"></p><ul><li>选择存储位置</li></ul><p><img src="/images/redis_basics_beginners/chapter6/image3.png" alt="Untitled"></p><ul><li><p>自动导入依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.peppa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>peppa-springboot-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  <img src="/images/redis_basics_beginners/chapter6/image4.png" alt="Untitled"></p></li><li><p><strong>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</strong></p><p>  jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式<br>  lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式</p></li><li><p>查看自动配置文件：spring-autoconfigure-metadata.properties</p><p>  SpringBoot所有的配置类，都有一个自动配置类，自动配置类都会绑定一个properties配置文件</p><p>  <img src="/images/redis_basics_beginners/chapter6/image5.png" alt="Untitled"></p></li><li><p>源码分析：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span></span><br><span class="line">    <span class="comment">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;</span></span><br><span class="line">RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>  <span class="comment">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(redisConnectionFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置连接</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置redis</span></span><br><span class="line"><span class="string">spring.redis.host=192.168.3.21</span></span><br><span class="line"><span class="string">spring.redis.port=6379</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeppaSpringbootRedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(PeppaSpringbootRedisApplicationTests.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList 操作List 类似List</span></span><br><span class="line">        <span class="comment">// opsForSet</span></span><br><span class="line">        <span class="comment">// opsForHash</span></span><br><span class="line">        <span class="comment">// opsForZSet</span></span><br><span class="line">        <span class="comment">// opsForGeo</span></span><br><span class="line">        <span class="comment">// opsForHyperLogLog</span></span><br><span class="line">        <span class="comment">// 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD</span></span><br><span class="line">        <span class="comment">// 获取redis的连接对象</span></span><br><span class="line">        <span class="comment">// RedisConnection connection =</span></span><br><span class="line">        redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        <span class="comment">// connection.flushDb();</span></span><br><span class="line">        <span class="comment">// connection.flushAll();</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;小猪佩奇&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;mykey===&gt;&#123;&#125;&quot;</span>,redisTemplate.opsForValue().get(<span class="string">&quot;mykey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Redis序列化配置"><a href="#2-Redis序列化配置" class="headerlink" title="2. Redis序列化配置"></a>2. Redis序列化配置</h3><ul><li><p>默认序列化</p><ul><li>Redis模板对象中会使用到的序列化：org.springframework.data.redis.core.RedisTemplate，默认的序列化是JDK</li></ul><p>  <img src="/images/redis_basics_beginners/chapter6/image6.png" alt="Untitled"></p></li><li><p>关于保存对象</p><p>  所有的对象，都需要序列化，不需要的会报如下错误</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObjectToRedisTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;小猪佩奇&quot;</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    logger.info(<span class="string">&quot;user==&gt;&#123;&#125;&quot;</span>,redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/images/redis_basics_beginners/chapter6/image7.png" alt="Untitled"></p></li><li><p><strong>自定义RedisTemplete</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonTypeInfo;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自己定义了一个 RedisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisConnectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>自定义RedisUtil</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key, <span class="type">long</span> time, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> count, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试RedisUtil</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redisUtilTest</span><span class="params">()</span>&#123;</span><br><span class="line">    redisUtil.set(<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;peppa&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;userName===&gt;&#123;&#125;&quot;</span>,redisUtil.get(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/redis_basics_beginners/chapter6/image8.png" alt="Untitled"></p><p><img src="/images/redis_basics_beginners/chapter6/image9.png" alt="Untitled"></p>]]></content>
    
    
    <summary type="html">SpringBoot 操作数据，添加Spring Data下.Spring Data:  Spring 的一个子项目。用于简化数据库访问，支持**NoSQL**和**关系数据库存储**。其主要目标是使数据库的访问变得方便快捷。</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(五)Java连接开发工具Jedis</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%BA%94)Java%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Jedis/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%BA%94)Java%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Jedis/</id>
    <published>2023-04-04T16:00:00.000Z</published>
    <updated>2025-09-03T16:20:59.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-五-Java连接开发工具Jedis"><a href="#Redis基础入门-五-Java连接开发工具Jedis" class="headerlink" title="Redis基础入门(五)Java连接开发工具Jedis"></a>Redis基础入门(五)Java连接开发工具Jedis</h2><p>什么是Jedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用java操作redis，那么一定要对Jedis 十分的熟悉！</p><h3 id="1-新建Jedis项目"><a href="#1-新建Jedis项目" class="headerlink" title="1. 新建Jedis项目"></a>1. 新建Jedis项目</h3><p>创建<strong>peppa-jedis</strong>，引用相关jar包</p><p><img src="/images/redis_basics_beginners/chapter5/image.png" alt="Untitled"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jedis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.79<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- junit --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--slf4j --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0-alpha5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- logback --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0-alpha12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0-alpha12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-access<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0-alpha12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-PingTest测试连接"><a href="#2-PingTest测试连接" class="headerlink" title="2. PingTest测试连接"></a>2. PingTest测试连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PingTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger= LoggerFactory.getLogger(PingTest.class);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.3.21&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.ping()==&gt;&#123;&#125;&quot;</span>,jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-StringTest字符"><a href="#3-StringTest字符" class="headerlink" title="3. StringTest字符"></a>3. StringTest字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.omg.CORBA.PUBLIC_MEMBER;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(StringTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">key</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.3.21&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;按索引查询：&#123;&#125;&quot;</span>, jedis.select(<span class="number">0</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;清空数据：&#123;&#125;&quot;</span>, jedis.flushDB());</span><br><span class="line">        logger.info(<span class="string">&quot;判断某个键是否存在：&#123;&#125;&quot;</span>, jedis.exists(<span class="string">&quot;username&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;peppa&#x27;&gt;的键值对：&#123;&#125;&quot;</span>, jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;peppa&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&#123;&#125;&quot;</span>, jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span> ));</span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;系统中所有的键如下：&#123;&#125;&quot;</span>, Arrays.toString(keys.toArray()));</span><br><span class="line">        logger.info(<span class="string">&quot;删除键password:&#123;&#125;&quot;</span>, jedis.del(<span class="string">&quot;password&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;判断键password是否存在：&#123;&#125;&quot;</span>, jedis.exists(<span class="string">&quot;password&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;查看键username所存储的值的类型:&#123;&#125;&quot;</span>, jedis.type(<span class="string">&quot;username&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;随机返回key空间的一个：&#123;&#125;&quot;</span>, jedis.randomKey());</span><br><span class="line">        logger.info(<span class="string">&quot;重命名key：&#123;&#125;&quot;</span>, jedis.rename(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;name&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;取出改后的name：&#123;&#125;&quot;</span>, jedis.get(<span class="string">&quot;name&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;删除当前选择数据库中的所有：&#123;&#125;&quot;</span>, jedis.flushDB());</span><br><span class="line">        logger.info(<span class="string">&quot;返回当前数据库中key的数目：&#123;&#125;&quot;</span>, jedis.dbSize());</span><br><span class="line">        logger.info(<span class="string">&quot;删除所有数据库中的所有key：&#123;&#125;&quot;</span>, jedis.flushAll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">str</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.3.21&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        logger.info(<span class="string">&quot;==========增加数据=========&quot;</span> );</span><br><span class="line">        logger.info(jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;valuel&quot;</span> ));</span><br><span class="line">        logger.info(jedis.set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span> ));</span><br><span class="line">        logger.info(jedis.set(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;删除键key2:&#123;&#125;&quot;</span>, jedis.del(<span class="string">&quot;key2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;获取键key2:&#123;&#125;&quot;</span>, jedis.get(<span class="string">&quot;key2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;修改key:&#123;&#125;&quot;</span>, jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;valueChanged&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;获取key1的值：&#123;&#125;&quot;</span>, jedis.get(<span class="string">&quot;key1&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;在key3后面加入值：&#123;&#125;&quot;</span>, jedis.append(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;End&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;key3的值：&quot;</span> + jedis.get(<span class="string">&quot;key3&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;增加多个键值对：&#123;&#125;&quot;</span>, jedis.mset(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;value02&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;value02&quot;</span>, <span class="string">&quot;key03&quot;</span>, <span class="string">&quot;value03&quot;</span>, <span class="string">&quot;key04&quot;</span>, <span class="string">&quot;value04&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;获取多个键值对：&#123;&#125;&quot;</span>, jedis.mget(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;key03&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;获取多个键值对：&#123;&#125;&quot;</span>, jedis.mget(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;key03&quot;</span>, <span class="string">&quot;key04&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;删除多个键值对：&#123;&#125;&quot;</span>, jedis.del(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;获取多个键值对：&#123;&#125;&quot;</span>, jedis.mget(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;key03&quot;</span> ));</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        logger.info(<span class="string">&quot;===========新增键值对防止覆盖筛先值=============&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.setnx():&#123;&#125;&quot;</span>, jedis.setnx(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.setnx():&#123;&#125;&quot;</span>, jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.setnx():&#123;&#125;&quot;</span>, jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2-new&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.get():&#123;&#125;&quot;</span>, jedis.get(<span class="string">&quot;key1&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.get():&#123;&#125;&quot;</span>, jedis.get(<span class="string">&quot;key2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;=======新增键值对并设置有效时间=====&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.setex():&#123;&#125;&quot;</span>, jedis.setex(<span class="string">&quot;key3&quot;</span>, <span class="number">2</span>, <span class="string">&quot;value3&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.get(key3):&#123;&#125;&quot;</span>, jedis.get(<span class="string">&quot;key3&quot;</span> ));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.get(key3):&#123;&#125;&quot;</span>, jedis.get(<span class="string">&quot;key3&quot;</span> ));</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;===========获取原值，更新为新值===========&quot;</span> );</span><br><span class="line">        logger.info(jedis.getSet(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key2GetSet&quot;</span> ));</span><br><span class="line">        logger.info(jedis.get(<span class="string">&quot;key2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;获得key2的值的字串：&#123;&#125;&quot;</span>, jedis.getrange(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-ListTest列表"><a href="#4-ListTest列表" class="headerlink" title="4. ListTest列表"></a>4. <strong>ListTest列表</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ListTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        logger.info(<span class="string">&quot;=======添加一个1ist===========&quot;</span> );</span><br><span class="line">        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;ArrayList&quot;</span>, <span class="string">&quot;Vector&quot;</span>, <span class="string">&quot;Stack&quot;</span>, <span class="string">&quot;HashMap&quot;</span>, <span class="string">&quot;WeakHashMap&quot;</span>, <span class="string">&quot;LinkedHashMap&quot;</span> );</span><br><span class="line">        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;HashSet&quot;</span> );</span><br><span class="line">        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;TreeSet&quot;</span> );</span><br><span class="line">        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;TreeMap&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;collections的内容：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>)); <span class="comment">//-1代表倒数第一个元素，-2代表倒数第二个元素</span></span><br><span class="line">        logger.info(<span class="string">&quot;collections区间0-3的元素：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;=================================&quot;</span> );</span><br><span class="line">        <span class="comment">// 删除列表指定的值，第二个参数的个数（有重复时），后add进去的值先被删，类似于出栈</span></span><br><span class="line">        logger.info(<span class="string">&quot;删除指定元素个数：&#123;&#125;&quot;</span> ,jedis.lrem(<span class="string">&quot;collections&quot;</span>, <span class="number">2</span>, <span class="string">&quot;HashMap&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;collections的内容：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;删除下表0-3区间之外的元素：&#123;&#125;&quot;</span> ,jedis.ltrim(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;collections的内容：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;collections列表出栈（左端）：&#123;&#125;&quot;</span> ,jedis.lpop(<span class="string">&quot;collections&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;collections的内容：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;collections添加元素，从列表右端，与1push相对应：&#123;&#125;&quot;</span> ,jedis.rpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;EnumMap&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;collections的内容：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;collections3列表出栈（右端）：&#123;&#125;&quot;</span> ,jedis.rpop(<span class="string">&quot;collections&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;collections的内容：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;修改collections指定下标1的内容：&#123;&#125;&quot;</span> ,jedis.lset(<span class="string">&quot;collections&quot;</span>, <span class="number">1</span>, <span class="string">&quot;LinkedArrayList&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;collections的内容：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;=================================&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;collections的长度：&#123;&#125;&quot;</span> ,jedis.llen(<span class="string">&quot;collections&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;获取collections下标为2的元素：&#123;&#125;&quot;</span> ,jedis.lindex(<span class="string">&quot;collections&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;=================================&quot;</span> );</span><br><span class="line">        jedis.lpush(<span class="string">&quot;sortedList&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;4&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;sortedList排序前：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;sortedList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.sort():&#123;&#125;&quot;</span>,jedis.sort(<span class="string">&quot;sortedList&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;sortedList排序后：&#123;&#125;&quot;</span> ,jedis.lrange(<span class="string">&quot;sortedList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-SetTest集合"><a href="#5-SetTest集合" class="headerlink" title="5. SetTest集合"></a>5. SetTest集合</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.peppa;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class SetTest &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(SetTest.class);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">set</span></span>() &#123;</span><br><span class="line">        Jedis jedis = new Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, 6379);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        logger.info(<span class="string">&quot;================向集合中添加元素（不重复）============&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.sadd():&#123;&#125;&quot;</span>,jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e0&quot;</span>, <span class="string">&quot;e8&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e5&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.sadd():&#123;&#125;&quot;</span>,jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e6&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.sadd():&#123;&#125;&quot;</span>,jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e6&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet的所有元素为：&#123;&#125;&quot;</span> ,jedis.smembers(<span class="string">&quot;eleSet&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;删除一个元素e0：&#123;&#125;&quot;</span> ,jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e0&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet的所有元素为：&#123;&#125;&quot;</span> ,jedis.smembers(<span class="string">&quot;eleSet&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;删除两个元素e7和e6：&#123;&#125;&quot;</span> ,jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e6&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet的所有元素为：&#123;&#125;&quot;</span> ,jedis.smembers(<span class="string">&quot;eleSet&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;随机的移除集合中的一个元素：&#123;&#125;&quot;</span> ,jedis.spop(<span class="string">&quot;eleSet&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;随机的移除集合中的一个元素：&#123;&#125;&quot;</span> ,jedis.spop(<span class="string">&quot;eleSet&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet的所有元素为：&#123;&#125;&quot;</span> ,jedis.smembers(<span class="string">&quot;eleSet&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet中包含元素的个数：&#123;&#125;&quot;</span> ,jedis.scard(<span class="string">&quot;eleSet&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;e3是否在eleSet中：&#123;&#125;&quot;</span> ,jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e3&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;e1是否在eleSet中：&#123;&#125;&quot;</span> ,jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;e1是否在eleSet中：&#123;&#125;&quot;</span> ,jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e5&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;=============================&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.sadd():&#123;&#125;&quot;</span>,jedis.sadd(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e0&quot;</span>, <span class="string">&quot;e8&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e5&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;jedis.sadd():&#123;&#125;&quot;</span>,jedis.sadd(<span class="string">&quot;eleSet2&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e0&quot;</span>, <span class="string">&quot;e8&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;将eleSet1中删除e1并存入eleSet3中：&#123;&#125;&quot;</span> ,jedis.smove(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet3&quot;</span>, <span class="string">&quot;el&quot;</span> ));//移到集合元素 </span><br><span class="line">        logger.info(<span class="string">&quot;将eleSet1中删除e2并存入eleSet3中：&#123;&#125;&quot;</span> ,jedis.smove(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet3&quot;</span>, <span class="string">&quot;e2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet1中的元素：&#123;&#125;&quot;</span> ,jedis.smembers(<span class="string">&quot;eleSet1&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet3中的元素：&#123;&#125;&quot;</span> ,jedis.smembers(<span class="string">&quot;eleSet3&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;=================集合运算================&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet1中的元素：&#123;&#125;&quot;</span> ,jedis.smembers(<span class="string">&quot;eleSet1&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet2中的元素：&#123;&#125;&quot;</span> ,jedis.smembers(<span class="string">&quot;eleSet2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet1和eleSet2的交集：&#123;&#125;&quot;</span> ,jedis.sinter(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet1和eleSet2的并集：&#123;&#125;&quot;</span> ,jedis.sunion(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet1和eleSet2的差集:&quot;</span> + jedis.sdiff(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span> ));//eLeSet1中有，eLeSet2中没有</span><br><span class="line">        jedis.sinterstore( <span class="string">&quot;eleSet4&quot;</span>, <span class="string">&quot;eleSet1&quot;</span>,<span class="string">&quot;eleSet2&quot;</span>);//求交集并将交集保</span><br><span class="line">        logger.info(<span class="string">&quot;eleSet4中的元素：&#123;&#125;&quot;</span>,jedis.smembers(<span class="string">&quot;eleSet4&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-TestHash"><a href="#6-TestHash" class="headerlink" title="6. TestHash"></a>6. TestHash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHash</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ListTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span> );</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span> );</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span> );</span><br><span class="line">        map.put(<span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span> );</span><br><span class="line">        <span class="comment">//添加名称为hash（key）的hash元素</span></span><br><span class="line">        jedis.hmset(<span class="string">&quot;hash&quot;</span>, map);</span><br><span class="line">        <span class="comment">//名称为hash的hash中添加Rey 为key5，vaLue为vatue5元素</span></span><br><span class="line">        jedis.hset(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span> );</span><br><span class="line">        logger.info(<span class="string">&quot;散列hash的所有键值对为：&#123;&#125;&quot;</span> ,jedis.hgetAll(<span class="string">&quot;hash&quot;</span> )); <span class="comment">//return Map&lt;s</span></span><br><span class="line">        logger.info(<span class="string">&quot;散列hash的所有键为：&#123;&#125;&quot;</span> ,jedis.hkeys(<span class="string">&quot;hash&quot;</span> )); <span class="comment">//return Set&lt;String&gt;</span></span><br><span class="line">        logger.info(<span class="string">&quot;散列hash的所有值为：&#123;&#125;&quot;</span> ,jedis.hvals(<span class="string">&quot;hash&quot;</span> )); <span class="comment">//return List&lt;String</span></span><br><span class="line">        logger.info(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&#123;&#125;&quot;</span> ,jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">5</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;散列hash的所有键值对为：&#123;&#125;&quot;</span> ,jedis.hgetAll(<span class="string">&quot;hash&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&#123;&#125;&quot;</span> ,jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;散列hash的所有键值对为：&#123;&#125;&quot;</span> ,jedis.hgetAll(<span class="string">&quot;hash&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;删除一个或者多个键值对：&#123;&#125;&quot;</span> ,jedis.hdel(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;散列hash的所有键值对为：&#123;&#125;&quot;</span> ,jedis.hgetAll(<span class="string">&quot;hash&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;散列hash中键值对的个数： &quot;</span> + jedis.hlen(<span class="string">&quot;hash&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;判断hash中是否存在key2：&#123;&#125;&quot;</span> ,jedis.hexists(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;判断hash中是否存在key3：&#123;&#125;&quot;</span> ,jedis.hexists(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key3&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;获取hash中的值：&#123;&#125;&quot;</span> ,jedis.hmget(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key3&quot;</span> ));</span><br><span class="line">        logger.info(<span class="string">&quot;获取hash中的值：&#123;&#125;&quot;</span> ,jedis.hmget(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;key4&quot;</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-TransactionTest（事务）"><a href="#7-TransactionTest（事务）" class="headerlink" title="7. TransactionTest（事务）"></a>7. TransactionTest（事务）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peppa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ListTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transaction</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line"></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> jsonObject.toJSONString();</span><br><span class="line">        multi.set(<span class="string">&quot;user1&quot;</span>,jsonStr);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 代码抛出异常，执行失败</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 执行事务</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            logger.error(ex.getMessage(),ex);</span><br><span class="line">            multi.discard(); <span class="comment">// 放弃事务</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            jedis.close();</span><br><span class="line">            logger.info(<span class="string">&quot;jsonStr:&#123;&#125;&quot;</span>,jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">什么是Jedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用java操作redis，那么一定要对Jedis 十分的熟悉！</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(四)Redis 事务操作</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%9B%9B)Redis%20%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%9B%9B)Redis%20%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/</id>
    <published>2023-04-03T16:00:00.000Z</published>
    <updated>2025-09-03T16:21:12.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-四-Redis-事务操作"><a href="#Redis基础入门-四-Redis-事务操作" class="headerlink" title="Redis基础入门(四)Redis 事务操作"></a>Redis基础入门(四)Redis 事务操作</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h3><p>Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！<br>一次性、顺序性、排他性！执行一些列的命令！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">----- 队列 <span class="built_in">set</span> <span class="built_in">set</span> <span class="built_in">set</span> 执行----—</span><br></pre></td></tr></table></figure><p><strong>Redis事务没有没有隔离级别的概念！</strong><br>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec<br><strong>Redis单条命令式保存原子性的，但是事务不保证原子性！</strong></p><ul><li><p><strong>Redis的事务：</strong></p><ul><li>开启事务（multi）</li><li>命令入队（……）</li><li>执行事务（exec）</li></ul></li><li><p><strong>正常执行事务</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure><ul><li><strong>放弃事务</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD <span class="comment"># 取消事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4 <span class="comment"># 事务队列中命令都不会被执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ul><li><strong>编译型异常</strong>（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k3 <span class="comment"># 错误的命令</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务报错！</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k5 <span class="comment"># 所有的命令都不会被执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ul><li>运行时异常（1&#x2F;0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">&quot;v1&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr k1 <span class="comment"># 会执行的时候失败！</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range <span class="comment"># 虽然第一条命令报错了，但是依旧正常执行成功了！</span></span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line"><span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>监控！ Watch （面试常问！）</strong></p><ol><li><strong>悲观锁：</strong><code>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</code></li><li><strong>乐观锁：</strong></li></ol><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否有人修改过这个数据，</li><li>获取version</li><li>更新的时候比较 version</li></ul></li><li><p><strong>Redis测监视测试</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视 money 对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">**127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><ul><li>测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视 money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ul><li>如果修改失败，获取最新的值就好</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; UNWATCH</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 70</span><br><span class="line">2) (<span class="built_in">integer</span>) 30</span><br></pre></td></tr></table></figure><p><img src="/images/redis_basics_beginners/chapter4/image.png" alt="Untitled"></p>]]></content>
    
    
    <summary type="html">Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！一次性、顺序性、排他性！执行一些列的命令！</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(三)三种特殊数据类型</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%89)%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%89)%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-04-02T16:00:00.000Z</published>
    <updated>2025-09-03T16:22:07.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-三-三种特殊数据类型"><a href="#Redis基础入门-三-三种特殊数据类型" class="headerlink" title="Redis基础入门(三)三种特殊数据类型"></a>Redis基础入门(三)三种特殊数据类型</h2><h3 id="1-Geospatial-地理位置"><a href="#1-Geospatial-地理位置" class="headerlink" title="1. Geospatial 地理位置"></a>1. Geospatial 地理位置</h3><ul><li><p>朋友的定位，附近的人，打车距离计算？</p><ul><li>Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！可以查询一些测试数据：<a href="http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/">http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/</a></li></ul><p>  <img src="/Untitled.png" alt="Untitled"></p></li></ul><p>官方文档：<a href="https://www.redis.net.cn/order/3685.html">https://www.redis.net.cn/order/3685.html</a></p><ul><li><strong>getadd 添加地理位置</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># getadd 添加地理位置</span></span><br><span class="line"><span class="comment"># 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！</span></span><br><span class="line"><span class="comment"># 有效的经度从-180度到180度。</span></span><br><span class="line"><span class="comment"># 有效的纬度从-85.05112878度到85.05112878度。</span></span><br><span class="line"><span class="comment"># 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijin</span></span><br><span class="line">(error) ERR invalid longitude,latitude pair 39.900000,116.400000</span><br><span class="line"><span class="comment"># 参数 key 值（）</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shengzhen</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><ul><li><strong>getpos获得当前定位：一定是一个坐标值！</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing <span class="comment"># 获取指定的城市的经度和纬度！</span></span><br><span class="line">1) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing chongqing</span><br><span class="line">1) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>GEODIST 两人之间的距离</strong></p><ul><li>单位：<br>  m 表示单位为米。<br>  km 表示单位为千米。<br>  mi 表示单位为英里。<br>  ft 表示单位为英尺。</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km <span class="comment"># 查看上海到北京的直线距离</span></span><br><span class="line"><span class="string">&quot;1067.3788&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing chongqing km <span class="comment"># 查看重庆到北京的直线距离</span></span><br><span class="line"><span class="string">&quot;1464.0708&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>georadius 以给定的经纬度为中心， 找出某一半径内的元素</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km <span class="comment"># 以110，30 这个经纬度为中心，寻找方圆1000km内的城市</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shengzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist <span class="comment"># 显示到中间距离的位置</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord <span class="comment"># 显示他人的定位信息</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 1 <span class="comment"># 筛选出指定的结果！</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 2</span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>GEORADIUSBYMEMBER  找出位于指定元素周围的其他元素！</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km</span><br><span class="line">1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km</span><br><span class="line">1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">2) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash china:city beijing chongqing <span class="comment"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！</span></span><br><span class="line">1) <span class="string">&quot;wx4fbxxfke0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wm5xzrybty0&quot;</span></span><br></pre></td></tr></table></figure><ul><li>GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE china:city 0 -1 <span class="comment"># 查看地图中全部的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shengzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">6) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing <span class="comment"># 移除指定元素！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shengzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><ul><li><strong>什么是基数？</strong></li></ul><p>基数（不重复的元素） &#x3D; 5，可以接受误差！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A &#123;1,3,5,7,8,7&#125;</span><br><span class="line">B &#123;1,3,5,7,8&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>简介</strong></p><p>  Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！<br>  Redis Hyperloglog 基数统计的算法！</p></li><li><p><strong>网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</strong></p><p>  传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !<br>  这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；<br>  0.81% 错误率！ 统计UV任务，可以忽略不计的！</p><ul><li><p>测试使用</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j <span class="comment"># 创建第一组元素 mykey</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey <span class="comment"># 统计 mykey 元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m <span class="comment"># 创建第二组元素 mykey2</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey2</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2 <span class="comment"># 合并两组 mykey mykey2 =&gt; mykey3 并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey3 <span class="comment"># 看并集的数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br></pre></td></tr></table></figure></li></ul><p>  如果允许容错，那么一定可以使用 Hyperloglog ！<br>  如果不允许容错，就使用 set 或者自己的数据类型即可！</p></li></ul><h3 id="Bitmap-位存储"><a href="#Bitmap-位存储" class="headerlink" title="Bitmap 位存储"></a>Bitmap 位存储</h3><p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用<br>Bitmaps！<br>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！<br>365 天 &#x3D; 365 bit 1字节 &#x3D; 8bit 46 个字节左右！</p><ul><li><strong>使用bitmap 来记录 周一到周日的打卡！</strong><br>周一：1 周二：0 周三：0 周四：1 ……</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3 <span class="comment"># 查看某一天是否有打卡！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount sign <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">朋友的定位，附近的人，打车距离计算？Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！可以查询一些测试数据</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门(二)五大数据类型</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%BA%8C)%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%BA%8C)%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-04-01T16:00:00.000Z</published>
    <updated>2025-09-03T16:17:04.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础入门-二-五大数据类型"><a href="#Redis基础入门-二-五大数据类型" class="headerlink" title="Redis基础入门(二)五大数据类型"></a>Redis基础入门(二)五大数据类型</h2><h3 id="1-官网文档"><a href="#1-官网文档" class="headerlink" title="1. 官网文档"></a>1. 官网文档</h3><p><img src="/images/redis_basics_beginners/chapter2/image.png" alt="Untitled"></p><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p><h3 id="2-Redis-Key"><a href="#2-Redis-Key" class="headerlink" title="2. Redis-Key"></a>2. Redis-Key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看所有的key</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name     yuanxw <span class="comment"># set key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name <span class="comment"># 判断当前的key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; move name 1 <span class="comment"># 移除当前的key</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name beijing</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; EXPIRE name 10 <span class="comment"># 设置key的过期时间，单位是秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name <span class="comment"># 查看当前key的剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name <span class="comment"># 查看当前key的一个类型！</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> age</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>后面如果遇到不会的命令，可以在官网查看帮助文档！</p><p><img src="/images/redis_basics_beginners/chapter2/image1.png" alt="Untitled"></p><h3 id="3-String（字符串）"><a href="#3-String（字符串）" class="headerlink" title="3. String（字符串）"></a>3. String（字符串）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 v1 <span class="comment"># 设置值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1 <span class="comment"># 获得值</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 获得所有的key</span></span><br><span class="line">1) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS key1 <span class="comment"># 判断某一个key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 <span class="string">&quot;hello&quot;</span> <span class="comment"># 追加字符串，如果当前key不存在，就相当于setkey</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1 <span class="comment"># 获取字符串的长度！</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 <span class="string">&quot;,peppa&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1hello,peppa&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment"># i++</span></span><br><span class="line"><span class="comment"># 步长 i+=</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0 <span class="comment"># 初始浏览量为0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views <span class="comment"># 自增1 浏览量变为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr views <span class="comment"># 自减1 浏览量-1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;-1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY views 10 <span class="comment"># 可以设置步长，指定增量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; INCRBY views 10</span><br><span class="line">(<span class="built_in">integer</span>) 19</span><br><span class="line">127.0.0.1:6379&gt; DECRBY views 5</span><br><span class="line"></span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment"># 字符串范围 range</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 <span class="string">&quot;hello,peppa&quot;</span> <span class="comment"># 设置 key1 的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;hello,peppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 3 <span class="comment"># 截取字符串 [0,3]</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 -1 <span class="comment"># 获取全部的字符串 和 get key是一样的</span></span><br><span class="line"><span class="string">&quot;hello,peppa&quot;</span></span><br><span class="line"><span class="comment"># 替换！</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 abcdefg</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SETRANGE key2 1 xx <span class="comment"># 替换指定位置开始的字符串！</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;axxdefg&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment"># setex (set with expire) # 设置过期时间</span></span><br><span class="line"><span class="comment"># setnx (set if not exist) # 不存在在设置 （在分布式锁中会常常使用！）</span></span><br><span class="line">127.0.0.1:6379&gt; setex key3 30 <span class="string">&quot;hello&quot;</span> <span class="comment"># 设置key3 的值为 hello,30秒后过期</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) 26</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;redis&quot;</span> <span class="comment"># 如果mykey 不存在，创建mykey</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;key2&quot;</span></span><br><span class="line">2) <span class="string">&quot;mykey&quot;</span></span><br><span class="line">3) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;MongoDB&quot;</span> <span class="comment"># 如果mykey存在，创建失败！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">mset</span><br><span class="line">mget</span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 <span class="comment"># 同时设置多个值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 <span class="comment"># 同时获取多个值</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 <span class="comment"># msetnx 是一个原子性的操作，要么一起成功，要么一起失败！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="built_in">set</span> user:1 &#123;name:zhangsan,age:3&#125; <span class="comment"># 设置一个user:1 对象 值为 json字符来保存一个对象！</span></span><br><span class="line"><span class="comment"># 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">getset <span class="comment"># 先get然后在set</span></span><br><span class="line">127.0.0.1:6379&gt; getset db redis <span class="comment"># 如果不存在值，则返回 nil</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb <span class="comment"># 如果存在值，获取原来的值，并设置新的值</span></span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;mongodb&quot;</span></span><br></pre></td></tr></table></figure><p>数据结构是相同的！<br>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存存储！</li></ul><p><strong>List（列表）</strong><br>基本的数据类型：列表</p><p>在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！所有的list命令都是用l开头的，Redis不区分大小命令</p><p><img src="/images/redis_basics_beginners/chapter2/image2.png" alt="Untitled"></p><p>在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！所有的list命令都是用l开头的，Redis不区分大小命令</p><p><img src="/images/redis_basics_beginners/chapter2/image3.png" alt="Untitled"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one <span class="comment"># 将一个值或者多个值，插入到列表头部 （左）</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1 <span class="comment"># 获取list中值！</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 1 <span class="comment"># 通过区间获取具体的值！</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Rpush list righr <span class="comment"># 将一个值或者多个值，插入到列表位部 （右）</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;righr&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">LPOP</span><br><span class="line">RPOP</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;righr&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lpop list <span class="comment"># 移除list的第一个元素</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Rpop list <span class="comment"># 移除list的最后一个元素</span></span><br><span class="line"><span class="string">&quot;righr&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">Lindex</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 1 <span class="comment"># 通过下标获得 list 中的某一个值！</span></span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0</span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">Llen</span><br><span class="line">127.0.0.1:6379&gt; Lpush list one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; Lpush list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; Lpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; Llen list <span class="comment"># 返回列表的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; Lpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">移除指定的值！</span><br><span class="line">取关 uid</span><br><span class="line">Lrem</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 one <span class="comment"># 移除list集合中指定个数的value，精确匹配</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 three</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">trim 修剪；list 截断!</span><br><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">&quot;hello1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">&quot;hello2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2 <span class="comment"># 通过下标截取指定的长度，这个list已经被改变了，截断了</span></span><br><span class="line">只剩下截取的元素！</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello2&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">rpoplpush <span class="comment"># 移除列表的最后一个元素，将他移动到新的列表中！</span></span><br><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myotherlist <span class="comment"># 移除列表的最后一个元素，将他移动到新的列表中！</span></span><br><span class="line"><span class="string">&quot;hello2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1 <span class="comment"># 查看原来的列表</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myotherlist 0 -1 <span class="comment"># 查看目标列表中，确实存在改值！</span></span><br><span class="line">1) <span class="string">&quot;hello2&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">lset 将列表中指定下标的值替换为另外一个值，更新操作</span><br><span class="line">127.0.0.1:6379&gt; EXISTS list <span class="comment"># 判断这个列表是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item <span class="comment"># 如果不存在列表我们去更新就会报错</span></span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list value1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 0</span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item <span class="comment"># 如果存在，更新当前下标的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 0</span><br><span class="line">1) <span class="string">&quot;item&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 1 other <span class="comment"># 如果不存在，则会报错！</span></span><br><span class="line">(error) ERR index out of range</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">linsert <span class="comment"># 将某个具体的value插入到列把你中某个元素的前面或者后面！</span></span><br><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist before <span class="string">&quot;world&quot;</span> <span class="string">&quot;other&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;other&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after world new</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;other&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">4) <span class="string">&quot;new&quot;</span></span><br></pre></td></tr></table></figure><p>小结：</p><ul><li>list实际上是一个链表，before Node after ， left，right 都可以插入值。</li><li>如果key 不存在，创建新的链表。如果key存在，新增内容</li><li>如果key存在，新增内容</li><li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</li><li>消息排队！消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）！</li></ul><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>set中的值是不能重读的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span> <span class="comment"># set集合中添加匀速</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;peppa&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;lovepeppa&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset <span class="comment"># 查看指定set的所有值</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;lovepeppa&quot;</span></span><br><span class="line">3) <span class="string">&quot;peppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hello <span class="comment"># 判断某一个值是不是在set集合中！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset world</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; scard myset <span class="comment"># 获取set集合中的内容元素个数！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">rem</span><br><span class="line">127.0.0.1:6379&gt; srem myset hello <span class="comment"># 移除set集合中的指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">2) <span class="string">&quot;lovepeppa&quot;</span></span><br><span class="line">3) <span class="string">&quot;peppa&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="built_in">set</span> 无序不重复集合。抽随机！</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;lovepeppa2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;lovepeppa2&quot;</span></span><br><span class="line">2) <span class="string">&quot;peppa&quot;</span></span><br><span class="line">3) <span class="string">&quot;lovepeppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset <span class="comment"># 随机抽选出一个元素</span></span><br><span class="line"><span class="string">&quot;peppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;peppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;peppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;peppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2 <span class="comment"># 随机抽选出指定个数的元素</span></span><br><span class="line">1) <span class="string">&quot;lovepeppa&quot;</span></span><br><span class="line">2) <span class="string">&quot;lovepeppa2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class="line">1) <span class="string">&quot;lovepeppa&quot;</span></span><br><span class="line">2) <span class="string">&quot;lovepeppa2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset <span class="comment"># 随机抽选出一个元素</span></span><br><span class="line"><span class="string">&quot;lovepeppa2&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">删除定的key，随机删除key！</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;lovepeppa2&quot;</span></span><br><span class="line">2) <span class="string">&quot;lovepeppa&quot;</span></span><br><span class="line">3) <span class="string">&quot;peppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset <span class="comment"># 随机删除一些set集合中的元素！</span></span><br><span class="line"><span class="string">&quot;lovepeppa2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;lovepeppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;peppa&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">将一个指定的值，移动到另外一个<span class="built_in">set</span>集合！</span><br><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;peppa&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 <span class="string">&quot;set2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 <span class="string">&quot;peppa&quot;</span> <span class="comment"># 将一个指定的值，移动到另外一个set集合！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) <span class="string">&quot;peppa&quot;</span></span><br><span class="line">2) <span class="string">&quot;set2&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">微博，微信朋友圈，共同关注！(并集)</span><br><span class="line">数字集合类：</span><br><span class="line">- 差集 SDIFF</span><br><span class="line">- 交集</span><br><span class="line">- 并集</span><br><span class="line">127.0.0.1:6379&gt; FLUSHALL</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 a  b c </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 c  d  e </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; SDIFF key1 key2 <span class="comment"># 差集</span></span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER key1 key2 <span class="comment"># 交集 共同好友就可以这样实现</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION key1 key2 <span class="comment"># 并集</span></span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;e&quot;</span></span><br><span class="line">4) <span class="string">&quot;a&quot;</span></span><br><span class="line">5) <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure><p>微博，A用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！<br>共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）</p><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的<br>key-vlaue！<br>set myhash field peppa</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hset myhash field1 peppa <span class="comment"># set一个具体 key-vlaue</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1 <span class="comment"># 获取一个字段值</span></span><br><span class="line"><span class="string">&quot;peppa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world <span class="comment"># set多个 key-vlaue</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2 <span class="comment"># 获取多个字段值</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash <span class="comment"># 获取全部的数据，</span></span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field1 <span class="comment"># 删除hash指定key字段！对应的value值也就消失了！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">hlen</span><br><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash</span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;field1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash <span class="comment"># 获取hash表的字段数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field1 <span class="comment"># 判断hash中指定字段是否存在！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment"># 只获得所有field</span></span><br><span class="line"><span class="comment"># 只获得所有value</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash <span class="comment"># 只获得所有field</span></span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;field1&quot;</span></span><br></pre></td></tr></table></figure><p>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的<br>存储，String更加适合字符串存储！</p><h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h3><p>在set的基础上，增加了一个值，set k1 v1 zset k1 score1 v1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">27.0.0.1:6379&gt; zadd myset 1 one <span class="comment"># 添加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two 3 three <span class="comment"># 添加多个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">排序如何实现</span><br><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 zhangsan <span class="comment"># 添加三个用户</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 wangwu</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># ZRANGEBYSCORE key min max</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf <span class="comment"># 显示全部的用户 从小到大！</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 <span class="comment"># 从大到进行排序！</span></span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores <span class="comment"># 显示全部的用户并且附带成绩</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores <span class="comment"># # 显示工资小于2500员工的升序排序！</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment"># 移除rem中的元素</span></span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary zhangsan <span class="comment"># 移除有序集合中的指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary <span class="comment"># 获取有序集合中的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 world 3 peppa</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3 <span class="comment"># 获取指定区间的成员数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><p>其它更多的API，查询官方文档：<a href="https://redis.io/commands">Command reference – Redis</a></p><p>案例思路：set 排序 存储班级成绩表，工资表排序！<br>普通消息，1， 重要消息 2，带权重进行判断！<br>排行榜应用实现，取Top N 测试！</p>]]></content>
    
    
    <summary type="html">Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis(一)认识Redis</title>
    <link href="https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%80)%E8%AE%A4%E8%AF%86Redis%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://yuanxw.github.io/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%80)%E8%AE%A4%E8%AF%86Redis%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2023-03-31T16:00:00.000Z</published>
    <updated>2025-09-03T16:10:24.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-一-认识Redis"><a href="#Redis-一-认识Redis" class="headerlink" title="Redis(一)认识Redis"></a>Redis(一)认识Redis</h2><h3 id="1-Redis-是什么？"><a href="#1-Redis-是什么？" class="headerlink" title="1. Redis 是什么？"></a>1. Redis 是什么？</h3><p>Redis（Remote Dictionary Server )，即远程字典服务 !<br>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！</p><p><img src="/images/redis_basics_beginners/chapter1/image.png" alt="Untitled"></p><h3 id="2-Redis-能干嘛？"><a href="#2-Redis-能干嘛？" class="headerlink" title="2. Redis 能干嘛？"></a>2. Redis 能干嘛？</h3><p>google guava提供两种方式：</p><ul><li>内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）</li><li>效率高，可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器（浏览量！）<br>……..</li></ul><h3 id="3-特性"><a href="#3-特性" class="headerlink" title="3. 特性"></a>3. 特性</h3><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li></ul><h3 id="4-Redis安装"><a href="#4-Redis安装" class="headerlink" title="4. Redis安装"></a>4. Redis安装</h3><ul><li><p><strong>Windows安装</strong></p><ol><li>下载安装包：<a href="https://github.com/microsoftarchive/redis/releases/">Releases · microsoftarchive&#x2F;redis · GitHub</a></li><li>下载完毕得到压缩包：</li></ol><p>  <img src="/images/redis_basics_beginners/chapter1/image1.png" alt="Untitled"></p><ol><li>解压到自己电脑上的环境目录下的就可以的！Redis 十分的小，只有5M</li></ol><p>  <img src="/images/redis_basics_beginners/chapter1/image2.png" alt="Untitled"></p><ol><li>开启Redis，双击运行服务即可！</li></ol><p>  <img src="/images/redis_basics_beginners/chapter1/image3.png" alt="Untitled"></p><ol><li>使用Redis客户单连接redis</li></ol><p>  <img src="/images/redis_basics_beginners/chapter1/image4.png" alt="Untitled"></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name yuanxw</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;yuanxw&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>  <img src="/images/redis_basics_beginners/chapter1/image5.png" alt="Untitled"></p></li></ul><p><strong>4.2 Linux安装</strong></p><ol><li>下载安装包：wget <a href="https://download.redis.io/releases/redis-6.2.6.tar.gz">https://download.redis.io/releases/redis-6.2.6.tar.gz</a></li><li>解压Redis的安装包</li></ol><p><img src="/images/redis_basics_beginners/chapter1/image6.png" alt="Untitled"></p><ol><li>进入解压后的文件，可以看到我们redis的配置文件</li></ol><p><img src="/images/redis_basics_beginners/chapter1/image7.png" alt="Untitled"></p><ol><li>基本的环境安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="/images/redis_basics_beginners/chapter1/image8.png" alt="Untitled"></p><p><img src="/images/redis_basics_beginners/chapter1/image9.png" alt="Untitled"></p><ol><li>Redis的默认安装路径</li></ol><p> 目录：&#x2F;usr&#x2F;local&#x2F;bin</p><p><img src="/images/redis_basics_beginners/chapter1/image10.png" alt="Untitled"></p><ol><li>将Redis配置文件。复制到我们当前目录下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/local/bin/config</span><br><span class="line"><span class="built_in">cp</span> /usr/local/software/redis-6.2.6/redis.conf /usr/local/bin/config</span><br></pre></td></tr></table></figure><ol><li>Redis默认不是后台启动的，修改配置文件！</li></ol><p><img src="/images/redis_basics_beginners/chapter1/image11.png" alt="Untitled"></p><p><img src="/images/redis_basics_beginners/chapter1/image12.png" alt="Untitled"></p><ol><li>启动Redis服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server config/redis.conf</span><br></pre></td></tr></table></figure><ol><li>验证服务</li></ol><p><img src="/images/redis_basics_beginners/chapter1/image13.png" alt="Untitled"></p><ol><li>使用redis-cli 进行连接测试</li></ol><p><img src="/images/redis_basics_beginners/chapter1/image14.png" alt="Untitled"></p><ol><li>如何关闭Redis服务呢</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# redis-cli </span><br><span class="line">127.0.0.1:6379&gt; SHUTDOWN</span><br></pre></td></tr></table></figure><p><img src="/images/redis_basics_beginners/chapter1/image15.png" alt="Untitled"></p><h3 id="5-Redis默认有16个数据库"><a href="#5-Redis默认有16个数据库" class="headerlink" title="5. Redis默认有16个数据库"></a>5. Redis默认有16个数据库</h3><p>Redis默认数据库有16个，默认使用database：0</p><p><img src="/images/redis_basics_beginners/chapter1/image16.png" alt="Untitled"></p><p>可以使用 select 进行切换数据库！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="keyword">select</span> 3 <span class="comment"># 切换数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE <span class="comment"># 查看DB大小！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p><img src="/images/redis_basics_beginners/chapter1/image17.png" alt="Untitled"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; keys * <span class="comment"># 查看数据库所有的key</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br></pre></td></tr></table></figure><h3 id="6-清除当前数据库"><a href="#6-清除当前数据库" class="headerlink" title="6. 清除当前数据库"></a>6. 清除当前数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushdb</span><br></pre></td></tr></table></figure><h3 id="7-清除全部数据库的内容"><a href="#7-清除全部数据库的内容" class="headerlink" title="7. 清除全部数据库的内容"></a>7. 清除全部数据库的内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSHALL</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><h3 id="8-Redis-是单线程的"><a href="#8-Redis-是单线程的" class="headerlink" title="8. Redis 是单线程的"></a>8. Redis 是单线程的</h3><p>明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所有就使用了单线程了！<br>Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的Memecache差！</p><ul><li>Redis 为什么单线程还这么快？<ul><li><p>误区1：高性能的服务器一定是多线程的？</p></li><li><p>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</p><p>  先去CPU&gt;内存&gt;硬盘的速度要有所了解！<br>  核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程<br>  （CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高<br>  的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Redis（Remote Dictionary Server )，即远程字典服务 !是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！</summary>
    
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yuanxw.github.io/tags/Redis/"/>
    
    <category term="Redis基础入门" scheme="https://yuanxw.github.io/tags/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Arthas诊断工具(七)Arthas（阿尔萨斯）profiler命令生成火焰图</title>
    <link href="https://yuanxw.github.io/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E4%B8%83)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89profiler%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    <id>https://yuanxw.github.io/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E4%B8%83)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89profiler%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E7%81%AB%E7%84%B0%E5%9B%BE/</id>
    <published>2023-03-06T16:00:00.000Z</published>
    <updated>2025-09-03T15:50:23.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arthas诊断工具-七-Arthas（阿尔萨斯）profiler命令生成火焰图"><a href="#Arthas诊断工具-七-Arthas（阿尔萨斯）profiler命令生成火焰图" class="headerlink" title="Arthas诊断工具(七)Arthas（阿尔萨斯）profiler命令生成火焰图"></a>Arthas诊断工具(七)Arthas（阿尔萨斯）profiler命令生成火焰图</h1><h2 id="1-profiler命令"><a href="#1-profiler命令" class="headerlink" title="1. profiler命令"></a>1. <strong>profiler命令</strong></h2><p><code>profiler</code> 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。</p><p><code>profiler</code> 命令基本运行结构是 <code>profiler action [actionArg]</code></p><p><code>profiler</code> 命令的格式基本与上游项目 <a href="https://github.com/async-profiler/async-profiler"><strong>async-profiler在新窗口打开</strong></a> 保持一致，详细的使用方式可参考上游项目的 README、Github Disscussions 以及其他文档资料</p><aside>💡<p>使用<a href="https://github.com/jvm-profiling-tools/async-profiler"><strong>async-profiler在新窗口打开</strong></a>生成火焰图</p></aside><ul><li><strong>参数说明</strong></li></ul><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>action</em></td><td>要执行的操作</td></tr><tr><td><em>actionArg</em></td><td>属性名模式</td></tr><tr><td>[i:]</td><td>采样间隔（单位：ns）（默认值：10’000’000，即 10 ms）</td></tr><tr><td>[f:]</td><td>将输出转储到指定路径</td></tr><tr><td>[d:]</td><td>运行评测指定秒</td></tr><tr><td>[e:]</td><td>要跟踪哪个事件（cpu, alloc, lock, cache-misses 等），默认是 cpu</td></tr></tbody></table><h2 id="2-启动-profiler-命令"><a href="#2-启动-profiler-命令" class="headerlink" title="2. 启动 profiler 命令"></a><strong>2. 启动 profiler 命令</strong></h2><aside>💡<p>默认情况下，生成的是 cpu 的火焰图，即 event 为<code>cpu</code>。可以用<code>--event</code>参数指定其他性能分析模式，见下文</p></aside><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[arthas@8161]$ profiler start</span><br><span class="line">Profiling started</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-获取已采集的-sample-的数量"><a href="#3-获取已采集的-sample-的数量" class="headerlink" title="3. 获取已采集的 sample 的数量"></a><strong>3. 获取已采集的 sample 的数量</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[arthas@8161]$ profiler getSamples </span><br><span class="line">34</span><br></pre></td></tr></table></figure><h2 id="4-查看-profiling-状态"><a href="#4-查看-profiling-状态" class="headerlink" title="4. 查看 profiling 状态"></a><strong>4. 查看 profiling 状态</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[arthas@8161]$ profiler status</span><br><span class="line">Profiling is running <span class="keyword">for</span> 230 seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-查看-profiler-自身的内存占用"><a href="#5-查看-profiler-自身的内存占用" class="headerlink" title="5. 查看 profiler 自身的内存占用"></a><strong>5. 查看 profiler 自身的内存占用</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[arthas@8161]$ profiler meminfo </span><br><span class="line">Call trace storage:   10244 KB</span><br><span class="line">  Flight recording:       0 KB</span><br><span class="line">      Dictionaries:      72 KB</span><br><span class="line">        Code cache:   12685 KB</span><br><span class="line">------------------------------</span><br><span class="line">             Total:   23001 KB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-停止-profiler"><a href="#6-停止-profiler" class="headerlink" title="6. 停止 profiler"></a><strong>6. 停止 profiler</strong></h2><ul><li><strong>生成火焰图格式结果</strong></li></ul><p>默认情况下，结果是 <a href="https://github.com/BrendanGregg/FlameGraph"><strong>Flame Graph在新窗口打开</strong></a> 格式的 <code>html</code> 文件，也可以用 <code>-o</code> 或 <code>--format</code> 参数指定其他内容格式，包括 flat、traces、collapsed、flamegraph、tree、jfr。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 停止采集数据，并生成火焰图</span></span><br><span class="line">[arthas@8161]$ profiler stop --format flamegraph</span><br><span class="line">OK</span><br><span class="line">profiler output file: /usr/local/software/arthas/arthas-output/20250607-110904.html</span><br><span class="line"></span><br><span class="line"><span class="comment">## 退出arthas</span></span><br><span class="line">[arthas@8161]$ stop</span><br><span class="line">Resetting all enhanced classes ...</span><br><span class="line">Affect(class count: 1 , method count: 0) cost <span class="keyword">in</span> 74 ms, listenerId: 0</span><br><span class="line">Arthas Server is going to shutdown...</span><br><span class="line">[arthas@8161]$ session (95b458b7-9c4b-4201-a619-de2dae2e85a7) is closed because server is going to shutdown.</span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载火焰图</span></span><br><span class="line">[root@localhost arthas]# sz /usr/local/software/arthas/arthas-output/20250607-110904.html</span><br></pre></td></tr></table></figure><p><img src="/images/arthas/chapter7/image.png" alt="image.png"></p><p><img src="/images/arthas/chapter7/image1.png" alt="image.png"></p><ol><li>arthas 火焰图颜色说明：<ul><li>绿色： java 代码</li><li>黄色： jvm c++ 代码</li><li>红色： 用户态 c 代码</li><li>橙色： 内核态 c 代码</li></ul></li><li>arthas 火焰图x-y轴<ul><li>x轴代表的不是时间，而是采样总量</li><li>y轴代表方法的调用栈深度，倘若方法调用得越多，火焰越高，顶部的栈就是当前正在执行的方法</li></ul></li><li>栈宽含义（CPU时间）<ul><li>宽度可以理解为CPU采样率的占比，越宽代表当前栈在采样数中占比高，其可能为三种含义<br> 该函数运行时间长<br> 该函数被调用次数多</li></ul></li><li>平顶现象（一定要格外注意）<ul><li>平顶现象是由于当前程序的采样数在总采样数中占用过高导致的，出现这种现象需要特意关注一下程序具体的调用栈，采样比例占用率过高，即代表方法在CPU中的占用率过高</li></ul></li></ol><p><strong>总结</strong>：</p><p>火焰图只是用于辅助程序分析定位问题，查看程序在采样期间的大致情况，实际场景还需结合CPU占用率、查看JVM的DUMP快照等方式进行定位</p><ul><li>火焰图的顶部代表CPU消耗最高的方法，越往下方法的消耗越低。宽度过宽的方法表示其被调用频繁或自身执行时间长，是性能瓶颈的候选点。</li><li>通过观察火焰图，你可以识别出哪些方法占用CPU最多，进而针对性地优化这些“热点”方法，提升程序性能。</li></ul><h2 id="7-profiler-支持的-events"><a href="#7-profiler-支持的-events" class="headerlink" title="7. profiler 支持的 events"></a><strong>7. profiler 支持的 events</strong></h2><p>在不同的平台，不同的 OS 下面，支持的 events 各有不同。比如在 centos下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[arthas@8161]$ profiler list</span><br><span class="line">Basic events:</span><br><span class="line">  cpu</span><br><span class="line">  alloc</span><br><span class="line">  nativemem</span><br><span class="line">  lock</span><br><span class="line">  wall</span><br><span class="line">  itimer</span><br><span class="line">  ctimer</span><br><span class="line">Java method calls:</span><br><span class="line">  ClassName.methodName</span><br><span class="line">Perf events:</span><br><span class="line">  cpu-clock</span><br><span class="line">  page-faults</span><br><span class="line">  context-switches</span><br><span class="line">  cycles</span><br><span class="line">  instructions</span><br><span class="line">  cache-references</span><br><span class="line">  cache-misses</span><br><span class="line">  branch-instructions</span><br><span class="line">  branch-misses</span><br><span class="line">  bus-cycles</span><br><span class="line">  L1-dcache-load-misses</span><br><span class="line">  LLC-load-misses</span><br><span class="line">  dTLB-load-misses</span><br><span class="line">  rNNN</span><br><span class="line">  pmu/event-descriptor/</span><br><span class="line">  mem:breakpoint</span><br><span class="line">  trace:tracepoint</span><br><span class="line">  kprobe:func</span><br><span class="line">  uprobe:path</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">profiler命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。</summary>
    
    
    
    <category term="Arthas" scheme="https://yuanxw.github.io/categories/Arthas/"/>
    
    
    <category term="Arthas" scheme="https://yuanxw.github.io/tags/Arthas/"/>
    
    <category term="Arthas诊断工具" scheme="https://yuanxw.github.io/tags/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Arthas诊断工具(六)Arthas（阿尔萨斯）options全局开关</title>
    <link href="https://yuanxw.github.io/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E5%85%AD)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89options%E5%85%A8%E5%B1%80%E5%BC%80%E5%85%B3/"/>
    <id>https://yuanxw.github.io/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E5%85%AD)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89options%E5%85%A8%E5%B1%80%E5%BC%80%E5%85%B3/</id>
    <published>2023-03-05T16:00:00.000Z</published>
    <updated>2025-09-03T15:50:23.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arthas诊断工具-六-Arthas（阿尔萨斯）options全局开关"><a href="#Arthas诊断工具-六-Arthas（阿尔萨斯）options全局开关" class="headerlink" title="Arthas诊断工具(六)Arthas（阿尔萨斯）options全局开关"></a>Arthas诊断工具(六)Arthas（阿尔萨斯）options全局开关</h1><h2 id="1-options命令"><a href="#1-options命令" class="headerlink" title="1. options命令"></a>1. options<strong>命令</strong></h2><p>全局开关</p><table><thead><tr><th>名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>unsafe</td><td>false</td><td>是否支持对系统级别的类进行增强，打开该开关可能导致把 JVM 搞挂，请慎重选择！</td></tr><tr><td>dump</td><td>false</td><td>是否支持被增强了的类 dump 到外部文件中，如果打开开关，class 文件会被 dump 到<code>/$&#123;application working dir&#125;/arthas-class-dump/</code>目录下，具体位置详见控制台输出</td></tr><tr><td>batch-re-transform</td><td>true</td><td>是否支持批量对匹配到的类执行 retransform 操作</td></tr><tr><td>json-format</td><td>false</td><td>是否支持 json 化的输出</td></tr><tr><td>disable-sub-class</td><td>false</td><td>是否禁用子类匹配，默认在匹配目标类的时候会默认匹配到其子类，如果想精确匹配，可以关闭此开关</td></tr><tr><td>support-default-method</td><td>true</td><td>是否支持匹配到 default method， 默认会查找 interface，匹配里面的 default method。参考 <a href="https://github.com/alibaba/arthas/issues/1105"><strong>#1105在新窗口打开</strong></a></td></tr><tr><td>save-result</td><td>false</td><td>是否打开执行结果存日志功能，打开之后所有命令的运行结果都将保存到<code>~/logs/arthas-cache/result.log</code>中</td></tr><tr><td>job-timeout</td><td>1d</td><td>异步后台任务的默认超时时间，超过这个时间，任务自动停止；比如设置 1d, 2h, 3m, 25s，分别代表天、小时、分、秒</td></tr><tr><td>print-parent-fields</td><td>true</td><td>是否打印在 parent class 里的 filed</td></tr><tr><td>verbose</td><td>false</td><td>是否打印更多详细信息</td></tr><tr><td>strict</td><td>true</td><td>是否启用 strict 模式</td></tr></tbody></table><ul><li><strong>查看所有的 options</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[arthas@8161]$ options</span><br><span class="line"> LEVEL              TYPE                NAME                                  VALUE              SUMMARY                                                   DESCRIPTION                                                                                                        </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> 0                  boolean             unsafe                                <span class="literal">false</span>              Option to support system-level class                      This option enables to proxy functionality of JVM classes. Due to serious security risk a JVM crash is possibly be </span><br><span class="line">                                                                                                                                                            introduced. Do not activate it unless you are able to manage.                                                     </span><br><span class="line"> 1                  boolean             dump                                  <span class="literal">false</span>              Option to dump the enhanced classes                       This option enables the enhanced classes to be dumped to external file <span class="keyword">for</span> further de-compilation and analysis.    </span><br><span class="line"> 1                  boolean             batch-re-transform                    <span class="literal">true</span>               Option to support batch reTransform Class                 This options enables to reTransform classes with batch mode.                                                       </span><br><span class="line"> 2                  boolean             json-format                           <span class="literal">false</span>              Option to support JSON format of object output            This option enables to format object output with JSON when -x option selected.                                     </span><br><span class="line"> 1                  boolean             disable-sub-class                     <span class="literal">false</span>              Option to control include sub class when class matching   This option <span class="built_in">disable</span> to include sub class when matching class.                                                      </span><br><span class="line"> 1                  boolean             support-default-method                <span class="literal">true</span>               Option to control include default method <span class="keyword">in</span> interface wh  This option <span class="built_in">disable</span> to include default method <span class="keyword">in</span> interface when matching class.                                    </span><br><span class="line">                                                                                                 en class matching                                                                                                                                                            </span><br><span class="line"> 1                  boolean             save-result                           <span class="literal">false</span>              Option to <span class="built_in">print</span> <span class="built_in">command</span><span class="string">&#x27;s result to log file              This option enables to save each command&#x27;</span>s result to <span class="built_in">log</span> file, <span class="built_in">which</span> path is <span class="variable">$&#123;user.home&#125;</span>/logs/arthas-cache/result </span><br><span class="line">                                                                                                                                                           .<span class="built_in">log</span>.                                                                                                              </span><br><span class="line"> 2                  String              job-timeout                           1d                 Option to job <span class="built_in">timeout</span>                                     This option setting job <span class="built_in">timeout</span>,The unit can be d, h, m, s <span class="keyword">for</span> day, hour, minute, second. 1d is one day <span class="keyword">in</span> default </span><br><span class="line"> 1                  boolean             print-parent-fields                   <span class="literal">true</span>               Option to <span class="built_in">print</span> all fileds <span class="keyword">in</span> parent class                This option enables <span class="built_in">print</span> files <span class="keyword">in</span> parent class, default value <span class="literal">true</span>.                                               </span><br><span class="line"> 1                  boolean             verbose                               <span class="literal">false</span>              Option to <span class="built_in">print</span> verbose information                       This option enables <span class="built_in">print</span> verbose information, default value <span class="literal">false</span>.                                                </span><br><span class="line"> 1                  boolean             strict                                <span class="literal">true</span>               Option to strict mode                                     By default, strict mode is <span class="literal">true</span>, not allowed to <span class="built_in">set</span> object properties. Want to <span class="built_in">set</span> object properties, execute `opt </span><br><span class="line">                                                                                                                                                           ions strict <span class="literal">false</span>`  </span><br></pre></td></tr></table></figure><ul><li><strong>获取 option 的值</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">json-format job-timeout </span><br><span class="line">[arthas@8161]$ options json-format </span><br><span class="line"> LEVEL              TYPE                NAME                                  VALUE              SUMMARY                                                   DESCRIPTION                                                                                                        </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> 2                  boolean             json-format                           <span class="literal">false</span>              Option to support JSON format of object output            This option enables to format object output with JSON when -x option selected.                                     </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">options全局开关</summary>
    
    
    
    <category term="Arthas" scheme="https://yuanxw.github.io/categories/Arthas/"/>
    
    
    <category term="Arthas" scheme="https://yuanxw.github.io/tags/Arthas/"/>
    
    <category term="Arthas诊断工具" scheme="https://yuanxw.github.io/tags/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
