<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM虚拟机详解(一)JVM与JAVA体系统结构</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%80)JVM%E4%B8%8EJAVA%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[1. Java生态圈Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。

作为一个平台，Java虚拟机扮演着举足轻重的作用
Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分


作为灯种文化，Java几乎成为了“开源”的代名词。
第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。
就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。


作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。


随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。
Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。
2. 字节码我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。
不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。
Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。
3. 多语言混合编程Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。
试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby&#x2F;Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。
对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。
4. Java发展的重大事件
1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java
1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。
1996年1月23日sun Microsystems发布了JDK 1.0。
1998年，JDK1.2版本发布。同时，sun发布了JSP&#x2F;Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。
2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。
2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。
2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。
2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。
2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。
2007年，Java平台迎来了新伙伴Clojure。
2008年，oracle收购了BEA，得到了JRockit虚拟机。
2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。
2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit
2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。
2017年，JDK9发布。将G1设置为默认Gc，替代CMS
同年，IBM的J9开源，形成了现在的open J9社区
2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元
同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会
同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可
2019年，JDK12发布，加入RedHat领导开发的shenandoah GC


在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。
5. 虚拟机与Java虚拟机所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。

大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。
程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。

无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。
6. Java虚拟机Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。
JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。
Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。
Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。
特点：

一次编译，到处运行
自动内存管理
自动垃圾回收功能

7. JVM的位置JVM是运行在操作系统之上的，它与硬件没有直接的交互


Java的体系结构


8. JVM整体结构
HotSpot VM是目前市面上高性能虚拟机的代表作之一。
它采用解释器与即时编译器并存的架构。
在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++程序一较高下的地步。


执行引擎包含三部分：解释器，及时编译器，垃圾回收器
9. Java代码执行流程只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了

10. JVM的架构模型
在文件中找到Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：

基于栈式架构的特点
设计和实现更简单，适用于资源受限的系统；
避开了寄存器的分配难题：使用零地址指令方式分配。
指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。
不需要硬件支持，可移植性更好，更好实现跨平台


基于寄存器架构的特点
典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。
指令集架构则完全依赖硬件，可移植性差
性能优秀和执行更高效
花费更少的指令去完成一项操作。
在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主




两种架构的举例
  同样执行2+3这种逻辑操作，其指令分别如下：

基于栈的计算流程（以Java虚拟机为例）：8个指令

  iconst_2 //常量2入栈istore_1 // 将常量2从操作数栈存付到局部变量表 第2个位置iconst_3 // 常量3入栈istore_2 // 将常量3从操作数栈存付到局部变量表 第3个位置 iload_1 // 加载局部变量第1个变量压入操作数栈iload_2 // 加载局部变量第2个变量压入操作数栈iadd // 常量2/3出栈，执行相加istore_0 // 结果5入栈

而基于寄存器的计算流程

  mov eax,2 //将eax寄存器的值设为1add eax,3 //使eax寄存器的值加3

11. 字节码反编译
我们编写一个简单的代码，然后查看一下字节码的反编译后的结果
  package com.peppa;/** * @author peppa * @create 2022-02-08 15:51:45 */public class StackStruTest &#123;    public static void main(String[] args) &#123;        int i = 2 + 3;    &#125;&#125;

然后我们找到编译后的 class文件，使用下列命令进行反编译
  javap -v StackStruTest.class
  反编译结果：
  public class com.peppa.StackStruTest  minor version: 0  major version: 52  flags: (0x0021) ACC_PUBLIC, ACC_SUPER  this_class: #5                          // com/peppa/StackStruTest  super_class: #6                         // java/lang/Object  interfaces: 0, fields: 0, methods: 2, attributes: 1Constant pool:   #1 = Methodref          #6.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #24.#25        // java/lang/System.out:Ljava/io/PrintStream;   #3 = String             #26            // -----------------   #4 = Methodref          #27.#28        // java/io/PrintStream.println:(Ljava/lang/String;)V   #5 = Class              #29            // com/peppa/StackStruTest   #6 = Class              #30            // java/lang/Object   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               LocalVariableTable  #12 = Utf8               this  #13 = Utf8               Lcom/peppa/StackStruTest;  #14 = Utf8               main  #15 = Utf8               ([Ljava/lang/String;)V  #16 = Utf8               args  #17 = Utf8               [Ljava/lang/String;  #18 = Utf8               i  #19 = Utf8               I  #20 = Utf8               MethodParameters  #21 = Utf8               SourceFile  #22 = Utf8               StackStruTest.java  #23 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V  #24 = Class              #31            // java/lang/System  #25 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;  #26 = Utf8               -----------------  #27 = Class              #34            // java/io/PrintStream  #28 = NameAndType        #35:#36        // println:(Ljava/lang/String;)V  #29 = Utf8               com/peppa/StackStruTest  #30 = Utf8               java/lang/Object  #31 = Utf8               java/lang/System  #32 = Utf8               out  #33 = Utf8               Ljava/io/PrintStream;  #34 = Utf8               java/io/PrintStream  #35 = Utf8               println  #36 = Utf8               (Ljava/lang/String;)V&#123;  public com.peppa.StackStruTest();    descriptor: ()V    flags: (0x0001) ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 6: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/peppa/StackStruTest;

12. JVM生命周期
虚拟机的启动
  Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。

虚拟机的执行

一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。
程序开始执行时他才运行，程序结束时他就停止。
执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。


虚拟机的退出

程序正常执行结束
程序在执行过程中遇到了异常或错误而异常终止
由于操作系统用现错误而导致Java虚拟机进程终止
某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。
除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。



13. JVM发展历程
Sun Classic VM

早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。
这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】
如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。
我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。
而解释器就是走到哪，解释到哪。


现在Hotspot内置了此虚拟机。


Exact VM

为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。
Exact Memory Management：准确式内存管理
也可以叫Non-Conservative&#x2F;Accurate Memory Management
虚拟机可以知道内存中某个位置的数据具体是什么类型。


具备现代高性能虚拟机的维形
热点探测（寻找出热点代码进行缓存）
编译器与解释器混合工作模式


只在Solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换


HotSpot VM（重点）

HotSpot历史
最初由一家名为“Longview Technologies”的小公司设计
1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。
JDK1.3时，HotSpot VM成为默认虚拟机


目前Hotspot占有绝对的市场地位，称霸武林。
不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot
Sun&#x2F;oracle JDK和openJDK的默认虚拟机
因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚机都没有方法区的概念）


从服务器、桌面到移动端、嵌入式都有应用。
名称中的HotSpot指的就是它的热点代码探测技术。
通过计数器找到最具编译价值代码，触发即时编译或栈上替换
通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡




JRockit（商用三大虚拟机之一）

专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。
大量的行业基准测试显示，JRockit JVM是世界上最快的JVM：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。
优势：全面的Java运行时解决方案组合
JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要
Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。


2008年，JRockit被Oracle收购。
Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。
高斯林：目前就职于谷歌，研究人工智能和水下机器人


IBM的J9（商用三大虚拟机之一）

全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9
市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。
目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。
2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9
OpenJDK -&gt; 是JDK开源了，包括了虚拟机


KVM和CDC&#x2F;CLDC Hotspot

Oracle在Java ME产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM
KVM（Kilobyte）是CLDC-HI早期产品
目前移动领域地位尴尬，智能机被Android和iOS二分天下。
KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场
智能控制器、传感器
老人手机、经济欠发达地区的功能手机


所有的虚拟机的原则：一次编译，到处运行。


Azul VM

前面三大“高性能Java虚拟机”使用在通用硬件平台上
这里Azul VW和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机：高性能Java虚拟机中的战斗机。
Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。
每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。
2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。


Liquid VM

高性能Java虚拟机中的战斗机。
BEA公司开发的，直接运行在自家Hypervisor系统上
Liquid VM即是现在的JRockit VE（Virtual Edition）。Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。
随着JRockit虚拟机终止开发，Liquid vM项目也停止了。


Apache Marmony

Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。
它是IElf和Intel联合开发的开源JVM，受到同样开源的Open JDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK
虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。


Micorsoft JVM

微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。
只能在window平台下运行。但确是当时Windows下性能最好的Java VM。
1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。


Taobao JVM

由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。
基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。
基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。
创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。
GCIH中的对象还能够在多个Java虚拟机进程中实现共享
使用crc32指令实现JvM intrinsic降低JNI的调用开销
PMU hardware的Java profiling tool和诊断协助功能
针对大数据场景的ZenGC


taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能


目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。


Dalvik VM

谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。
Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范
不能直接执行Java的Class文件
基于寄存器架构，不是jvm的栈架构。
执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。
它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。


Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。


Graal VM（未来虚拟机）

2018年4月，Oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。
GraalVM在HotSpot VM基础上增强而成的**跨语言全栈虚拟机，可以作为“任何语言”**的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等
支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件
工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。
如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。



6. 总结
具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。

]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>VM虚拟机详解(七)**虚拟机栈Virtual Machine Stacks</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%83)%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88Virtual%20Machine%20Stacks/</url>
    <content><![CDATA[JVM虚拟机详解(七)虚拟机栈Virtual Machine Stacks1. 概述每个 Java 虚拟机线程都有一个专用的 Java 虚拟机堆栈，与线程同时创建。Java 虚拟机堆栈存储帧(2.6)。Java 虚拟机堆栈类似于传统语言(如 c)的堆栈: 它保存局部变量和部分结果，并在方法调用和返回中发挥作用。因为 Java 虚拟机堆栈从来不会被直接操作，除了推送和弹出框架，框架可能会被分配到堆中。Java 虚拟机堆栈的内存不需要是连续的。
在 Java 虚拟机规范的第一版中，Java 虚拟机堆栈被称为 Java 堆栈。
该规范允许 Java 虚拟机堆栈具有固定的大小，或者根据计算的需要动态扩展和收缩。如果 Java 虚拟机堆栈的大小是固定的，那么在创建该堆栈时可以独立地选择每个 Java 虚拟机堆栈的大小。
一个 Java 虚拟机实现可以为程序员或用户提供对 Java 虚拟机堆栈初始大小的控制，以及，在动态扩展或收缩 Java 虚拟机堆栈的情况下，对最大和最小大小的控制。

下列异常情况与 Java 虚拟机堆栈相关:
如果线程中的计算需要比允许的更大的 Java 虚拟机堆栈，则 Java 虚拟机抛出 StackOverflowError。
如果 Java 虚拟机堆栈可以动态扩展，并且尝试扩展，但是没有足够的内存来实现扩展，或者如果没有足够的内存来为新线程创建初始的 Java 虚拟机堆栈，Java 虚拟机抛出 OutOfMemoryError。


默认堆大小：
Xms：初始大小内存，默认为物理内存64&#x2F;1，等价于-XX:InitialHeapSize
Xmx：最大分配内存，默认为物理内存的4&#x2F;1，等价于：-XXMaxHeapSize


默认栈大小：
XX:ThreadStackSize设为0，就是使用“系统默认值”。而在Linux x64上HotSpot VM给Java栈定义的“系统默认”大小也是1MB。



官网：Chapter 2. The Structure of the Java Virtual Machine (oracle.com)

首先栈是运行时的单位，而堆是存储的单位
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。

堆解决的是数据存储的问题，即数据怎么放，放哪里
  




Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。


生命周期
  生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了

作用  - 主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。  - 局部变量，它是相比于成员变量来说的（或属性）  - 基本数据类型变量 VS 引用类型变量（类、数组、接口）
虚拟机栈的特点

栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
JVM直接对Java栈的操作只有两个：
每个方法执行，伴随着进栈（入栈、压栈）
执行结束后的出栈工作




对于栈来说不存在垃圾回收问题

栈不需要GC，但是可能存在OOM

  
  

设置栈内存大小

我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。


Sets the thread stack size (in bytes). Append the letter k or K to indicate KB, m or M to indicate MB, and g or G to indicate GB. The default value depends on the platform:

Linux&#x2F;x64 (64-bit): 1024 KB
macOS (64-bit): 1024 KB
Oracle Solaris&#x2F;x64 (64-bit): 1024 KB
Windows: The default value depends on virtual memory


  The following examples set the thread stack size to 1024 KB in different units:
  -Xss1m-Xss1024k-Xss1048576

举例：
  package com.peppa.stack;/** * 演示栈中的异常：StackOverflowError * @author: peppa * @create: 2022-02-10 15:35:20 */public class StackErrorTest &#123;    private static int count = 1;    /**     * 默认参数：当栈深度达到：9826，出现内存空间不足。报错：Exception in thread &quot;main&quot; java.lang.StackOverflowError     * 添加参数：-Xss128k，当栈深度达到：982。报错：Exception in thread &quot;main&quot; java.lang.StackOverflowError     * 	at java.io.PrintStream.write(PrintStream.java:526)     * 	at java.io.PrintStream.print(PrintStream.java:597)     * 	at java.io.PrintStream.println(PrintStream.java:736)     * @param args     */    public static void main(String[] args) &#123;        System.out.println(count++);        main(args);    &#125;&#125;

2.栈的存储单位
栈中存储什么？

每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。
在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。
栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。


栈运行原理

JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出（后进先出）原则
在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）
执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。
不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。
如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
Java方法有两种返回函数的方式。
一种是正常的函数返回，使用return指令。
另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。
但不管使用哪种方式，都会导致栈帧被弹出。



  
  

栈帧的内部结构
  每个栈帧中存储着：

局部变量表（Local Variables）

操作数栈（operand Stack）（或表达式栈）

动态链接（DynamicLinking）（或指向运行时常量池的方法引用）

方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）

一些附加信息
  
  并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的
  




3.局部变量表
概述：

局部变量表也被称之为局部变量数组或本地变量表
定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。
由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。
方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。
对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。
进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。


局部变量表中的变量只在当前方法调用中有效。
在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。
当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。




关于Slot的理解

参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。

局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。

在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。

byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 1ong和double则占据两个slot。


JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上，如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）

如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。
  



Slot的重复利用
  栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。
  public void test4() &#123;        int a = 0;        &#123;            int b = 0;            b = a + 1;        &#125;        // 变量c使用之前已经销毁的变量b占据的slot的位置        int c = a + 1;    &#125;
  局部变量 c 重用了局部变量 b 的 slot 位置
  

静态变量与局部变量的对比

按数据类型分：基本数据类型、引用数据类型

按类中声明的位置分：成员变量（类变量，实例变量）、局部变量

类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块
实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值
局部变量：在使用前必须进行显式赋值，不然编译不通过。


参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。
  我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。
  和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。

补充说明
  在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
  局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。




4.操作数栈操作数栈：Operand Stack

操作数栈的特点

每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）

操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）

某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，
比如：执行复制、交换、求和等操作

 
 


  操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
  操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.

这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的

  每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。
  栈中的任何一个元素都是可以任意的Java数据类型

32bit的类型占用一个栈单位深度
64bit的类型占用两个栈单位深度

  操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问
  如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。
  操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|
  另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。
  

代码追踪
  public void testAddOperation() &#123;    byte i = 15;    int j = 8;    int k = i + j;&#125;
  使用javap 命令反编译class文件： javap -v 类名.class
  
  byte、short、char、boolean 内部都是使用int型来进行保存的
  从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和 8进行入栈操作
  同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作

一步一步看流程

首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。

  
  执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素
  
  为什么局部变量表不是从0开始的呢？
  其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~
  然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中
  
  
  然后从局部变量表中，依次将数据放在操作数栈中
  
  
  然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置
  
  
  最后PC寄存器的位置指向10，也就是return方法，则直接退出方法
  

栈顶缓存技术
  栈顶缓存技术：Top Of Stack Cashing
  前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。
  由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。


5.动态链接动态链接：Dynamic Linking

动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区

每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令
在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。

比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。
源码：
package com.peppa.linking;public class DynamicLinkingTest &#123;    int num = 10;    public void methodA()&#123;        System.out.println(&quot;methodA()....&quot;);    &#125;    public void methodB()&#123;        System.out.println(&quot;methodB()....&quot;);        methodA();        num++;    &#125;&#125;

对应字节码
public class com.peppa.linking.DynamicLinkingTest  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #8.#24         // com/peppa/linking/DynamicLinkingTest.num:I   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;   #4 = String             #27            // methodA()....   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V   #6 = String             #30            // methodB()....   #7 = Methodref          #8.#31         // com/peppa/linking/DynamicLinkingTest.methodA:()V   #8 = Class              #32            // com/peppa/linking/DynamicLinkingTest   #9 = Class              #33            // java/lang/Object  #10 = Utf8               num  #11 = Utf8               I  #12 = Utf8               &lt;init&gt;  #13 = Utf8               ()V  #14 = Utf8               Code  #15 = Utf8               LineNumberTable  #16 = Utf8               LocalVariableTable  #17 = Utf8               this  #18 = Utf8               Lcom/peppa/linking/DynamicLinkingTest;  #19 = Utf8               methodA  #20 = Utf8               methodB  #21 = Utf8               SourceFile  #22 = Utf8               DynamicLinkingTest.java  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V  #24 = NameAndType        #10:#11        // num:I  #25 = Class              #34            // java/lang/System  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;  #27 = Utf8               methodA()....  #28 = Class              #37            // java/io/PrintStream  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V  #30 = Utf8               methodB()....  #31 = NameAndType        #19:#13        // methodA:()V  #32 = Utf8               com/peppa/linking/DynamicLinkingTest  #33 = Utf8               java/lang/Object  #34 = Utf8               java/lang/System  #35 = Utf8               out  #36 = Utf8               Ljava/io/PrintStream;  #37 = Utf8               java/io/PrintStream  #38 = Utf8               println  #39 = Utf8               (Ljava/lang/String;)V&#123;  int num;    descriptor: I    flags:  public com.peppa.linking.DynamicLinkingTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: bipush        10         7: putfield      #2                  // Field num:I        10: return      LineNumberTable:        line 3: 0        line 4: 4      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      11     0  this   Lcom/peppa/linking/DynamicLinkingTest;  public void methodA();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #4                  // String methodA()....         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 7: 0        line 8: 8      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       9     0  this   Lcom/peppa/linking/DynamicLinkingTest;  public void methodB();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=3, locals=1, args_size=1         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #6                  // String methodB()....         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: aload_0         9: invokevirtual #7                  // Method methodA:()V        12: aload_0        13: dup        14: getfield      #2                  // Field num:I        17: iconst_1        18: iadd        19: putfield      #2                  // Field num:I        22: return      LineNumberTable:        line 11: 0        line 13: 8        line 15: 12        line 16: 22      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      23     0  this   Lcom/peppa/linking/DynamicLinkingTest;&#125;

1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？
2、往上面翻，找到常量池的定义：#7 = Methodref #8.#31

先找 #8 ：
#8 = Class #32 ：去找 #32
#32 = Utf8 com/peppa/linking/DynamicLinkingTest
结论：通过 #8 我们找到了 DynamicLinkingTest 这个类


再来找 #31：
#31 = NameAndType #19:#13 ：去找 #19 和 #13
#19 = Utf8 methodA ：方法名为 methodA
#13 = Utf8 ()V ：方法没有形参，返回值为 void



3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用
4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等

为什么需要运行时常量池？
因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间
常量池的作用：就是为了提供一些符号和常量，便于指令的识别

方法调用：解析与分配

静态链接与动态链接
  在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关

**静态链接：**当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。


早期绑定与晚期绑定
  静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。

早期绑定
  早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

晚期绑定
  如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。



早晚期绑定的发展历史
  随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。
  Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。

虚方法和非虚方法

如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。
静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。
其他方法称为虚方法。


子类对象的多态的使用前提：

类的继承关系
方法的重写


虚拟机中提供了以下几条方法调用指令：

普通调用指令：

invokestatic：调用静态方法，解析阶段确定唯一方法版本
invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本
invokevirtual：调用所有虚方法
invokeinterface：调用接口方法


动态调用指令：

invokedynamic：动态解析出需要调用的方法，然后执行
  前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。





invokednamic指令

JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。
但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。
Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。


动态语言和静态语言

动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。
说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。

  Java：String info = &quot;mogu blog&quot;; (Java是静态类型语言的，会先编译就进行类型检查) JS：var name = &quot;shkstart&quot;; var name = 10; （运行时才进行检查）Python: info = 130.5 (运行时才检查)


Java语言中方法重写的本质

什么是动态分派？

找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。
如果通过则返回这个方法的直接引用，查找过程结束
如果不通过，则返回java.lang.IllegalAccessError 异常


否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。


IllegalAccessError介绍
  程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。

方法的调用：虚方法表

在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】
每个类中都有一个虚方法表，表中存放着各个方法的实际入口。
虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。

  
  如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。




6.方法返回地址
方法的结束

存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：
正常执行完成
出现未处理的异常，非正常退出


无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。
正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。


方法退出的两种方式
  当一个方法开始执行后，只有两种方式可以退出这个方法，

正常退出：

执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；
一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。
在字节码指令中，返回指令包含：
ireturn：当返回值是boolean，byte，char，short和int类型时使用
lreturn：Long类型
freturn：Float类型
dreturn：Double类型
areturn：引用类型
return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法




异常退出：

在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。
方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码

  
  异常处理表：

反编译字节码文件，可得到 Exception table
from ：字节码指令起始地址
to ：字节码指令结束地址
target ：出现异常跳转至地址为 11 的指令执行
type ：捕获异常的类型



  本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。
  正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。


7.一些附加信息虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，成为栈帧信息。
]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(三)**类加载器的分类</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%89)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[JVM虚拟机详解(三)类加载器的分类1. 类加载器概述
JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）
从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器
无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示


这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。


我们通过一个类，获取它不同的加载器
  package com.peppa.classloader;/** * @author peppa * @create 2022-02-10 11:25:46 */public class ClassLoaderTest &#123;    public static void main(String[] args) &#123;        // 获取系统类加载器        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);        // 获取其上层的：扩展类加载器        ClassLoader extClassLoader = systemClassLoader.getParent();        System.out.println(extClassLoader);        // 试图获取 根加载器        ClassLoader bootstrapClassLoader = extClassLoader.getParent();        System.out.println(bootstrapClassLoader);        // 获取自定义加载器        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();        System.out.println(classLoader);        // 获取String类型的加载器        ClassLoader classLoader1 = String.class.getClassLoader();        System.out.println(classLoader1);    &#125;&#125;// 执行结果：sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@1b6d3586nullsun.misc.Launcher$AppClassLoader@18b4aac2null
  得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。
  我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，因为引导类加载器右 C&#x2F;C++ 语言，我们获取不到
  两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明系统类加载器是全局唯一的


2.虚拟机自带的加载器
启动类加载器（引导类加载器，Bootstrap ClassLoader）

这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。
它用来加载Java的核心库（JAVAHOME&#x2F;jre&#x2F;1ib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
并不继承自ava.lang.ClassLoader，没有父加载器。
加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类


扩展类加载器（Extension ClassLoader）

Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
派生于ClassLoader类
父类加载器为启动类加载器
从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;1ib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。


应用程序类加载器（系统类加载器，AppClassLoader）

javI语言编写，由sun.misc.LaunchersAppClassLoader实现
派生于ClassLoader类
父类加载器为扩展类加载器
它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器


用户自定义类加载器
  在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？

隔离加载类
修改类加载的方式
扩展加载源
防止源码泄漏

  用户自定义类加载器实现步骤：

开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中
在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。



3.查看根加载器所能加载的目录刚刚我们通过概念了解到了，根加载器只能够加载 java &#x2F;lib目录下的class，我们通过下面代码验证一下
package com.peppa.classloader;import java.net.URL;import java.security.Provider;/** * @author peppa * @create 2022-02-10 11:42:4 */public class ClassLoaderPathTest &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;*********启动类加载器************&quot;);        // 获取BootstrapClassLoader 能够加载的API的路径        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();        for (URL url : urls) &#123;            System.out.println(url.toExternalForm());        &#125;        // 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器        ClassLoader classLoader = Provider.class.getClassLoader();        System.out.println(&quot;classLoader ==&gt;&quot;+classLoader);    &#125;&#125;// 得到的结果*********启动类加载器************file:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/resources.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/rt.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/sunrsasign.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/jsse.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/jce.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/charsets.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/jfr.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/classesclassLoader ==&gt;null

4. 关于ClassLoader
ClassLoader 类介绍
  ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）
  

sun.misc.Launcher 它是一个java虚拟机的入口应用




获取ClassLoader的途径
获取当前ClassLoader：clazz.getClassLoader()
获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()
获取系统的ClassLoader：ClassLoader.getSystemClassLoader()
获取调用者的ClassLoader：DriverManager.getCallerClassLoader()



5.双亲委派机制Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；
如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常



双亲委派机制举例
  当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。
  

沙箱安全机制
  自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。

双亲委派机制的优势
  通过上面的例子，我们可以知道，双亲机制可以

避免类的重复加载
保护程序安全，防止核心API被随意篡改
自定义类：java.lang.String
自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）




其他

如何判断两个class对象是否相同？
  在JVM中表示两个class对象是否为同一个类存在两个必要条件：

类的完整类名必须一致，包括包名
加载这个类的ClassLoader（指ClassLoader实例对象）必须相同
换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的


对类加载器的引用

JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的
如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中





]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(九)方法区**Method Area</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B9%9D)%E6%96%B9%E6%B3%95%E5%8C%BAMethod%20Area/</url>
    <content><![CDATA[JVM虚拟机详解(九)方法区Method Area1. 栈、堆、方法区的交互关系
从线程共享与否的角度来看

ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。

  

从线程共享与否的角度来看
  ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理


  
  

栈、堆、方法区的交互关系

下面就涉及了对象的访问定位

  

Person：存放在元空间，也可以说方法区
person：存放在Java栈的局部变量表中
new Person()：存放在Java堆中


方法区的理解

《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。所以，方法区看作是一块独立于Java堆的内存空间。

  
  方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。
方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。
方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace
加载大量的第三方的jar包
Tomcat部署的工程过多（30~50个）
大量动态的生成反射类


关闭JVM就会释放这个区域的内存。


HotSpot中方法区的演进
  在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。

JDK 1.8后，元空间存放在堆外内存中

  本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。
  现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）
  
  而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替
  
  元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存
  永久代、元空间二者并不只是名字变了，内部结构也调整了
  根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常
  

设置方法区大小与OOM

方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。


jdk7及以前

通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M

XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M

当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。
  

JDK8以后
  元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定
  默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。
  与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace

XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。

  如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。



如何解决这些OOM

要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）
内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题


如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。



2.方法区的内部结构
关系图
  《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。





类型信息
  对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：

这个类型的完整有效名称（全名&#x3D;包名.类名）
这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）
这个类型的修饰符（public，abstract，final的某个子集）
这个类型直接接口的一个有序列表


域信息
  JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
  域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）

方法（Method）信息
  JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

方法名称
方法的返回类型（或void）
方法参数的数量和类型（按顺序）
方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
异常表（abstract和native方法除外）


每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引


non-final的类变量
  静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分
  类变量被类的所有实例共享，即使没有类实例时，你也可以访问它
  package com.peppa.area;/** * non-final的类变量 * * @author: peppa * @create: 2022-02-12 18:42:45 */public class MethodAreaTest &#123;    public static void main(String[] args) &#123;        Order order = new Order();        order.hello();        System.out.println(order.count);    &#125;&#125;class Order &#123;    public static int count = 1;    public static final int number = 2;    public static void hello() &#123;        System.out.println(&quot;hello!&quot;);    &#125;&#125;// 执行结果：// hello!// 1
  如上代码所示，即使我们把order设置为null，也不会出现空指针异常

全局常量：static final

全局常量就是使用 static final 进行修饰
被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。

  查看上面代码，这部分的字节码指令
  class Order &#123;    public static int count = 1;    public static final int number = 2;    ...&#125;
  public static int count;    descriptor: I    flags: ACC_PUBLIC, ACC_STATIC  public static final int number;    descriptor: I    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL    ConstantValue: int 2
  可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。****


3.常量池
常量池概述

官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html
  

方法区，内部包含了运行时常量池
字节码文件，内部包含了常量池
要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。
要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。




常量池
  一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用
  

为什么需要常量池
  一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。
  比如：如下的代码：
  public class SimpleClass &#123;    public void sayHello() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;

虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。
比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过引用的方式，来加载、调用所需的结构
这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。


常量池中有啥？

数量值
字符串值
类引用
字段引用
方法引用

  例如下面这段代码
  package com.peppa.area;public class MethodAreaTest2 &#123;    public static void main(String args[]) &#123;        Object obj = new Object();    &#125;&#125;
  将会被翻译成如下字节码
  0: new           #2                  // class java/lang/Object3: dup4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V7: astore_18: return

常量池总结
  常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。


4.运行时常量池
运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。
常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。（运行时常量池就是常量池在程序运行时的称呼）
运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。


运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。
当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。


方法区的使用举例

代码
  package com.peppa.area;public class MethodAreaDemo &#123;    public static void main(String[] args) &#123;        int x = 500;        int y = 100;        int a = x / y;        int b = 50;        System.out.println(a + b);    &#125;&#125;

字节码
  public class com.peppa.area.MethodAreaDemo  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #5.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;   #3 = Methodref          #28.#29        // java/io/PrintStream.println:(I)V   #4 = Class              #30            // com/peppa/area/MethodAreaDemo   #5 = Class              #31            // java/lang/Object   #6 = Utf8               &lt;init&gt;   #7 = Utf8               ()V   #8 = Utf8               Code   #9 = Utf8               LineNumberTable  #10 = Utf8               LocalVariableTable  #11 = Utf8               this  #12 = Utf8               Lcom/peppa/area/MethodAreaDemo;  #13 = Utf8               main  #14 = Utf8               ([Ljava/lang/String;)V  #15 = Utf8               args  #16 = Utf8               [Ljava/lang/String;  #17 = Utf8               x  #18 = Utf8               I  #19 = Utf8               y  #20 = Utf8               a  #21 = Utf8               b  #22 = Utf8               MethodParameters  #23 = Utf8               SourceFile  #24 = Utf8               MethodAreaDemo.java  #25 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V  #26 = Class              #32            // java/lang/System  #27 = NameAndType        #33:#34        // out:Ljava/io/PrintStream;  #28 = Class              #35            // java/io/PrintStream  #29 = NameAndType        #36:#37        // println:(I)V  #30 = Utf8               com/peppa/area/MethodAreaDemo  #31 = Utf8               java/lang/Object  #32 = Utf8               java/lang/System  #33 = Utf8               out  #34 = Utf8               Ljava/io/PrintStream;  #35 = Utf8               java/io/PrintStream  #36 = Utf8               println  #37 = Utf8               (I)V&#123;  public com.peppa.area.MethodAreaDemo();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 3: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/peppa/area/MethodAreaDemo;  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=3, locals=5, args_size=1         0: sipush        500         3: istore_1         4: bipush        100         6: istore_2         7: iload_1         8: iload_2         9: idiv        10: istore_3        11: bipush        50        13: istore        4        15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;        18: iload_3        19: iload         4        21: iadd        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V        25: return      LineNumberTable:        line 5: 0        line 6: 4        line 7: 7        line 8: 11        line 9: 15        line 10: 25      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      26     0  args   [Ljava/lang/String;            4      22     1     x   I            7      19     2     y   I           11      15     3     a   I           15      11     4     b   I    MethodParameters:      Name                           Flags      args&#125;


图解字节码指令执行流程
  
  首先现将操作数500放入到操作数栈中
  
  然后存储到局部变量表中
  
  然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作
  
  将500 和 100 进行一个除法运算，在把结果入栈
  
  在最后就是输出流，需要调用运行时常量池的常量
  
  最后调用invokevirtual（虚方法调用），然后返回
  
  返回时
  
  程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。
  符号引用 –&gt; 直接引用：

上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载
如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）



5.方法区的演进细节
永久代演进过程

首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。


Hotspot中方法区的变化：
  JDK1.6及以前	  有永久代（permanent generation），静态变量存储在永久代上JDK1.7	       有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中JDK1.8	       无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。

JDK6
  方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）
  

JDK7
  方法区由永久代实现，使用 JVM 虚拟机内存
  

JDK8
  元空间大小只受物理内存影响
  

永久代为什么要被元空间替代？

官方文档：JEP 122: Remove the Permanent Generation (java.net)


随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。
由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
这项改动是很有必要的，原因有：
为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。
对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低Full GC
有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。
一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。






字符串常量池 StringTable 为什么要调整位置？

JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。
这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。


方法区的垃圾回收

有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。

一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。

方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。

先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：

类和接口的全限定名
字段的名称和描述符
方法的名称和描述符


HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。

回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）



类卸载

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用**-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading**查看类加载和卸载信息
在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

  


6.直接内存 Direct Memory
直接内存概述

不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。
直接内存是在Java堆外的、直接向系统申请的内存区间。
来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存
通常，访问直接内存的速度会优于Java堆。即读写性能高。
因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。
Java的NIO库允许Java程序使用直接内存，用于数据缓冲区


使用下列代码，直接分配本地内存空间


int BUFFER = 1024*1024*1024; // 1GBByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);


非直接缓存区和缓存区

NIO的方式使用了缓存区的概念


存在的问题
  也可能导致outofMemoryError异常
  由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 缺点

分配回收成本较高
不受JVM内存回收管理

  直接内存大小可以通过MaxDirectMemorySize设置
  如果不指定，默认与堆的最大值-xmx参数值一致
  


]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(二)**类加载子系统</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%BA%8C)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[JVM虚拟机详解(二)类加载子系统1. 内存结构概述

💡 注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有




2.类加载器子系统
类加载器子系统作用：

类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。
ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。
加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）

  


3. 类加载器ClassLoader角色
class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。
class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。
在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。


4.类加载过程例如下面的一段简单的代码
/** * 类加载子系统 * @author peppa * @create 2022-02-08 16:51:45 */public class HelloLoader &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;我已经被加载啦...&quot;);    &#125;&#125;


它的加载过程是怎么样的呢?

执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader
加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main
加载失败则抛出异常

  
  完整的流程图如下所示
  


5. 加载阶段
加载：

通过一个类的全限定名获取定义此类的二进制字节流
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口


加载class文件的方式

从本地系统中直接加载
通过网络获取，典型场景：Web Applet
从zip压缩包中读取，成为日后jar、war格式的基础
运行时计算生成，使用最多的是：动态代理技术
由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见
从加密文件中获取，典型的防Class文件被反编译的保护措施



6. 链接阶段链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析

验证(Verify)

目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。


举例
  使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。
  工具：Binary Viewer查看，工具下载地址：Binary Viewer Page (proxoft.com)
  
  如果出现不合法的字节码文件，那么将会验证不通过，同时我们可以通过安装IDEA的插件，来查看我们的Class文件

安装Binary Viewer
  同时我们可以通过安装IDEA的插件，来查看我们的Class文件
  

配置插件参数
  点击Help，点击Edit Custom Vm Options…，增加以下配置后重启IDEA。
  -Duser.language=en-Duser.region=CN
  安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了
  



准备(Prepare)

为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值
这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化
注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中


举例

  代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1
  /** * @author peppa * @create 2022-02-08 17:36:28 */public class HelloApp &#123;    private static int a = 1;  // 准备阶段为0，在下个阶段，也就是初始化的时候才是1    public static void main(String[] args) &#123;        System.out.println(a);    &#125;&#125;

解析(Resolve)

将常量池内的符号引用转换为直接引用的过程
事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行
符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等


符号引用

反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用

  




7.初始化阶段
类的初始化时机

创建类的实例
访问某个类或接口的静态变量，或者对该静态变量赋值
调用类的静态方法
反射（比如：Class.forName(“com.atguigu.Test”)）
初始化一个类的子类
Java虚拟机启动时被标明为启动类的类
JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

  除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）
  

构造器方法&lt;clinit&gt;()方法

初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程
此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法
&lt;clinit&gt;()方法中的指令按语句在源文件中出现的顺序执行
&lt;clinit&gt;()不同于类的构造器。（关联：构造器是虚拟机视角下的&lt;init&gt;()）
若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕
虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁


案例1：有static变量
  查看下面这个代码的字节码，可以发现有一个&lt;clinit&gt;()方法。
  package com.peppa;/** * @author peppa * @create 2022-02-09 20:38:46 */public class ClassInitTest &#123;    private static int age = 1;    static &#123;        age = 2;        number = 20;        System.out.println(age);        // System.out.println(number);  //报错：Illegal forward reference 非法的前向引用    &#125;    /**     * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10     * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会     * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）     */    private static int number = 10;    public static void main(String[] args) &#123;        System.out.println(ClassInitTest.age); // 2        System.out.println(ClassInitTest.number); // 10    &#125;&#125;
  

&lt;clint字节码&gt;：当我们代码中包含static变量的时候，就会有clinit方法

  0: iconst_11: putstatic     #3                   // Field age:I4: iconst_25: putstatic     #3                   // Field age:I8: bipush        20                   // 先赋20                    10: putstatic     #5                  // Field number:I13: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;16: getstatic     #3                  // Field age:I19: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V22: bipush        10                  // 再赋10       24: putstatic     #5                  // Field number:I27: return

案例2：无static变量


package com.peppa;/** * @author peppa * @create 2022-02-09 20:38:46 */public class NonStaticClassInitTest &#123;    private int age = 1;    private int number = 10;    public static void main(String[] args) &#123;        System.out.println(&quot;this is NonStaticClassInitTest.class&quot;);    &#125;&#125;



案例3：关于涉及到父类时候的变量赋值过程

若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕

  package com.peppa;/** * @author peppa * @create 2022-02-09 22:32:26 */public class SubClassInitTest &#123;    static class Animal &#123;        public static int A = 1;        static &#123;            A = 2;        &#125;    &#125;    static class Dog extends Animal &#123;        public static int B = A;    &#125;    public static void main(String[] args) &#123;        System.out.println(Dog.B);  // 2    &#125;&#125;
  如上代码，加载流程如下：

首先，执行 main() 方法需要加载 SubClassInitTest 类
获取 Dog .B 静态变量，需要加载 Dog 类
Dog 类的父类是 Animal 类，所以需要先执行 Animal 类的加载，再执行 Dog 类的加载


案例4：虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁
  package com.peppa;public class DeadThreadTest &#123;    public static void main(String[] args) &#123;        Runnable r = () -&gt; &#123;            System.out.println(Thread.currentThread().getName() + &quot;开始&quot;);            DeadThread dead = new DeadThread();            System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);        &#125;;        Thread t1 = new Thread(r,&quot;线程1&quot;);        Thread t2 = new Thread(r,&quot;线程2&quot;);        t1.start();        t2.start();    &#125;&#125;class DeadThread&#123;    static&#123;        if(true)&#123;            System.out.println(Thread.currentThread().getName() + &quot;初始化当前类&quot;);            while(true)&#123;            &#125;        &#125;    &#125;&#125;// 执行结果:	线程2开始	线程1开始	线程2初始化当前类	/**然后程序卡死了**/
  程序卡死，分析原因：

两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环
先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放
所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(五)**程序计数器(PC寄存器)PC Register</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%BA%94)%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8(PC%E5%AF%84%E5%AD%98%E5%99%A8)PC%20Register/</url>
    <content><![CDATA[JVM虚拟机详解(五)程序计数器(PC寄存器)PC Register1. 概述Java 虚拟机可以同时支持多个线程的执行(jls17)。每个 Java 虚拟机线程都有自己的 pc (程序计数器)寄存器。在任何时候，每个 Java 虚拟机线程都在执行单个方法的代码，即该线程的当前方法(2.6)。如果这个方法不是本机的，那么 pc 寄存器就会包含当前正在执行的 Java 虚拟指令的地址。如果当前由线程执行的方法是本机的，那么 Java 虚拟机的 pc 寄存器的值是未定义的。Java 虚拟机的 pc 寄存器足够宽，可以在特定平台上保存 returnAddress 或本机指针。
官网：The Java® Virtual Machine Specification (oracle.com)


JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。
这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。
它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。
它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。


作用
  PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。
  
  内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。

代码实现
  package com.peppa.register;/**程序计数器 * @author: peppa * @create: 2022-02-10 13:25:3 */public class PCRegisterTest &#123;    public static void main(String[] args) &#123;        int i = 10;        int j = 20;        int k = i + j;    &#125;&#125;
  然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。
  0: bipush        102: istore_13: bipush        205: istore_26: iload_17: iload_28: iadd9: istore_310: return
  通过PC寄存器，我们就可以知道当前程序执行到哪一步了
  
  

使用PC寄存器存储字节码指令地址有什么用呢？
  因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
  JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
  

PC寄存器为什么被设定为私有的？

我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。
由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。
这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。



2.CPU 时间片
CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。
在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。


]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(八)堆Heap</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%85%AB)%E5%A0%86Heap/</url>
    <content><![CDATA[JVM虚拟机详解(八)堆Heap1. 概述
概述
Java 虚拟机有一个堆，它在所有 Java 虚拟机线程之间共享。堆是运行时数据区域，从中分配所有类实例和数组的内存。
在虚拟机启动时创建堆。对象的堆存储由自动存储管理系统(称为垃圾收集器)回收; 对象永远不会显式释放。Java 虚拟机没有特定类型的自动存储管理系统，可以根据实现者的系统需求选择存储管理技术。堆的大小可以是固定的，也可以根据计算的需要进行扩展，如果不需要更大的堆，还可以进行收缩。堆的内存不需要是连续的。
一个 Java 虚拟机实现可以提供程序员或用户对堆的初始大小的控制，以及，如果堆可以动态扩展或收缩，对堆的最大和最小大小的控制。
所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。
《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）• 从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）
数组和对象可能永远不会存储在栈上（不一定），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
也就是触发了GC的时候，才会进行回收
如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word


堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。


下列异常情况与堆相关联:
如果计算需要比自动存储管理系统所能提供的更多的堆，那么 Java 虚拟机将抛出 OutOfMemoryError 错误。


默认堆大小：
Xms：初始大小内存，默认为物理内存64&#x2F;1，等价于-XX:InitialHeapSize
Xmx：最大分配内存，默认为物理内存的4&#x2F;1，等价于：-XXMaxHeapSize



官网：Chapter 2. The Structure of the Java Virtual Machine (oracle.com)



堆内存细分
  现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：

Java7 及之前堆内存逻辑上分为三部分：新生代+老年代+永久区
Young Generation Space 新生代 Young&#x2F;New
又被划分为Eden区和Survivor区


Old generation space 老年代 Old&#x2F;Tenure
Permanent Space 永久区 Perm


Java 8及之后堆内存逻辑上分为三部分：新生代+老年代+元空间


Young Generation Space 新生代，又被划分为Eden区和Survivor区
Old generation space 老年代
Meta Space 元空间 Meta

  


堆空间内部结构，JDK1.8之前从永久代 替换成 元空间

2.JVisualVM可视化查看堆内存运行代码
package com.peppa.heap;import java.util.concurrent.TimeUnit;public class HeapDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        System.out.println(&quot;start...&quot;);        TimeUnit.MINUTES.sleep(30);        System.out.println(&quot;end...&quot;);    &#125;&#125;

1、双击jdk目录下的这个文件

2、工具 -&gt; 插件 -&gt; 安装Visual GC插件

3、运行上面的代码
3.设置堆内存大小与OOM
设置堆内存

Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。

Xms用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**
Xmx则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**


一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。

通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。

原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。
如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM


默认情况下:

初始内存大小：物理电脑内存大小&#x2F;64
最大内存大小：物理电脑内存大小&#x2F;4

 package com.peppa.heap;/** * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小 *  -X：是jvm运行参数 *  ms：memory start * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小 * @author peppa * @create 2022-02-11 14:33:20 */public class HeapSpaceInitial &#123;    public static void main(String[] args) &#123;        // 返回Java虚拟机中的堆内存总量        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;        // 返回Java虚拟机试图使用的最大堆内存        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;        System.out.println(&quot;-Xms:&quot; + initialMemory + &quot;M&quot;);        System.out.println(&quot;-Xmx:&quot; + maxMemory + &quot;M&quot;);    &#125;&#125;// 输出结果-Xms:303M-Xmx:4482M


如何查看堆内存的内存分配情况

jps  -&gt;  staat -gc  进程id
  参数说明：

SOC: S0区总共容量
S1C: S1区总共容量
S0U: S0区使用的量
S1U: S1区使用的量
EC: 伊甸园区总共容量
EU: 伊甸园区使用的量
OC: 老年代总共容量
OU: 老年代使用的量

  
  -XX:+PrintGCDetails
  



OutOfMemory测试


添加参数：Xms600m -Xmx600m -XX:+PrintGCDetails
package com.peppa.heap;import java.util.ArrayList;import java.util.List;public class OutOfMemoryTest &#123;    public static void main(String[] args) &#123;        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();        while (true)&#123;            list.add(new byte[1024*1024]);        &#125;    &#125;&#125;

 执行结果：
D:\software\Java\jdk1.8\jdk1.8.0_241\bin\java.exe -Xms600m -Xmx600m -XX:+PrintGCDetails &quot;-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2021.3.1\lib\idea_rt.jar=4979:D:\Program Files\JetBrains\IntelliJ IDEA 2021.3.1\bin&quot; -Dfile.encoding=UTF-8 -classpath D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\charsets.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\deploy.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\access-bridge-64.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\cldrdata.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\dnsns.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\jaccess.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\jfxrt.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\localedata.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\nashorn.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\sunec.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\sunjce_provider.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\sunmscapi.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\sunpkcs11.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\zipfs.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\javaws.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\jce.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\jfr.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\jfxswt.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\jsse.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\management-agent.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\plugin.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\resources.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\rt.jar;E:\workspace\IdeaWork\other\peppa-platform\peppa-jvm\target\classes com.peppa.heap.OutOfMemoryTest[GC (Allocation Failure) [PSYoungGen: 152578K-&gt;25384K(179200K)] 152578K-&gt;145202K(588800K), 0.0190912 secs] [Times: user=0.05 sys=0.08, real=0.02 secs] [GC (Allocation Failure) [PSYoungGen: 178893K-&gt;25336K(179200K)] 298711K-&gt;297740K(588800K), 0.0233429 secs] [Times: user=0.05 sys=0.06, real=0.02 secs] [Full GC (Ergonomics) [PSYoungGen: 25336K-&gt;0K(179200K)] [ParOldGen: 272404K-&gt;297589K(409600K)] 297740K-&gt;297589K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0556161 secs] [Times: user=0.28 sys=0.00, real=0.05 secs] [Full GC (Ergonomics) [PSYoungGen: 153530K-&gt;37888K(179200K)] [ParOldGen: 297589K-&gt;409208K(409600K)] 451120K-&gt;447096K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0254560 secs] [Times: user=0.06 sys=0.05, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 153506K-&gt;152578K(179200K)] [ParOldGen: 409208K-&gt;409208K(409600K)] 562714K-&gt;561786K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0175328 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] [Full GC (Allocation Failure) [PSYoungGen: 152578K-&gt;152578K(179200K)] [ParOldGen: 409208K-&gt;409190K(409600K)] 561786K-&gt;561768K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0235650 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] Heap PSYoungGen      total 179200K, used 153600K [0x00000000f3800000, 0x0000000100000000, 0x0000000100000000)  eden space 153600K, 100% used [0x00000000f3800000,0x00000000fce00000,0x00000000fce00000)  from space 25600K, 0% used [0x00000000fe700000,0x00000000fe700000,0x0000000100000000)  to   space 25600K, 0% used [0x00000000fce00000,0x00000000fce00000,0x00000000fe700000) ParOldGen       total 409600K, used 409194K [0x00000000da800000, 0x00000000f3800000, 0x00000000f3800000)  object space 409600K, 99% used [0x00000000da800000,0x00000000f379abf0,0x00000000f3800000) Metaspace       used 3260K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: **Java heap space**	at com.peppa.heap.OutOfMemoryTest.main(OutOfMemoryTest.java:10)

4.年轻代与老年代
存储对象划分：

存储在JVM中的Java对象可以被划分为两类：
一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速，生命周期短的，及时回收即可。
另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致


Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）
其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）

  
  下面这参数开发中一般不会调：
  

配置新生代与老年代在堆结构的占比
默认**-XX:NewRatio**&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3
可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5




在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，
当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8
几乎所有的Java对象都是在Eden区被new出来的。
绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。

  


5.图解对象分配过程
概念
  为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

new的对象先放伊甸园区。此区有大小限制。
当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
然后将伊甸园中的剩余对象移动到幸存者0区。
如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。
如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
啥时候能去养老区呢？可以设置次数。默认是15次。
在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理
若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。

  可以设置参数：-Xx:MaxTenuringThreshold&#x3D; N进行设置
  

图解过程
  我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC &#x2F; Minor GC操作
  
  当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。
  同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1
  
  我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中
  

幸存区区满了后？
  特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作
  如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代

对象分配的特殊情况

如果来了一个新对象，先看看 Eden 是否放的下？
如果 Eden 放得下，则直接放到 Eden 区
如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？


将对象放到老年区又有两种情况：
如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代
那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM


如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区

  
  

代码演示对象分配过程


我们不断的创建大对象
package com.peppa.heap;import java.util.ArrayList;import java.util.Random;/** * 代码演示对象创建过程 * * @author: peppa * @create: 2022-02-11 17:27:58 */public class HeapInstanceTest &#123;    byte [] buffer = new byte[new Random().nextInt(1024 * 200)];    public static void main(String[] args) throws InterruptedException &#123;        ArrayList&lt;HeapInstanceTest&gt; list = new ArrayList&lt;&gt;();        while (true) &#123;            list.add(new HeapInstanceTest());            Thread.sleep(10);        &#125;    &#125;&#125;

然后设置JVM参数：-Xms600m -Xmx600m
打开VisualVM图形化界面

最终，在老年代和新生代都满了，就出现OOM
D:\software\Java\jdk1.8\jdk1.8.0_241\bin\java.exe -Xms600m -Xmx600mException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space	at com.peppa.heap.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:12)	at com.peppa.heap.HeapInstanceTest.main(HeapInstanceTest.java:16)Process finished with exit code 1


常用调优工具

JDK命令行
Eclipse：Memory Analyzer Tool
Jconsole
Visual VM（实时监控，推荐）
Jprofiler（IDEA插件）
Java Flight Recorder（实时监控）
GCViewer
GCEasy


GC分类

Minor GC，MajorGC、Full GC

Minor GC：新生代的GC
Major GC：老年代的GC
Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集


我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题，而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上


部分收集（Partial GC）&amp;&amp; 整堆收集（FullGC）

新生代收集（MinorGC&#x2F;YoungGC）：只是新生代的垃圾收集
老年代收集（MajorGC&#x2F;o1dGC）：只是老年代的圾收集。
目前，只有CMSGC会有单独收集老年代的行为。
注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。




整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。

Young GC
  当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）
  因为Java对象大多都具备 朝生夕灭 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
  Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行
  

老年代GC（MajorGC）触发机制

指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了
出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）
也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC


Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。
如果Major GC后，内存还不足，就报OOM了


触发Full GC执行的情况有如下五种：

调用System.gc()时，系统建议执行FullGC，但是不必然执行
老年代空间不足
方法区空间不足
通过Minor GC后进入老年代的平均大小大于老年代的可用内存
由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小




GC日志分析
  package com.peppa.gc;import java.util.ArrayList;import java.util.List;/** * 测试MinorGC 、 MajorGC、FullGC * -Xms9m -Xmx9m -XX:+PrintGCDetails * @author shkstart  shkstart@126.com * @create 2020  14:19 */public class GCTest &#123;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            List&lt;String&gt; list = new ArrayList&lt;&gt;();            String a = &quot;this is peppa&quot;;            while (true) &#123;                list.add(a);                a = a + a;                i++;            &#125;        &#125; catch (Throwable t) &#123;            t.printStackTrace();            System.out.println(&quot;遍历次数为：&quot; + i);        &#125;    &#125;&#125;
  输出：
  [GC (Allocation Failure) [PSYoungGen: 1964K-&gt;510K(2560K)] 1964K-&gt;826K(9728K), 0.0008721 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2361K-&gt;496K(2560K)] 2677K-&gt;1489K(9728K), 0.0007112 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1796K-&gt;384K(2560K)] 2790K-&gt;2417K(9728K), 0.0009442 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 2151K-&gt;0K(2560K)] [ParOldGen: 7025K-&gt;5682K(7168K)] 9177K-&gt;5682K(9728K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0029911 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5682K-&gt;5682K(9728K), 0.0004552 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5682K-&gt;5599K(7168K)] 5682K-&gt;5599K(9728K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0058927 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 遍历次数为：16Heap PSYoungGen      total 2560K, used 101K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  eden space 2048K, 4% used [0x00000000ffd00000,0x00000000ffd19568,0x00000000fff00000)  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen       total 7168K, used 5599K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  object space 7168K, 78% used [0x00000000ff600000,0x00000000ffb77d90,0x00000000ffd00000) Metaspace       used 3259K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576Kjava.lang.OutOfMemoryError: Java heap space	at java.util.Arrays.copyOf(Arrays.java:3332)	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)	at java.lang.StringBuilder.append(StringBuilder.java:136)	at com.peppa.gc.GCTest.main(GCTest.java:20)Process finished with exit code 0
  [GC (Allocation Failure) [PSYoungGen: 1964K-&gt;510K(2560K)] 1964K-&gt;826K(9728K), 0.0008721 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[PSYoungGen: 1964K-&gt;510K(2560K)]：年轻代总空间为 2560K ，当前占用 1964K ，经过垃圾回收后剩余510K****
1964K-&gt;826K(9728K)：堆内存总空间为 9728K ，当前占用1964K，经过垃圾回收后剩余826K

  
  
  

堆空间分代思想
  为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。

新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。
老年代：存放新生代中经历多次GC仍然存活的对象。

  
  其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。
  
  

内存分配策略
  如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代
  对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置
  针对不同年龄段的对象分配原则如下所示：

优先分配到Eden
开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢


大对象直接分配到老年代
尽量避免程序中出现过多的大对象


长期存活的对象分配到老年代
动态对象年龄判断
如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。



  空间分配担保： -Xx:HandlePromotionFailure

也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。


为对象分配内存：TLAB

问题：堆空间都是共享的么？
  不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占

为什么有TLAB？
  从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
  多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。
  据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。
  
  尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
  在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。
  默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。
  一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

TLAB分配过程
  对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配
  



小结：堆空间的参数设置

XX：+PrintFlagsInitial：查看所有的参数的默认初始值
XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）
Xms：初始堆空间内存（默认为物理内存的1&#x2F;64）
Xmx：最大堆空间内存（默认为物理内存的1&#x2F;4）
Xmn：设置新生代的大小。（初始值及最大值）
XX:NewRatio：配置新生代与老年代在堆结构的占比
XX:SurvivorRatio：设置新生代中Eden和S0&#x2F;S1空间的比例
XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄
XX：+PrintGCDetails：输出详细的GC处理日志
打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc


XX:HandlePromotionFalilure：是否设置空间分配担保

  在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。

如果大于，则此次Minor GC是安全的
如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。
如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
如果小于，则改为进行一次FullGC。
如果HandlePromotionFailure&#x3D;false，则改为进行一次Full GC



  在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。

堆是分配对象的唯一选择么？
  在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：

随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。
在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。
此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。



6.逃逸分析
逃逸分析

如何将堆上的对象分配到栈，需要使用逃逸分析手段。
这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
逃逸分析的基本行为就是分析对象动态作用域：
当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。




逃逸分析举例

没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）

  public void my_method() &#123;    V v = new V();    // use v    // ....    v = null;&#125;

下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配

  public static StringBuffer createStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb;&#125;

如果想要StringBuffer sb不发生逃逸，可以这样写

  public static String createStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb.toString();&#125;
  /** * 逃逸分析 * *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。 */public class EscapeAnalysis &#123;    public EscapeAnalysis obj;    /*    方法返回EscapeAnalysis对象，发生逃逸     */    public EscapeAnalysis getInstance()&#123;        return obj == null? new EscapeAnalysis() : obj;    &#125;    /*    为成员属性赋值，发生逃逸     */    public void setObj()&#123;        this.obj = new EscapeAnalysis();    &#125;    //思考：如果当前的obj引用声明为static的？仍然会发生逃逸。    /*    对象的作用域仅在当前方法中有效，没有发生逃逸     */    public void useEscapeAnalysis()&#123;        EscapeAnalysis e = new EscapeAnalysis();    &#125;    /*    引用成员变量的值，发生逃逸     */    public void useEscapeAnalysis1()&#123;        EscapeAnalysis e = getInstance();        //getInstance().xxx()同样会发生逃逸    &#125;&#125;

逃逸分析参数设置

在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析
如果使用的是较早的版本，开发人员则可以通过：
选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析
通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果




结论
  开发中能使用局部变量的，就不要使用在方法外定义。
  使用逃逸分析，编译器可以对代码做如下优化：

栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配
同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。



7.栈上分配
栈上分配举例

JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。
常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。


举例

设置JVM参数，表示未开启逃逸分析
  package com.peppa.heap;import java.util.concurrent.TimeUnit;/** * 栈上分配： * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails * 开启逃逸分析： * -Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails */public class StackAllocation &#123;    public static void main(String[] args) throws InterruptedException &#123;        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10000000; i++) &#123;            alloc();        &#125;        // 查看执行时间        long end = System.currentTimeMillis();        System.out.println(&quot;花费的时间为： &quot; + (end - start) + &quot; ms&quot;);        // 为了方便查看堆内存中对象个数，线程sleep        TimeUnit.MINUTES.sleep(1);    &#125;    private static void alloc() &#123;        User user = new User();//未发生逃逸    &#125;    static class User &#123;        private String name;        private String age;        private String gender;        private String phone;    &#125;&#125;

参数：-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails

运行结果，同时还触发了GC操作
  [GC (Allocation Failure) [PSYoungGen: 262144K-&gt;728K(305664K)] 262144K-&gt;736K(1005056K), 0.0007353 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 花费的时间为： 120 ms


我们开启逃逸分析

参数：-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails

运行结果：日志打印：并没有发生 GC ，耗时5ms 。
  花费的时间为： 5 ms



8.同步省略
概述：线程同步的代价是相当高的，同步的后果是降低并发性和性能。
  在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。
  例如下面的代码：
  public void f() &#123;    Object hellis = new Object();    synchronized(hellis) &#123;        System.out.println(hellis);    &#125;&#125;
  代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：
  public void f() &#123;    Object hellis = new Object();	System.out.println(hellis);&#125;
  0 new #2 &lt;java/lang/Object&gt;3 dup4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;7 astore_18 aload_19 dup10 astore_211 monitorenter12 getstatic #3 &lt;java/lang/System.out&gt;15 aload_116 invokevirtual #4 &lt;java/io/PrintStream.println&gt;19 aload_220 monitorexit21 goto 29 (+8)24 astore_325 aload_226 monitorexit27 aload_328 athrow29 return
  注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，同步省略操作是在解释运行时发生的


9.分离对象或标量替换
标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。
相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。


标量替换举例

代码

  public static void main(String args[]) &#123;    alloc();&#125;class Point &#123;    private int x;    private int y;&#125;private static void alloc() &#123;    Point point = new Point(1,2);    System.out.println(&quot;point.x&quot; + point.x + &quot;;point.y&quot; + point.y);&#125;

以上代码，经过标量替换后，就会变成

  private static void alloc() &#123;    int x = 1;    int y = 2;    System.out.println(&quot;point.x = &quot; + x + &quot;; point.y=&quot; + y);&#125;
  可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。
  

标量替换参数设置
  package com.peppa.heap;/** * 不开启标量替换： *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations * * [GC (Allocation Failure)  25600K-&gt;816K(98304K), 0.0007805 secs] * [GC (Allocation Failure)  26416K-&gt;832K(98304K), 0.0005552 secs] * [GC (Allocation Failure)  26432K-&gt;704K(98304K), 0.0010244 secs] * [GC (Allocation Failure)  26304K-&gt;752K(98304K), 0.0006991 secs] * [GC (Allocation Failure)  26352K-&gt;704K(98304K), 0.0006366 secs] * [GC (Allocation Failure)  26304K-&gt;720K(101376K), 0.0008407 secs] * [GC (Allocation Failure)  32464K-&gt;652K(101376K), 0.0010512 secs] * [GC (Allocation Failure)  32396K-&gt;652K(100352K), 0.0003788 secs] * 花费的时间为： 64 ms * * 开启标量替换： *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations *  花费的时间为： 4 ms */public class ScalarReplace &#123;    public static class User &#123;        public int id;        public String name;    &#125;    public static void alloc() &#123;        User u = new User();//未发生逃逸        u.id = 5;        u.name = &quot;peppa&quot;;    &#125;    public static void main(String[] args) &#123;        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10000000; i++) &#123;            alloc();        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;花费的时间为： &quot; + (end - start) + &quot; ms&quot;);    &#125;&#125;

逃逸分析的不足

关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。
其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。
一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。
虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。
注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上。
目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。


小结

年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。
老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。
当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；
如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；
如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。
当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。
当GC发生在老年代时则被称为Major GC或者Full GC。
一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(六)**本地方法栈Native Method Stacks</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%85%AD)%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88Native%20Method%20Stacks/</url>
    <content><![CDATA[JVM虚拟机详解(六)本地方法栈Native Method Stacks1. 概述Java 虚拟机的实现可以使用传统的栈(通常称为“ c 栈”)来支持本机方法(用 Java 编程语言以外的语言编写的方法)。本机方法堆栈也可以用于 Java 虚拟机指令集的解释器的实现，如 c 语言的 Java 虚拟机实现，不能加载本机方法，也不依赖于传统的堆栈，不需要提供本机方法堆栈。如果提供，通常在创建每个线程时为每个线程分配本机方法堆栈。
该规范允许本机方法堆栈具有固定的大小，或者根据计算的需要动态扩展和收缩。如果本机方法堆栈的大小固定，则在创建该堆栈时可以独立选择每个本机方法堆栈的大小。
Java 虚拟机实现可以为程序员或用户提供对本机方法堆栈初始大小的控制，以及对于不同大小的本机方法堆栈，对最大和最小方法堆栈大小的控制。

下面的异常情况与本机方法堆栈相关联:
如果线程中的计算需要比允许的更大的本机方法堆栈，那么 Java 虚拟机抛出一个 StackOverflowError。
如果本机方法堆栈可以动态扩展，本机方法堆栈扩展可以尝试，但是没有足够的内存可用，或者如果没有足够的内存可用来为新线程创建初始的本机方法堆栈，Java 虚拟机将抛出 OutOfMemoryError。



官网：Chapter 2. The Structure of the Java Virtual Machine (oracle.com)

简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。
“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）
在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。
本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。

代码举例说明Native方法是如何编写的
  需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外
  public class IHaveNatives &#123;    public native void Native1(int x);    public native static long Native2();    private native synchronized float Native3(Object o);    native void Native4(int[] ary) throws Exception;    &#125;

为什么使用Native Method？

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。


与Java环境的交互

有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。


与操作系统的交互

JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。


Sun’s Java

Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。
例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十)对象的实例化内存布局与访问定位</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81)%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[JVM虚拟机详解(十)对象的实例化内存布局与访问定位1. 创建对象

对象创建方式

new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法
Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器
Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器
使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口
使用序列化：序列化一般用于Socket的网络传输
第三方库 Objenesis


创建对象的步骤

判断对象对应的类是否加载、链接、初始化
 public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=2, args_size=1         0: new           #2                  // class java/lang/Object         3: dup         4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         7: astore_1         8: return      LineNumberTable:        line 5: 0        line 6: 8      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       9     0  args   [Ljava/lang/String;            8       1     1   obj   Ljava/lang/Object;    MethodParameters:      Name                           Flags      args
 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。

为对象分配内存

首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小
如果内存规整：采用指针碰撞分配内存
如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。
意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。
如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。
标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域


如果内存不规整
如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。
意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”
选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
标记清除算法清理过后的堆内存，就会存在很多内存碎片。




处理并发问题

采用CAS+失败重试保证更新的原子性
每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）
在Eden区给每个线程分配一块区域


初始化分配到的空间

所有属性设置默认值，保证对象实例字段在不赋值可以直接使用
给对象属性赋值的顺序：
属性的默认值初始化
显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）
构造器初始化




置对象的对象头
 将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。


  6.执行init方法进行初始化

在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。

  从字节码角度看 init 方法
  源代码
  package com.peppa.area;public class Customer &#123;    int id = 1001;    String name;    Account acct;    &#123;        name = &quot;匿名客户&quot;;    &#125;    public Customer()&#123;        acct = new Account();    &#125;&#125;class Account&#123;&#125;
  字节码
  0: aload_01: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V4: aload_05: sipush        10018: putfield      #2                  // Field id:I11: aload_012: ldc           #3                  // String 匿名客户14: putfield      #4                  // Field name:Ljava/lang/String;17: aload_018: new           #5                  // class com/peppa/area/Account21: dup22: invokespecial #6                  // Method com/peppa/area/Account.&quot;&lt;init&gt;&quot;:()V25: putfield      #7                  // Field acct:Lcom/peppa/area/Account;28: return

init() 方法的字节码指令：
属性的默认值初始化：id = 1001;
显示初始化&#x2F;代码块初始化：name = &quot;匿名客户&quot;;
构造器初始化：acct = new Account();



2. 对象的内存布局
对象的内存布局思维导图
  

对象头

对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针
如果是数组，还需要记录数组的长度


运行时元数据
哈希值（HashCode）
GC分代年龄
锁状态标志
线程持有的锁
偏向线程ID
翩向时间戳


类型指针
指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息




图解内存布局


  

对象的访问定位
JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？
  定位，通过栈上reference访问
  

对象的两种访问方式：句柄访问和直接指针

句柄访问

缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低
优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改

  



直接指针（HotSpot采用）

优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据

缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值
 








]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十)对象的实例化内存布局与访问定位</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%B8%80)%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8EExecution%20Engine/</url>
    <content><![CDATA[JVM虚拟机详解(十一)执行引擎Execution Engine1. 执行引擎概述
概述

执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器
执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

  
  JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。
  
  那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。
  

执行引擎的工作流程

执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。
每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。
当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。

  
  从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。


2.Java代码编译和执行过程
编译和执行过程

大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤

前面橙色部分是生成字节码文件的过程，和JVM无关

后面蓝色和绿色才是JVM需要考虑的过程
  



Java代码编译是由Java源码编译器来完成，流程图如下所示：


  

Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示

  

我们用一个总的图，来说说 解释器和编译器





什么是解释器（Interpreter）
  当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

什么是JIT编译器

JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。


为什么Java是半编译半解释型语言
  JDK1.e时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。
  翻译成本地代码后，就可以做一个缓存操作，存储在方法区中

机器码、指令、汇编语言

机器码
  各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。
  机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。
  用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。
  机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。

指令
  由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。
  指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好
  由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。

指令集
  不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的

x86指令集，对应的是x86架构的平台
ARM指令集，对应的是ARM架构的平台


汇编语言
  由于指令的可读性还是太差，于是人们又发明了汇编语言。
  在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。

由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。





3.高级语言
高级计算机语言
  为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。
  高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。



高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++

C、C++源程序执行过程
  编译过程又可以分成两个阶段：编译和汇编。
  编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码
  汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。
  

字节码
  字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码
  字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。
  字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。

字节码典型的应用为：Java bytecode


解释器
  JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。
  
  为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的
  解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
  当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。

解释器分类
  在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。
  字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。
  而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。
  在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。

Interpreter模块：实现了解释器的核心功能
Code模块：用于管理HotSpot VM在运行时生成的本地机器指令


现状
  由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。
  为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。
  不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。


4.JIT编译器
Java代码的执行分类

第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行
第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行
HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。
在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。


为啥我们还需要解释器呢？

有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。
JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能


首先明确两点：

当程序启动后，解释器可以马上发挥作用，响应速度快，省去编译的时间，立即执行。
编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间，但编译为本地代码后，执行效率高。

  所以：

尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。
在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。

  案例
  注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。
  在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队
  
  

JIT编译器相关概念

Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。
也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。
还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）

  典型的编译器：

前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。
JIT编译器：HotSpot VM的C1、C2编译器。
AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。


热点代码及探测方式

当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。
关于那些需要被编译为本地代码的字节码，也被称之为**“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化**，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。
一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。
一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。
目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。
采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。
方法调用计数器用于统计方法的调用次数
回边计数器则用于统计循环体执行的循环次数




方法调用计数器

这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。

这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。

当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本

如果存在，则优先使用编译后的本地代码来执行
如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。
如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。
如果未超过阈值，则使用解释器对字节码文件解释执行



 



热度衰减

如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）
进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。
另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。


回边计数器
  它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。
  

HotSpotVM 可以设置程序执行方法
  缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：

Xint：完全采用解释器模式执行程序；
Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
Xmixed：采用解释器+即时编译器的混合模式共同执行程序。

  
  

HotSpotVM JIT 分类
  在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：

client：指定Java虚拟机运行在Client模式下，并使用C1编译器；
C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。


server：指定Java虚拟机运行在server模式下，并使用C2编译器。
C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）




C1和C2编译器不同的优化策略

在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。
方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
去虚拟化：对唯一的实现樊进行内联
冗余消除：在运行期间把一些不会执行的代码折叠掉


C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：
标量替换：用标量值代替聚合对象的属性值
栈上分配：对于未逃逸的对象分配对象在栈而不是堆
同步消除：清除同步操作，通常指synchronized




分层编译策略

分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。
不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。
一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高
C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器


Graal 编译器

自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器
编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）
目前，带着实验状态标签，需要使用开关参数去激活才能使用
XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler




AOT编译器

jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）

Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。

所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。
 .java -&gt; .class -&gt; (使用jaotc) -&gt; .so



AOT编译器编译器的优缺点
  最大的好处：

Java虚拟机加载已经预编译成二进制库，可以直接执行。
不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验

  缺点：

破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包
降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。
还需要继续优化中，最初只支持Linux X64 java base


最后

自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器
编译效果短短几年时间就追评了G2编译器，未来可期
目前，带着实验状态标签，需要使用开关参数去激活才能使用



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十三)垃圾回收算法</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%B8%89)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[JVM虚拟机详解(十三)垃圾回收算法1. 什么是垃圾
从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。
垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 关于垃圾收集有三个经典问题：

哪些内存需要回收？
什么时候回收？
如何回收？

垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。

什么是垃圾？

垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。
外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.
如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。


为什么需要GC？

想要学习GC，首先需要理解为什么需要GC？
对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。
随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。




早期垃圾回收

在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：
 MibBridge *pBridge= new cmBaseGroupBridge（）；  //如果注册失败，使用Delete释放该对象所占内存区域  if（pBridge-&gt;Register（kDestroy）！=NO ERROR）  	delete pBridge；

这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。

有了垃圾回收机制后，上述代码极有可能变成这样
 MibBridge *pBridge=new cmBaseGroupBridge();   pBridge-&gt;Register(kDestroy);




现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。

2.Java 垃圾回收机制
自动内存管理

官网介绍：Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide, Release 8 (oracle.com)


自动内存管理的优点

自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险
没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。
自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发


关于自动内存管理的担忧

对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。
此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。
当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。


GC主要关注的区域
  GC主要关注于 方法区 和堆中的垃圾收集
  
  垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收

其中，Java堆是垃圾收集器的工作重点

  从次数上讲：

频繁收集Young区
较少收集Old区
基本不收集Perm区（元空间）



3.垃圾回收相关算法
引用计数算法

在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。
那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。
判断对象存活一般有两种方式：引用计数算法和可达性分析算法。


引用计数算法-原理
引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
缺点：
它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。




循环引用
当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏****



  

验证Java是否采用的是引用计数算法

  package com.peppa.gc;/** * -XX:+PrintGCDetails * 引用计数算法测试 * * @author: peppa * @create: 2022-03-05 16:44:15 */public class RefCountGC &#123;    // 这个成员属性的唯一作用就是占用一点内存    private byte[] bigSize = new byte[5*1024*1024];    // 引用    Object reference = null;    public static void main(String[] args) &#123;        RefCountGC obj1 = new RefCountGC();        RefCountGC obj2 = new RefCountGC();        obj1.reference = obj2;        obj2.reference = obj1;        obj1 = null;        obj2 = null;        // 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？        System.gc();    &#125;&#125;
  [GC (System.gc()) [PSYoungGen: 15093K-&gt;808K(94208K)] 15093K-&gt;816K(310272K), 0.0010090 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(94208K)] [ParOldGen: 8K-&gt;627K(216064K)] 816K-&gt;627K(310272K), [Metaspace: 3226K-&gt;3226K(1056768K)], 0.0038155 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 94208K, used 809K [0x0000000756f80000, 0x000000075d880000, 0x00000007c0000000)  eden space 80896K, 1% used [0x0000000756f80000,0x000000075704a548,0x000000075be80000)  from space 13312K, 0% used [0x000000075be80000,0x000000075be80000,0x000000075cb80000)  to   space 13312K, 0% used [0x000000075cb80000,0x000000075cb80000,0x000000075d880000) ParOldGen       total 216064K, used 627K [0x0000000684e00000, 0x0000000692100000, 0x0000000756f80000)  object space 216064K, 0% used [0x0000000684e00000,0x0000000684e9cc80,0x0000000692100000) Metaspace       used 3233K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K
  我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了
  [GC (System.gc()) [PSYoungGen: 15093K-&gt;808K(94208K)] 15093K-&gt;816K(310272K), 0.0010090 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
   如果使用引用计数算法，那么这两个对象会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。
  

可达性分析算法

概念：
可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集
相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）




可达性分析实现思路
所谓”GCRoots”根集合就是一组必须活跃的引用

其基本思路如下：

可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）
如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记垃圾对象。
在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

  





标记-清除算法

垃圾清除阶段

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是
标记-清除算法（Mark-Sweep）
复制算法（Copying）
标记-压缩算法（Mark-Compact）


标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。


执行过程

当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除
标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
标记的是引用的对象，不是垃圾！！


清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收

  
  

标记-清除算法的缺点

标记清除算法的效率不算高
在进行GC的时候，需要停止整个应用程序，用户体验较差
这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表


注意：何为清除？

这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。
关于空闲列表是在为对象分配内存的时候提过：
如果内存规整
采用指针碰撞的方式进行内存分配


如果内存不规整
虚拟机需要维护一个空闲列表
采用空闲列表分配内存






GC Roots可以是哪些？

虚拟机栈中引用的对象
比如：各个线程被调用的方法中使用到的参数、局部变量等。


本地方法栈内JNI（通常说的本地方法）引用的对象
方法区中类静态属性引用的对象
比如：Java类的引用类型静态变量


方法区中常量引用的对象
比如：字符串常量池（StringTable）里的引用


所有被同步锁synchronized持有的对象
Java虚拟机内部的引用。
基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。


反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

  

注意
如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。
这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。






清除阶段：复制算法

背景

为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。


核心思想

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

  

把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法

  
  

优点

没有标记和清除过程，实现简单，运行高效
复制过去以后保证空间的连续性，不会出现“碎片”问题。


缺点

此算法的缺点也是很明显的，就是需要两倍的内存空间。
对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小


注意

如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）
在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。

  




4.对象的 finalization 机制
概述

Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。


对象销毁前的回调函数：finalize()

Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。


注意事项：
  永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：

在finalize（）时可能会导致对象复活。
finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。
因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收


一个糟糕的finalize（）会严重影响Gc的性能。


生存还是死亡？

由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。

如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：
可触及的：从根节点开始，可以到达这个对象。
可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。
不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。


以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。


具体过程
  判定一个对象objA是否可回收，至少要经历两次标记过程：

如果对象objA到GC Roots没有引用链，则进行第一次标记。

进行筛选，判断此对象是否有必要执行finalize（）方法

如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。
finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。

  



代码演示 finalize() 方法可复活对象

我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this
在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。

  package com.peppa.gc;/** * 测试Object类中finalize()方法，即对象的finalization机制。 * @author: peppa * @create: 2022-03-05 17:54:15 */public class CanReliveObj &#123;    //类变量，属于 GC Root    public static CanReliveObj obj;    /**     * 此方法只能被调用一次     * @throws Throwable     */    @Override    protected void finalize() throws Throwable &#123;        super.finalize();        System.out.println(&quot;调用当前类重写的finalize()方法&quot;);        //当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系        obj = this;    &#125;    public static void main(String[] args) &#123;        try &#123;            obj = new CanReliveObj();            obj = null;            System.gc();//调用垃圾回收器            System.out.println(&quot;-----------------第一次gc操作------------&quot;);            // 因为Finalizer线程优先级很低，暂停2秒，以等待它            Thread.sleep(2000);            if (obj == null) &#123;                System.out.println(&quot;obj is dead&quot;);            &#125; else &#123;                System.out.println(&quot;obj is still alive&quot;);            &#125;            System.out.println(&quot;-----------------第二次gc操作------------&quot;);            obj = null;            System.gc();            // 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了            // 因为Finalizer线程优先级很低，暂停2秒，以等待它            Thread.sleep(2000);            if (obj == null) &#123;                System.out.println(&quot;obj is dead&quot;);            &#125; else &#123;                System.out.println(&quot;obj is still alive&quot;);            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

最后运行结果

  调用当前类重写的finalize()方法-----------------第一次gc操作------------obj is still alive-----------------第二次gc操作------------obj is dead



5.MAT与JProfiler的GC Roots溯源
MAT

介绍

MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。
MAT是基于Eclipse开发的，是一款免费的性能分析工具。
下载地址：Eclipse Memory Analyzer Open Source Project | The Eclipse Foundation


获取dump文件

命令行使用 jmap

  C:\Users\yuanxw&gt;jps13376 Jps16176 RefCountGC585616824 Launcher16700 MainC:\Users\yuanxw&gt;jmap -dump:format=b,live,file=refcountgc.bin 16176Dumping heap to C:\Users\yuanxw\refcountgc.bin ...Heap dump file created

打开后，我们就可以看到有哪些可以作为GC Roots的对象

  



JProfiler

JProfiler的GC Roots溯源

在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫GC Roots 溯源
下面我们使用使用 JProfiler 进行 GC Roots 溯源演示

  
  - 

如何判断什么原因造成OOM

当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明

  package com.peppa.gc;import java.util.ArrayList;/** * 内存溢出排查 * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError * 这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件 */public class HeapOOM &#123;    byte[] buffer = new byte[1 * 1024 * 1024];//1MB    public static void main(String[] args) &#123;        ArrayList&lt;HeapOOM&gt; list = new ArrayList&lt;&gt;();        int count = 0;        try&#123;            while(true)&#123;                list.add(new HeapOOM());                count++;            &#125;        &#125;catch (Throwable e)&#123;            System.out.println(&quot;count = &quot; + count);            e.printStackTrace();        &#125;    &#125;&#125;
  上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出
  java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid7196.hprof ...Heap dump file created [7705267 bytes in 0.009 secs]count = 6java.lang.OutOfMemoryError: Java heap space	at com.peppa.gc.HeapOOM.&lt;init&gt;(HeapOOM.java:10)	at com.peppa.gc.HeapOOM.main(HeapOOM.java:18)
  我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象
  
  然后我们通过线程，还能够定位到哪里出现OOM
  



清除阶段：标记-整理算法

背景

复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。
标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。


执行过程

第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象

第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。
  



标清和标整的区别

标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。
二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。
标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。


标整的优缺点

优点
消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
消除了复制算法当中，内存减半的高额代价。


缺点
从效率上来说，标记-整理算法要低于复制算法。
移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）
移动过程中，需要全程暂停用户应用程序。即：STW






垃圾回收算法小结

对比三种清除阶段的算法

效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。
而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。





标记清除
标记整理
复制



速率
中等
最慢
最快


空间开销
少（但会堆积碎片）
少（不堆积碎片）
通常需要活对象的2倍空间（不堆积碎片）


移动对象
否
是
是



分代收集算法

前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。
分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。
在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。


目前几乎所有的GC都采用分代手机算法执行垃圾回收的
  在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。

年轻代（Young Gen）
  年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。
  这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。

老年代（Tenured Gen）
  老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
  这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。

Mark阶段的开销与存活对象的数量成正比。
Sweep阶段的开销与所管理区域的大小成正相关。
compact阶段的开销与存活对象的数据成正比。



  以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。
  分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代



增量收集算法

概述

上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。


增量收集算法基本思想

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作


增量收集算法的缺点

使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。


分区算法

概述

一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。
分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

  






]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十二)StringTable(字符串常量池)</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%BA%8C)StringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/</url>
    <content><![CDATA[JVM虚拟机详解(十二)StringTable(字符串常量池)1. StringTable(字符串常量池)
String的基本特性

String：字符串，使用一对 ”” 引起来表示

  String s1 = &quot;peppa&quot; ;   			// 字面量的定义方式String s2 =  new String(&quot;hello world&quot;);     // new 对象的方式

string声明为final的，不可被继承
String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小
String在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]


为什么JDK9改变了结构
  String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。
  我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1&#x2F;Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。
  结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间
  // 之前private final char value[];// 之后private final byte[] value
  同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改

String的不可变性

String：代表不可变的字符序列。简称：不可变性。
当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。


通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。


当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
  @Testpublic void test1() &#123;    String s1 = &quot;abc&quot;;//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中    String s2 = &quot;abc&quot;;    s1 = &quot;hello&quot;;    System.out.println(s1 == s2);//判断地址：true  --&gt; false    System.out.println(s1);//    System.out.println(s2);//abc&#125;
  字节码指令

取字符串 “abc” 时，使用的是同一个符号引用：#2
取字符串 “hello” 时，使用的是另一个符号引用：#3


当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值
  @Testpublic void test2() &#123;    String s1 = &quot;abc&quot;;    String s2 = &quot;abc&quot;;    s2 += &quot;def&quot;;    System.out.println(s2);//abcdef    System.out.println(s1);//abc&#125;

当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值
  @Testpublic void test3() &#123;    String s1 = &quot;abc&quot;;    String s2 = s1.replace(&#x27;a&#x27;, &#x27;m&#x27;);    System.out.println(s1);//abc    System.out.println(s2);//mbc&#125;

一道笔试题
  public class StringExer &#123;    String str = new String(&quot;good&quot;);    char[] ch = &#123;&#x27;t&#x27;, &#x27;e&#x27;, &#x27;s&#x27;, &#x27;t&#x27;&#125;;    public void change(String str, char ch[]) &#123;        str = &quot;test ok&quot;;        ch[0] = &#x27;b&#x27;;    &#125;    public static void main(String[] args) &#123;        StringExer ex = new StringExer();        ex.change(ex.str, ex.ch);        System.out.println(ex.str);//good        System.out.println(ex.ch);//best    &#125;&#125;
  str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容****


2.String 的底层结构
字符串常量池是不会存储相同内容的字符串的

String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。
使用-XX:StringTablesize可设置StringTable的长度
在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求
在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求
在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009


String 的内存分配

在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。
常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。
直接使用双引号声明出来的String对象会直接存储在常量池中。比如：String info=&quot;atguigu.com&quot;;
如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈


Java 6及以前，字符串常量池存放在永久代
Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内
所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。
字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。


Java8元空间，字符串常量在堆

  
  
  

StringTable 为什么要调整？

为什么要调整位置？
永久代的默认空间大小比较小
永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space
堆中空间足够大，字符串可被及时回收


在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。
此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。

  官方文档:https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes
  代码示例：
  package com.peppa.strings;import java.util.HashSet;import java.util.Set;/** * jdk6中： * -XX:PermSize=10m -XX:MaxPermSize=10m -Xms10m -Xmx10m * * jdk8中： * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=10m -Xms10m -Xmx10m */public class StringTest3 &#123;    public static void main(String[] args) &#123;        //使用Set保持着常量池引用，避免full gc回收常量池行为        Set&lt;String&gt; set = new HashSet&lt;String&gt;();        //在short可以取值的范围内足以让10MB的PermSize或heap产生OOM了。        short i = 0;        while(true)&#123;            set.add(String.valueOf(i++).intern());        &#125;    &#125;&#125;
  输出结果：字符串真的在堆中（JDK8）
  Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space	at java.util.HashMap.resize(HashMap.java:704)	at java.util.HashMap.putVal(HashMap.java:663)	at java.util.HashMap.put(HashMap.java:612)	at java.util.HashSet.add(HashSet.java:220)	at com.peppa.strings.StringTest3.main(StringTest3.java:20)Process finished with exit code 1

String 的基本操作
  Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。
  package com.peppa.strings;public class StringTest4 &#123;    public static void main(String[] args) &#123;        System.out.println();//2051        System.out.println(&quot;1&quot;);//2052        System.out.println(&quot;2&quot;);        System.out.println(&quot;3&quot;);        System.out.println(&quot;4&quot;);        System.out.println(&quot;5&quot;);        System.out.println(&quot;6&quot;);        System.out.println(&quot;7&quot;);        System.out.println(&quot;8&quot;);        System.out.println(&quot;9&quot;);        System.out.println(&quot;10&quot;);//2303        //如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载        System.out.println(&quot;1&quot;);//2304        System.out.println(&quot;2&quot;);//2304        System.out.println(&quot;3&quot;);        System.out.println(&quot;4&quot;);        System.out.println(&quot;5&quot;);        System.out.println(&quot;6&quot;);        System.out.println(&quot;7&quot;);        System.out.println(&quot;8&quot;);        System.out.println(&quot;9&quot;);        System.out.println(&quot;10&quot;);//2304    &#125;&#125;

分析字符串常量池的变化-案例1：
  1、程序启动时已经加载了 *2051*个字符串常量
  
  2、加载了一个换行符（println），所以多了一个
  
  3、之后的字符串”1” 到 “10”不会再次加载
  

分析字符串常量池的变化-案例2：

官方示例代码

  //官方示例代码class Memory &#123;    public static void main(String[] args) &#123;//line 1        int i = 1;//line 2        Object obj = new Object();//line 3        Memory mem = new Memory();//line 4        mem.foo(obj);//line 5    &#125;//line 9    private void foo(Object param) &#123;//line 6        String str = param.toString();//line 7        System.out.println(str);    &#125;//line 8&#125;

分析运行时内存（foo() 方法是实例方法，其实图中少了一个 this 局部变量）

  




3.字符串拼接操作
字符串拼接操作

常量与常量的拼接结果在常量池，原理是编译期优化
常量池中不会存在相同内容的变量
只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder
如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址


常量与常量的拼接结果在常量池，原理是编译期优化
  @Testpublic void test1()&#123;    String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;//编译期优化：等同于&quot;abc&quot;    String s2 = &quot;abc&quot;; //&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2    /*     * 最终.java编译成.class,再执行.class     * String s1 = &quot;abc&quot;;     * String s2 = &quot;abc&quot;     */    System.out.println(s1 == s2); //true    System.out.println(s1.equals(s2)); //true&#125;
  从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”
  0: ldc           #2                  // String abc2: astore_13: ldc           #2                  // String abc5: astore_26: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;9: aload_110: aload_211: if_acmpne     1814: iconst_115: goto          1918: iconst_019: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V22: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;25: aload_126: aload_227: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z30: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V33: return
  IDEA 反编译 class 文件后，来看这个问题
  

拼接前后，只要其中有一个是变量，结果就在堆中
  public void test2()&#123;    String s1 = &quot;javaEE&quot;;    String s2 = &quot;hadoop&quot;;    String s3 = &quot;javaEEhadoop&quot;;    String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;//编译期优化    //如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop    String s5 = s1 + &quot;hadoop&quot;;    String s6 = &quot;javaEE&quot; + s2;    String s7 = s1 + s2;    System.out.println(s3 == s4);//true    System.out.println(s3 == s5);//false    System.out.println(s3 == s6);//false    System.out.println(s3 == s7);//false    System.out.println(s5 == s6);//false    System.out.println(s5 == s7);//false    System.out.println(s6 == s7);//false    //intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；    //如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。    String s8 = s6.intern();    System.out.println(s3 == s8);//true&#125;
  从上述的结果我们可以知道：
  从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类
  如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果
  而调用intern方法，则会判断字符串常量池中是否存在JavaEEhadoop值，如果存在则返回常量池中的值，否者就在常量池中创建

底层原理

拼接操作的底层其实使用了StringBuilder
  public void test3()&#123;    String s1 = &quot;a&quot;;    String s2 = &quot;b&quot;;    String s3 = &quot;ab&quot;;    /*    如下的s1 + s2 的执行细节：(变量s是我临时定义的）    ① StringBuilder s = new StringBuilder();    ② s.append(&quot;a&quot;)    ③ s.append(&quot;b&quot;)    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer     */    String s4 = s1 + s2;//    System.out.println(s3 == s4);//false&#125;
  

字符串拼接操作不一定使用的是StringBuilder


  /*    1. 字符串拼接操作不一定使用的是StringBuilder!       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。     */    @Test    public void test4()&#123;        final String s1 = &quot;a&quot;;        final String s2 = &quot;b&quot;;        String s3 = &quot;ab&quot;;        String s4 = s1 + s2;        System.out.println(s3 == s4);//true    &#125;

从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”
  0 ldc #14 &lt;a&gt;2 astore_13 ldc #15 &lt;b&gt;5 astore_26 ldc #16 &lt;ab&gt;8 astore_39 ldc #16 &lt;ab&gt;11 astore 413 getstatic #3 &lt;java/lang/System.out&gt;16 aload_317 aload 419 if_acmpne 26 (+7)22 iconst_123 goto 27 (+4)26 iconst_027 invokevirtual #4 &lt;java/io/PrintStream.println&gt;30 return


拼接操作和append性能对比
  public static void method1(int highLevel) &#123;    String src = &quot;&quot;;    for (int i = 0; i &lt; highLevel; i++) &#123;        src += &quot;a&quot;; // 每次循环都会创建一个StringBuilder对象    &#125;&#125;public static void method2(int highLevel) &#123;    StringBuilder sb = new StringBuilder();    for (int i = 0; i &lt; highLevel; i++) &#123;        sb.append(&quot;a&quot;);    &#125;&#125;

方法1耗费的时间：4005ms，方法2消耗时间：7ms
  结论：

通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法

  好处

StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象
对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象
内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间

  改进的空间

我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数
因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度




intern()的使用


intern() 方法的说明



  public native String intern();

intern是一个native方法，调用的是底层C的方法

字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）

如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：
 String myInfo = new string(&quot;I love atguigu&quot;).intern();

也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true
 (&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;

通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）



new String() 的说明

new String(“ab”)会创建几个对象？
  /** * 题目： * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。 *     一个对象是：new关键字在堆空间创建的 *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc * */public class StringNewTest &#123;    public static void main(String[] args) &#123;        String str = new String(&quot;ab&quot;);    &#125;&#125;

字节码指令

  0 new #2 &lt;java/lang/String&gt;3 dup4 ldc #3 &lt;ab&gt;6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;9 astore_110 return
  0 new #2 &lt;java/lang/String&gt;：在堆中创建了一个 String 对象
  4 ldc #3 &lt;ab&gt; ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）
  

new String(“a”) + new String(“b”) 会创建几个对象？

代码

  /** * 思考： * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？ *  对象1：new StringBuilder() *  对象2： new String(&quot;a&quot;) *  对象3： 常量池中的&quot;a&quot; *  对象4： new String(&quot;b&quot;) *  对象5： 常量池中的&quot;b&quot; * *  深入剖析： StringBuilder的toString(): *      对象6 ：new String(&quot;ab&quot;) *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot; * */public class StringNewTest &#123;    public static void main(String[] args) &#123;        String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);    &#125;&#125;
  字节码指令
  0: new           #2                  // class java/lang/StringBuilder3: dup4: invokespecial #3                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V7: new           #4                  // class java/lang/String10: dup11: ldc           #5                  // String a13: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V16: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;19: new           #4                  // class java/lang/String22: dup23: ldc           #8                  // String b25: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;31: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;34: astore_135: return
  我们创建了6个对象

对象1：new StringBuilder()
对象2：new String(“a”)
对象3：常量池的 a
对象4：new String(“b”)
对象5：常量池的 b
对象6：toString中会创建一个 new String(“ab”)
调用toString方法，不会在常量池中生成ab






intern的使用：JDK6和JDK7

JDK6中
  String s = new String(&quot;1&quot;);  // 在常量池中已经有了s.intern(); // 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1String s2 = &quot;1&quot;;System.out.println(s == s2); // falseString s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);s3.intern();String s4 = &quot;11&quot;;System.out.println(s3 == s4); // false
  输出结果
  falsefalse

为什么对象会不一样呢？

一个是new创建的对象，一个是常量池中的对象，显然不是同一个




如果是下面这样的，那么就是true
  String s = new String(&quot;1&quot;);s = s.intern();String s2 = &quot;1&quot;;System.out.println(s == s2); // true
  而对于下面的来说，因为 s3变量记录的地址是 new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是JDK6的关系，然后执行 s3.intern()后，就会在常量池中生成 “11”，最后 s4用的就是s3的地址

为什么最后输出的 s3 &#x3D;&#x3D; s4 会为false呢？这是因为在JDK6中创建了一个新的对象 “11”，也就是有了新的地址， s2 &#x3D; 新地址而在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象


JDK7中
  String s = new String(&quot;1&quot;);s.intern();String s2 = &quot;1&quot;;System.out.println(s == s2); // falseString s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);s3.intern();String s4 = &quot;11&quot;;System.out.println(s3 == s4); // true
  



扩展
  /** * StringIntern.java中练习的拓展： * */public class StringIntern1 &#123;    public static void main(String[] args) &#123;        //执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！        String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);//new String(&quot;11&quot;)        //在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象        String s4 = &quot;11&quot;;        String s5 = s3.intern();        // s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;        System.out.println(s3 == s4);//false        // s5 是从字符串常量池中取回来的引用，当然和 s4 相等        System.out.println(s5 == s4);//true    &#125;&#125;

总结string的intern（）的使用：
  JDK1.6中，将这个字符串对象尝试放入串池。

如果串池中有，则并不会放入。返回已有的串池中的对象的地址
如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址

  JDK1.7起，将这个字符串对象尝试放入串池。

如果串池中有，则并不会放入。返回已有的串池中的对象的地址
如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址


练习：
  

在JDK6中，在字符串常量池中创建一个字符串 “ab”
在JDK8中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到 串池中。
所以上述结果，在JDK6中是：

  truefalse

在JDK8中是

  falsetrue
  
  针对下面这题，在JDK6和8中表现的是一样的
  


4.StringTable的垃圾回收package com.peppa.strings;/** * String的垃圾回收: * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails */public class StringGCTest &#123;    public static void main(String[] args) &#123;        for (int j = 0; j &lt; 100000; j++) &#123;            String.valueOf(j).intern();        &#125;    &#125;&#125;

[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;488K(4608K)] 4096K-&gt;664K(15872K), 0.0011215 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 4608K, used 3577K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)  eden space 4096K, 75% used [0x00000000ffb00000,0x00000000ffe04688,0x00000000fff00000)  from space 512K, 95% used [0x00000000fff00000,0x00000000fff7a020,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 11264K, used 176K [0x00000000ff000000, 0x00000000ffb00000, 0x00000000ffb00000)  object space 11264K, 1% used [0x00000000ff000000,0x00000000ff02c000,0x00000000ffb00000) Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576KSymbolTable statistics:Number of buckets       :     20011 =    160088 bytes, avg   8.000Number of entries       :     13304 =    319296 bytes, avg  24.000Number of literals      :     13304 =    568608 bytes, avg  42.740Total footprint         :           =   1047992 bytesAverage bucket size     :     0.665Variance of bucket size :     0.666Std. dev. of bucket size:     0.816Maximum bucket size     :         6StringTable statistics:Number of buckets       :     60013 =    480104 bytes, avg   8.000Number of entries       :     57042 =   1369008 bytes, avg  24.000Number of literals      :     57042 =   3253608 bytes, avg  57.039Total footprint         :           =   5102720 bytesAverage bucket size     :     0.950Variance of bucket size :     0.750Std. dev. of bucket size:     0.866Maximum bucket size     :         5

5.G1 中的 String 去重操作官方：JEP 192: String Deduplication in G1 (java.net)
注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复

描述

背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：
堆存活数据集合里面string对象占了25%
堆存活数据集合里面重复的string对象有13.5%
string对象的平均长度是45


许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）&#x3D; true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。


String 去重的的实现

当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。
如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。
使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。
如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。
如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。


命令行选项

UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。
PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息
stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十四)**垃圾回收相关概念</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E5%9B%9B)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[JVM虚拟机详解(十四)垃圾回收相关概念1. System.gc()
理解

在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)

JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()代码演示是否出发GC操作

代码演示是否出发GC操作
  package com.peppa.gc;/** * System.gc() * * @author: peppa * @create: 2022-03-07 10:41:57 */public class SystemGC &#123;    public static void main(String[] args) &#123;        new SystemGC();        // 提醒JVM进行垃圾回收        System.gc();        // 强制调用 失去引用对象的finalize()        //System.runFinalization();    &#125;    @Override    protected void finalize() throws Throwable &#123;        super.finalize();        System.out.println(&quot;...SystemGC.finalize()方法被执行!!!&quot;);    &#125;&#125;

  输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用
  ...SystemGC.finalize()方法被执行!!!

手动GC来理解不可达对象的回收
  package com.peppa.gc;/** * 加上参数：  -XX:+PrintGCDetails -Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m * @author peppa * @create 2022-03-07 10:53:44 */public class LocalVariablesGC &#123;    /**     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区     */    public void localvarGC1() &#123;        //10MB        byte[] buffer = new byte[10 * 1024 * 1024];        System.gc();    &#125;    /**     *  触发YoungGC的时候，已经被回收了     */    public void localvarGC2() &#123;        byte[] buffer = new byte[10 * 1024 * 1024];        buffer = null;        System.gc();    &#125;    /**     * 不会被回收，因为它还存放在局部变量表索引为1的槽中     */    public void localvarGC3() &#123;        &#123;            byte[] buffer = new byte[10 * 1024 * 1024];        &#125;        System.gc();    &#125;    /**     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了     */    public void localvarGC4() &#123;        &#123;            byte[] buffer = new byte[10 * 1024 * 1024];        &#125;        int value = 10;        System.gc();    &#125;    /**     * localvarGC5中的数组已经被回收     */    public void localvarGC5() &#123;        localvarGC1();        System.gc();    &#125;    public static void main(String[] args) &#123;        LocalVariablesGC local = new LocalVariablesGC();        // 通过在main方法调用这几个方法进行测试        System.out.println(&quot;...LocalVariablesGC.localvarGC-1()&quot;);        local.localvarGC1();//        System.out.println(&quot;...LocalVariablesGC.localvarGC-2()&quot;);//        local.localvarGC2();////        System.out.println(&quot;...LocalVariablesGC.localvarGC-3()&quot;);//        local.localvarGC3();////        System.out.println(&quot;...LocalVariablesGC.localvarGC-4()&quot;);//        local.localvarGC4();////        System.out.println(&quot;...LocalVariablesGC.localvarGC-5()&quot;);//        local.localvarGC5();    &#125;&#125;

执行结果：

执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收

  ...LocalVariablesGC.localvarGC-1()**[GC (System.gc()) [PSYoungGen: 15483K-&gt;10728K(76288K)] 15483K-&gt;10976K(251392K), 0.0052388 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 248K-&gt;10868K(175104K)] 10976K-&gt;10868K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0040694 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]** Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 10868K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 6% used [0x00000000f0000000,0x00000000f0a9d270,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K

由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收

  ...LocalVariablesGC.localvarGC-2()**[GC (System.gc()) [PSYoungGen: 15483K-&gt;840K(76288K)] 15483K-&gt;848K(251392K), 0.0007219 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;628K(175104K)] 848K-&gt;628K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0034734 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]** Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 628K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009d260,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K

虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收

  ...LocalVariablesGC.localvarGC-3()**[GC (System.gc()) [PSYoungGen: 15483K-&gt;10736K(76288K)] 15483K-&gt;10976K(251392K), 0.0051980 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 240K-&gt;10868K(175104K)] 10976K-&gt;10868K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0039932 secs] [Times: user=0.05 sys=0.06, real=0.00 secs]** Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 10868K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 6% used [0x00000000f0000000,0x00000000f0a9d270,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K

1、来看看字节码：实例方法局部变量表第一个变量肯定是 this
  Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？
  A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看，value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向new byte[10 * 1024 * 1024]实例了。

局部变量除了方法范围就是失效了，堆中的字节数组铁定被回收


  ...LocalVariablesGC.localvarGC-5()[GC (System.gc()) [PSYoungGen: 15483K-&gt;10728K(76288K)] 15483K-&gt;10944K(251392K), 0.0050946 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (System.gc()) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 216K-&gt;10868K(175104K)] 10944K-&gt;10868K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0043706 secs] [Times: user=0.13 sys=0.00, real=0.00 secs] [GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10868K-&gt;10868K(251392K), 0.0002125 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10868K-&gt;628K(175104K)] 10868K-&gt;628K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0042302 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000)  to   space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000) ParOldGen       total 175104K, used 628K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009d260,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K
  ...LocalVariablesGC.localvarGC-4()[GC (System.gc()) [PSYoungGen: 15483K-&gt;840K(76288K)] 15483K-&gt;848K(251392K), 0.0007100 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;628K(175104K)] 848K-&gt;628K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0041518 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 628K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009d260,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K



2.内存溢出和内存泄漏
什么是内存溢出？

内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。
由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。
大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。
Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。


内存溢出（OOM）原因分析

首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：

Java虚拟机的堆内存设置不够。
比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。


代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）
对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space“。
随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace“。直接内存不足，也会导致OOM。




抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。

例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。
在**java.nio.Bits.reserveMemory()**方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。


当然，也不是在任何情况下垃圾收集器都会被触发的

比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。




什么是内存泄漏？

也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。
但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。
尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。
注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。

  
  Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。

举例

单例模式

  单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。

一些提供close的资源未关闭导致内存泄漏

  数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。




3.Stop The World]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(四)**运行时数据区概述及线程</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%9B%9B)%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[JVM虚拟机详解(四)运行时数据区概述及线程1. 前言本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段

当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区

也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品

内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。

我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁


运行时数据区的完整图
  
  Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。
  灰色的为单独线程私有的，红色的为多个线程共享的。即：

每个线程：独立包括程序计数器、栈、本地栈。
线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

  


2. 线程
JVM 线程
线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行
在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射
当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收


操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法


JVM 系统线程
如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[])的main线程以及所有这个main线程自己创建的线程。
这些主要的后台系统线程在Hotspot JVM里主要是以下几个：
虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销
周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行
GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持
编译线程：这种线程在运行时会将字节码编译成到本地代码
信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理





]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(一)认识JAVA多线程</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)%E8%AE%A4%E8%AF%86JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[1. 什么是线程和进程?&emsp;&emsp;在早期的计算机中不包含操作系统，它们从头到尾只执行一个程序，并肯这个程序能访问计算机中的所有的所有资源。在这种裸机环境中，不仅很难编写和运行程序，而且每次只能运行一个程序，这对于昂贵并且稀有的计算机资源来说也是一种浪费。
&emsp;&emsp;操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为各个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程之间可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。
1.1 什么是进程进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。
如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。
1.2 什么是线程线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
2. Java中创建线程&emsp;&emsp;在Java中创建线程的方式有三种：继承Thread类重写run方法、实现runnable接口重写run方法和实现callable接口重写call方法配合futureTask使用
2.1 继承Thread类继承Thread类的方式创建线程算是最简单的了，但是你的线程类往往要继承项目中的其他类，而Java是单继承机制的，所以使用此方法会有很大的局限性。
package com.yuanxw.chapter1;/** * Java中创建线程一：继承Thread类重写run方法 */public class MyThread extends Thread &#123;    public static void main(String[] args) &#123;        MyThread myThread = new MyThread();        myThread.start();        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, currentThread().getName()));    &#125;    @Override    public void run() &#123;        for (int i = 0; i &lt; 20; i++) &#123;            try &#123;                System.out.println(String.format(&quot;线程：【%s】,打印：%s&quot;, currentThread().getName(),i));                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, currentThread().getName()));    &#125;&#125;
2.2 实现Runnable接口Thread类的构造方法允许传入一个实现Runnable接口的target进去，线程启动将会执行target.run方法。实现Runnable接口的方式可以很好的避免单继承问题。
package com.yuanxw.chapter1;/** * Java中创建线程二：实现Runnable接口重写run方法 */public class MyRunnable implements Runnable&#123;    public static void main(String[] args) &#123;        MyRunnable myRunnable = new MyRunnable();        Thread thread = new Thread(myRunnable);        thread.start();        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, Thread.currentThread().getName()));    &#125;    @Override    public void run() &#123;        for (int i = 0; i &lt; 20; i++) &#123;            try &#123;                System.out.println(String.format(&quot;线程：【%s】,打印：%s&quot;, Thread.currentThread().getName(),i));                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, Thread.currentThread().getName()));    &#125;&#125;
2.3 实现Callable接口call方法与run方法最大的区别在于call方法存在返回值futureTask的get方法可以获取这个返回值。使用此种方法实现线程的好处是当你创建的任务的结果不是立即就要时，你可以提交一个线程在后台执行，而你的程序仍可以正常运行下去，在需要执行结果时使用futureTask去获取即可。这是一种典型的异步任务处理的方法。
package com.yuanxw.chapter1;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;import java.util.concurrent.TimeoutException;public class MyCallable implements Callable &#123;    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException &#123;        FutureTask futureTask1 = new FutureTask(new MyCallable());        new Thread(futureTask1,&quot;子线程-A&quot;).start();        FutureTask futureTask2 = new FutureTask(new MyCallable());        new Thread(futureTask2,&quot;子线程-B&quot;).start();        // futureTask可以在指定时间内获取线程执行的返回值，超时则丢弃任务        //  因此futureTask可以用作异步任务处理        // futureTask.get(1000, TimeUnit.SECONDS);        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, Thread.currentThread().getName()));    &#125;    @Override    public Object call() throws Exception &#123;        int sum = 0;        for (int i = 0; i &lt; 50; i++) &#123;            try &#123;                System.out.println(String.format(&quot;线程：【%s】,打印：%s&quot;, Thread.currentThread().getName(),i));                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            sum += i;        &#125;        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, Thread.currentThread().getName()));        System.out.println(&quot;执行结果：&quot; + sum);        return sum;    &#125;&#125;

3. 线程的生命周期和状态Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：由上图可以看出：线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。
学习推荐书籍： [1]: 《Java并发编程实践 》 [2]: 《Java并发编程的艺术 》 [3]: 《Java高并发编程详解：多线程与架构设计 》 [4]: 《Java多线程编程核心技术（第2版） 》
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(七)Java多线程之synchronized(同步锁)</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%83)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bsynchronized(%E5%90%8C%E6%AD%A5%E9%94%81)/</url>
    <content><![CDATA[1.JAVA多线程(七)Java多线程之synchronized(同步锁)1.1 synchronized(同步锁)&emsp;&emsp;synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
synchronized 关键字最主要的三种使用方式：

修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

总结 ： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！
1.1.1.模拟多线程下单减库存，在不锁的情况的结果一个抢购活动某个商品的总数是一个常数，购买者可以有多个，每个购买操作都会使总数减少。我们竟然发现了 余票为-1 -2的情况，这就与实际不符。原因在于 多个线程同时执行同一段代码，导致变量错误。
package com.yuanxw.chapter7;/** * 多线程处理订单 */public class ThreadOrder &#123;    public static void main(String[] args) &#123;        OrderPayService orderPayService = new OrderPayService();        new Thread(orderPayService).start();        new Thread(orderPayService).start();        new Thread(orderPayService).start();        new Thread(orderPayService).start();    &#125;&#125;class OrderPayService implements Runnable &#123;    /** 最大库存 **/    private  int maxQuantityNum = 10;    @Override    public void run() &#123;        while (maxQuantityNum &gt;0)&#123;            try &#123;                Thread.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(String.format(&quot;您抢购商品，库存只剩下【%s】个商品&quot;, maxQuantityNum--));        &#125;    &#125;&#125;
执行结果
您抢购商品，库存只剩下【9】个商品您抢购商品，库存只剩下【8】个商品您抢购商品，库存只剩下【7】个商品您抢购商品，库存只剩下【10】个商品您抢购商品，库存只剩下【6】个商品您抢购商品，库存只剩下【6】个商品您抢购商品，库存只剩下【4】个商品您抢购商品，库存只剩下【5】个商品您抢购商品，库存只剩下【3】个商品您抢购商品，库存只剩下【3】个商品您抢购商品，库存只剩下【2】个商品您抢购商品，库存只剩下【1】个商品您抢购商品，库存只剩下【-1】个商品您抢购商品，库存只剩下【0】个商品
我们应对这段代码进行加锁控制
package com.yuanxw.chapter7;/** * 多线程处理订单 */public class ThreadOrderSynchronized &#123;    public static void main(String[] args) &#123;        OrderPaymentService orderPaymentService = new OrderPaymentService();        new Thread(orderPaymentService).start();        new Thread(orderPaymentService).start();        new Thread(orderPaymentService).start();        new Thread(orderPaymentService).start();    &#125;&#125;class OrderPaymentService implements Runnable &#123;    /** 最大库存 **/    private  int maxQuantityNum = 10;    /** 监控 **/    private final Object MONITOR = new Object();    @Override    public void run() &#123;        // synchronized 关键字加到实例方法上是给对象实例上锁        synchronized (MONITOR) &#123;            while (maxQuantityNum &gt; 0) &#123;                try &#123;                    Thread.sleep(3);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(String.format(&quot;您抢购商品，库存只剩下【%s】个商品&quot;, maxQuantityNum--));            &#125;        &#125;    &#125;&#125;
执行结果
您抢购商品，库存只剩下【10】个商品您抢购商品，库存只剩下【9】个商品您抢购商品，库存只剩下【8】个商品您抢购商品，库存只剩下【7】个商品您抢购商品，库存只剩下【6】个商品您抢购商品，库存只剩下【5】个商品您抢购商品，库存只剩下【4】个商品您抢购商品，库存只剩下【3】个商品您抢购商品，库存只剩下【2】个商品您抢购商品，库存只剩下【1】个商品

通过 JDK 自带的 javap 命令查看 OrderPaymentService.class 类的相关字节码信息：首先切换到类的对应目录执行 javac OrderPaymentService.java 命令生成编译后的 OrderPaymentService.class 文件，然后执行javap -c -s -v -l OrderPaymentService.class从上面我们可以看出：
synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
1.2 单例模式(一)：【双重校验锁实现对象单例（线程安全）】双重检验锁方式实现单例模式的原理：需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。
package com.yuanxw.chapter7;/** * 单例模式：一 */public class Singleton &#123;    // 内存可见性    private volatile static Singleton uniqueInstance;    private Singleton() &#123;    &#125;    public static Singleton getUniqueInstance() &#123;        //先判断对象是否已经实例过，没有实例化过才进入加锁代码        if (uniqueInstance == null) &#123;            //类对象加锁            synchronized (Singleton.class) &#123;                if (uniqueInstance == null) &#123;                    uniqueInstance = new Singleton();                &#125;            &#125;        &#125;        return uniqueInstance;    &#125;&#125;

uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行：
为 uniqueInstance 分配内存空间
初始化 uniqueInstance
将 uniqueInstance 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。
使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。
1.3 单例模式(二)单例模式(二)：JVM类在加载的时候，只会运行一次，静态类可以严格的保证线程执行顺序 
package com.yuanxw.chapter7;/** * 单例模式：二 */public class SingletonHolder &#123;    private SingletonHolder()&#123;    &#125;    /** JVM类在加载的时候，只会运行一次，静态类可以严格的保证线程执行顺序 **/    private static class InstanceHolder&#123;        private final static SingletonHolder instance = new SingletonHolder();    &#125;    public static SingletonHolder getInstance()&#123;        // 只有使用时才会加载。        return  SingletonHolder.getInstance();    &#125;&#125;
1.4 单例模式(三)通过枚举的方式，保证线程安全。枚举构造函数只会被装载一次，因此可以保证对象只会被创建一次。
package com.yuanxw.chapter7;/** * 单例模式：三 * 推荐使用 */public class SingtonEnum &#123;    private SingtonEnum()&#123;    &#125;    /**     * 通过枚举的方式，保证线程安全     */    private enum Sington &#123;        INSTANCE;        private final SingtonEnum instance;        Sington() &#123;            // 只会被创建一次            instance = new SingtonEnum();        &#125;        public SingtonEnum getInstance() &#123;            return instance;        &#125;    &#125;    /**     * 获得单例     * @return     */    public static SingtonEnum getInstance()&#123;        return Sington.INSTANCE.getInstance();    &#125;&#125;


 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(七)Java多线程之synchronized(同步锁)》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(三)Java多线程之守护线程</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[1.JAVA多线程(三)Java多线程之守护线程1.1 daemon(守护线程)&emsp;&emsp;Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)。用户线程即运行在前台的线程，而守护线程是运行在后台的线程。

&emsp;&emsp; 用户线程：运行在前台，执行具体的任务，程序的主线程，连接网络的子线程等都是用户线程。

&emsp;&emsp; 守护线程：运行在后台，为其他前台线程服务。

特点：当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。
应用：数据库连接池中的监测线程JVM启动后的监测线程
最常见的守护线程：垃圾回收线程
如何设置守护线程：可以通过Thread类的setDaemon（true）方法来设置当前的线程为守护线程



package com.yuanxw.chapter3;/** * 守护线程 */public class DaemonThread &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread()&#123;            @Override            public void run() &#123;                while (true)&#123;                    try &#123;                        sleep(500L);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(&quot;connecting to network ...&quot;);                &#125;            &#125;        &#125;;        /**         * 设置为守护线程，必须的调用start()方法之前设置。         * 在start()方法之后设置：Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException         */        thread.setDaemon(true);        thread.start();    &#125;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(三)Java多线程之守护线程》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(九)Java多线程之生产者与消费者</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B9%9D)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[1.JAVA多线程(九)Java多线程之生产者与消费者
需求如下：自定义多线程生产者与消费者
1.如果生产者没有生产消息，就需要去生产消息，消费者就需要等待消费者生产完以后再去消费。
2.如果消费者没有消费消息，那么生产者就需要等待，消费都消费完成后，再去生产消息。

1.1 生产者与消费者【一个生产线程和一个消费者线程】package com.yuanxw.chapter9;/** * 自定义多线程生产者与消费者 * 1.如果生产者没有生产消息，就需要去生产消息，消费者就需要等待消费者生产完以后再去消费。 * 2.如果消费者没有消费消息，那么生产者就需要等待，消费都消费完成后，再去生产消息。 */public class ProduceConsumer &#123;    /** 生产数量 **/    private int num = 0;    /** 锁 **/    protected final Object LOCK = new Object();    /** volatile:内存可见性关键字，默认为没有生产，可以进行生产 **/    private volatile boolean isProducted = false;    /**     * 生产方法     * @return     */    public void produce() throws InterruptedException &#123;        // 同步生产        synchronized (LOCK)&#123;            // 如果消息已经生产，需要等待消费者消费后再去生产            if(isProducted)&#123;                /**                 * 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。                 * 它们都属于 Object 的一部分，而不属于 Thread。                 */                LOCK.wait();            &#125;else &#123;                // 如果已经消费，那么就需要进行生产                num++;                System.out.println(String.format(&quot;生产消息&gt;&gt;【%s】&quot;, num));                /**                 * 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。                 * 它们都属于 Object 的一部分，而不属于 Thread。                 */                // 通知消费者，可以进行消费                LOCK.notify();                // 设置标记：已经生产                isProducted = true;            &#125;        &#125;    &#125;    /**     * 消费方法     */    public void consumer() throws InterruptedException &#123;        // 同步消费        synchronized (LOCK)&#123;            // 如果已经生产，那么消费者消费            if(isProducted)&#123;                System.out.println(String.format(&quot;消费消息&lt;&lt;【%s】&quot;, num));                // 通知生产者已经消费                LOCK.notify();                // 设置标记：未生产                isProducted = false;            &#125;else &#123;                // 如果已经没有生产，即需要消息费进行等待生产者进行生产                LOCK.wait();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        ProduceConsumer produceConsumer = new ProduceConsumer();        // 生产者：生产线程        new Thread(()-&gt;&#123;            try &#123;                while (true) &#123;                    produceConsumer.produce();                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        // 消费者：消费线程        new Thread(()-&gt;&#123;            try &#123;                while (true) &#123;                    produceConsumer.consumer();                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;

执行结果：
生产消息&gt;&gt;【1】消费消息&lt;&lt;【1】生产消息&gt;&gt;【2】消费消息&lt;&lt;【2】生产消息&gt;&gt;【3】消费消息&lt;&lt;【3】生产消息&gt;&gt;【4】消费消息&lt;&lt;【4】生产消息&gt;&gt;【5】消费消息&lt;&lt;【5】生产消息&gt;&gt;【6】消费消息&lt;&lt;【6】生产消息&gt;&gt;【7】消费消息&lt;&lt;【7】生产消息&gt;&gt;【8】消费消息&lt;&lt;【8】生产消息&gt;&gt;【9】消费消息&lt;&lt;【9】生产消息&gt;&gt;【10】消费消息&lt;&lt;【10】

1.2 生产者与消费者【多个生产线程和多个消费者线程】package com.yuanxw.chapter9;import java.util.Arrays;/** * 自定义多线程生产者与消费者【多生產者多消費者】 * 1.如果生产者没有生产消息，就需要去生产消息，消费者就需要等待消费者生产完以后再去消费。 * 2.如果消费者没有消费消息，那么生产者就需要等待，消费都消费完成后，再去生产消息。 */public class MultiProduceConsumer &#123;    /** 生产数量 **/    private int num = 0;    /** 锁 **/    protected final Object LOCK = new Object();    /** volatile:内存可见性关键字，默认为没有生产，可以进行生产 **/    private volatile boolean isProducted = false;    /**     * 生产方法     * @return     */    public void produce() throws InterruptedException &#123;        // 同步生产        synchronized (LOCK)&#123;            // 如果消息已经生产，需要等待消费者消费后再去生产            while (isProducted)&#123;                /**                 * 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。                 * 它们都属于 Object 的一部分，而不属于 Thread。                 */                LOCK.wait();            &#125;            // 如果已经消费，那么就需要进行生产            num++;            System.out.println(String.format(&quot;生产消息&gt;&gt;&gt;&gt;【%s】&quot;, num));            /**             * 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。             * 它们都属于 Object 的一部分，而不属于 Thread。             */            // 通知消费者，可以进行消费            LOCK.notifyAll();            // 设置标记：已经生产            isProducted = true;        &#125;    &#125;    /**     * 消费方法     */    public void consumer() throws InterruptedException &#123;        // 同步消费        synchronized (LOCK)&#123;            // 如果已经生产，那么消费者消费            while (!isProducted)&#123;                // 如果已经没有生产，即需要消息费进行等待生产者进行生产                LOCK.wait();            &#125;            System.out.println(String.format(&quot;消费消息&lt;&lt;&lt;&lt;【%s】&quot;, num));            // 通知生产者已经消费            LOCK.notifyAll();            // 设置标记：未生产            isProducted = false;        &#125;    &#125;    public static void main(String[] args) &#123;        MultiProduceConsumer produceConsumer = new MultiProduceConsumer();        Arrays.asList(&quot;Produce1&quot;,&quot;Produce2&quot;,&quot;Produce3&quot;,&quot;Produce4&quot;,&quot;Produce5&quot;,&quot;Produce6&quot;,&quot;Produce7&quot;,&quot;Produce8&quot;).forEach(p-&gt;&#123;            // 生产者Produce            new Thread(()-&gt;&#123;                try &#123;                    while (true) &#123;                        produceConsumer.produce();                         Thread.sleep(10L);                    &#125;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;,p).start();        &#125;);        Arrays.asList(&quot;Consumer1&quot;,&quot;Consumer2&quot;,&quot;Consumer3&quot;,&quot;Consumer4&quot;,&quot;Consumer5&quot;,&quot;Consumer6&quot;).forEach(c-&gt; &#123;            // 消费者            new Thread(() -&gt; &#123;                try &#123;                    while (true) &#123;                        produceConsumer.consumer();                         Thread.sleep(10L);                    &#125;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;,c).start();        &#125;);    &#125;&#125;
执行结果：
生产消息&gt;&gt;&gt;&gt;【1】消费消息&lt;&lt;&lt;&lt;【1】生产消息&gt;&gt;&gt;&gt;【2】消费消息&lt;&lt;&lt;&lt;【2】生产消息&gt;&gt;&gt;&gt;【3】消费消息&lt;&lt;&lt;&lt;【3】生产消息&gt;&gt;&gt;&gt;【4】消费消息&lt;&lt;&lt;&lt;【4】生产消息&gt;&gt;&gt;&gt;【5】消费消息&lt;&lt;&lt;&lt;【5】生产消息&gt;&gt;&gt;&gt;【6】消费消息&lt;&lt;&lt;&lt;【6】生产消息&gt;&gt;&gt;&gt;【7】消费消息&lt;&lt;&lt;&lt;【7】生产消息&gt;&gt;&gt;&gt;【8】消费消息&lt;&lt;&lt;&lt;【8】生产消息&gt;&gt;&gt;&gt;【9】消费消息&lt;&lt;&lt;&lt;【9】生产消息&gt;&gt;&gt;&gt;【10】消费消息&lt;&lt;&lt;&lt;【10】生产消息&gt;&gt;&gt;&gt;【11】消费消息&lt;&lt;&lt;&lt;【11】生产消息&gt;&gt;&gt;&gt;【12】消费消息&lt;&lt;&lt;&lt;【12】生产消息&gt;&gt;&gt;&gt;【13】消费消息&lt;&lt;&lt;&lt;【13】生产消息&gt;&gt;&gt;&gt;【14】消费消息&lt;&lt;&lt;&lt;【14】生产消息&gt;&gt;&gt;&gt;【15】消费消息&lt;&lt;&lt;&lt;【15】生产消息&gt;&gt;&gt;&gt;【16】消费消息&lt;&lt;&lt;&lt;【16】生产消息&gt;&gt;&gt;&gt;【17】消费消息&lt;&lt;&lt;&lt;【17】生产消息&gt;&gt;&gt;&gt;【18】消费消息&lt;&lt;&lt;&lt;【18】生产消息&gt;&gt;&gt;&gt;【19】消费消息&lt;&lt;&lt;&lt;【19】生产消息&gt;&gt;&gt;&gt;【20】消费消息&lt;&lt;&lt;&lt;【20】

1.3 JAVA中sleep() 方法和 wait() 方法区别
sleep方法是Thread类的方法，而wait方法是Object方法。
sleep方法没有释放锁，而wait方法释放了锁，并且加入到Object的queue。
使用sleep方法不用synchronized监控，而wait方法需要。
使用sleep方法不需要唤醒，而wait需要。

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(九)Java多线程之生产者与消费者》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二)Java多线程之火车票</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%81%AB%E8%BD%A6%E7%A5%A8/</url>
    <content><![CDATA[1. JAVA多线程(二)Java多线程之火车票&emsp;&emsp;需求如下：铁道部发布了一个售票任务，要求销售10张票，要求有4个窗口来进行销售，请编写多线程程序来模拟这个效果

第001窗口，正在售票，票号：1
第004窗口，正在售票，票号：2
第002窗口，正在售票，票号：3
第003窗口，正在售票，票号：4

1.1 继承Thread类多线程进行售票继承Thread类的方式创建多线程进行售票的方式，在不加锁的情况下，每一个窗口都独立个体，数据没有共享。（四个窗口都卖了10张票，这显然不是我们想的结果），代码如下：
package com.yuanxw.chapter2;/** * 火车票售票 */public class RailwayStation &#123;    public static void main(String[] args) &#123;        TicketWindow ticketWindow1 = new TicketWindow(&quot;001窗口&quot;);        TicketWindow ticketWindow2 = new TicketWindow(&quot;002窗口&quot;);        TicketWindow ticketWindow3 = new TicketWindow(&quot;003窗口&quot;);        TicketWindow ticketWindow4 = new TicketWindow(&quot;004窗口&quot;);        ticketWindow1.start();        ticketWindow2.start();        ticketWindow3.start();        ticketWindow4.start();    &#125;&#125;

package com.yuanxw.chapter2;/** * 售票窗口 * @author yuanxw */public class TicketWindow  extends Thread &#123;    /** 最大售数 **/    private final int MAX_NUMBER = 10;    /** 当前售数 **/    private int currentNumber = 1;    /** 窗口名称 **/    private String name;    public TicketWindow(String name) &#123;        this.name = name;    &#125;    @Override    public void run() &#123;        while (currentNumber &lt;= MAX_NUMBER)&#123;            System.out.println(String.format(&quot;第%s，正在售票，票号：%s&quot;, name,currentNumber++));        &#125;    &#125;&#125;
执行结果：
第001窗口，正在售票，票号：1第002窗口，正在售票，票号：1第003窗口，正在售票，票号：1第001窗口，正在售票，票号：2第004窗口，正在售票，票号：1第003窗口，正在售票，票号：2第001窗口，正在售票，票号：3第003窗口，正在售票，票号：3第001窗口，正在售票，票号：4第003窗口，正在售票，票号：4第002窗口，正在售票，票号：2第001窗口，正在售票，票号：5第003窗口，正在售票，票号：5第002窗口，正在售票，票号：3第004窗口，正在售票，票号：2第003窗口，正在售票，票号：6第002窗口，正在售票，票号：4第001窗口，正在售票，票号：6第003窗口，正在售票，票号：7第002窗口，正在售票，票号：5第001窗口，正在售票，票号：7第004窗口，正在售票，票号：3第002窗口，正在售票，票号：6第001窗口，正在售票，票号：8第003窗口，正在售票，票号：8第002窗口，正在售票，票号：7第001窗口，正在售票，票号：9第003窗口，正在售票，票号：9第002窗口，正在售票，票号：8第004窗口，正在售票，票号：4第001窗口，正在售票，票号：10第002窗口，正在售票，票号：9第003窗口，正在售票，票号：10第004窗口，正在售票，票号：5第002窗口，正在售票，票号：10第004窗口，正在售票，票号：6第004窗口，正在售票，票号：7第004窗口，正在售票，票号：8第004窗口，正在售票，票号：9第004窗口，正在售票，票号：10

2.2 实现Runnable接口多线程进行售票实现Runnable接口的方式将我们可执行的逻辑单元和我们的线程控制分离，Runnable接口更加适合多个相同线程处理同一份资源的情况。
package com.yuanxw.chapter2;/** * 高铁站售票 */public class HighSpeedRailStation &#123;    public static void main(String[] args) &#123;        TicketWindowRunnable ticketWindowRunnable = new TicketWindowRunnable();        Thread thread1 = new Thread(ticketWindowRunnable,&quot;001窗口&quot;);        Thread thread2 = new Thread(ticketWindowRunnable,&quot;002窗口&quot;);        Thread thread3 = new Thread(ticketWindowRunnable,&quot;003窗口&quot;);        Thread thread4 = new Thread(ticketWindowRunnable,&quot;004窗口&quot;);        thread1.start();        thread2.start();        thread3.start();        thread4.start();    &#125;&#125;

package com.yuanxw.chapter2;/** * 实现Runnable方式售票 */public class TicketWindowRunnable implements Runnable &#123;    /** 最大售数 **/    private final int MAX_NUMBER = 10;    /** 当前售数 **/    private int currentNumber = 1;    @Override    public void run() &#123;        try &#123;            Thread.sleep(100);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        while (currentNumber &lt;= MAX_NUMBER)&#123;            System.out.println(String.format(&quot;第%s，正在售票，票号：%s&quot;, Thread.currentThread().getName(),currentNumber++));        &#125;    &#125;&#125;

执行结果：
第001窗口，正在售票，票号：2第002窗口，正在售票，票号：3第004窗口，正在售票，票号：1第003窗口，正在售票，票号：4第001窗口，正在售票，票号：5第002窗口，正在售票，票号：6第004窗口，正在售票，票号：7第001窗口，正在售票，票号：9第002窗口，正在售票，票号：10第003窗口，正在售票，票号：8


 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二)Java多线程之火车票》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 多线程(二十)Java 多线程之 FixedThreadPool 可重用固定线程数的线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BFixedThreadPool%E5%8F%AF%E9%87%8D%E7%94%A8%E5%9B%BA%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA 多线程(二十)Java 多线程之 FixedThreadPool 可重用固定线程数的线程池1.1 可重用固定线程数的线程池 FixedThreadPool&emsp;&emsp; 可重用固定线程数的线程池 FixedThreadPool 特点是：只有核心线程，不会被回收、线程数量固定、任务队列无大小限制（超出的线程任务会在队列中等待），通过源代码查看 FixedThreadPool 实现：
/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue.  At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks.  The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */public static ExecutorService newFixedThreadPool(int nThreads) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());&#125;/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue, using the provided * ThreadFactory to create new threads when needed.  At any point, * at most &#123;@code nThreads&#125; threads will be active processing * tasks.  If additional tasks are submitted when all threads are * active, they will wait in the queue until a thread is * available.  If any thread terminates due to a failure during * execution prior to shutdown, a new one will take its place if * needed to execute subsequent tasks.  The threads in the pool will * exist until it is explicitly &#123;@link ExecutorService#shutdown * shutdown&#125;. * * @param nThreads the number of threads in the pool * @param threadFactory the factory to use when creating new threads * @return the newly created thread pool * @throws NullPointerException if threadFactory is null * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;(),                                  threadFactory);&#125;/** * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;. */public LinkedBlockingQueue() &#123;    this(Integer.MAX_VALUE);&#125;

在 FixedThreadPool 实现中：

corePoolSize &amp;&amp; maximumPoolSize，核心线程数和允许最大的线程数一致，可以指定无限大，在资源有限的情况下容易引起 OOM 异常。
keepAliveTime &#x3D;&gt; keepAliveTime 为 0，意味着多余的空闲线程会被立即终止。
workQueue &#x3D;&gt; 采用无界队列 LinkedBlockingQueue 作为线程池的工作队列（队列的容量为 Integer.MAX_VALUE），会在循环中反复从 LinkedBlockingQueue 获取任务来执行。

1.2 FixedThreadPool 使用样例FixedThreadPool 线程池使用 LinkedBlockingQueue 作为线程池的工作队列会对线程池带来如下影响：

当线程池中的线程数达到 corePoolSize 核心线程数后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize 核心线程数。
使用无界队列，运行中的 FixedThreadPool 不会拒绝任务，（未执行方法 shutdown()或 shutdownNow()，不会调用 RejectedExecutionHandler.rejectedExecution 方法），在任务比较多的时候会导致 OOM（内存溢出）。

package com.yuanxw.chapter20;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class FixedThreadPoolExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        ExecutorService executorService = Executors.newFixedThreadPool(5);        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());        for (int i = 0; i &lt; 10; i++) &#123;            executorService.execute(()-&gt;&#123;                try &#123;                    TimeUnit.SECONDS.sleep(1);                    System.out.println(String.format(&quot;线程【%s】正在工作&gt;&gt;&gt;&gt;&quot;, Thread.currentThread().getName()));                    System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;        TimeUnit.SECONDS.sleep(5);        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());        // corePoolSize 等于 maximumPoolSize，因此应用程序不会结束，需要调用executorService.shutdown()方法，关闭线程池。        executorService.shutdown();    &#125;&#125;

执行结果：
获得活动的线程评估数：0线程【pool-1-thread-2】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-3】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5线程【pool-1-thread-1】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：4线程【pool-1-thread-5】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5获得活动的线程评估数：5线程【pool-1-thread-4】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5线程【pool-1-thread-4】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-3】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-2】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-5】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5线程【pool-1-thread-1】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5获得活动的线程评估数：5获得活动的线程评估数：5获得活动的线程评估数：4获得活动的线程评估数：0

FixedThreadPool 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：

如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；
当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；
线程池中的线程执行完当前的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；

&emsp;&emsp;&emsp;&emsp;– 以上为《JAVA 多线程(二十)Java 多线程之 FixedThreadPool 可重用固定线程数的线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。
  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%83)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BLinkedBlockingQueue%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[1.JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器1.1 什么是LinkedBlockingQueue&emsp;&emsp;LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。
下面是 LinkedBlockingQueue继承结构关系图：

1.2 LinkedBlockingQueue单向链表实现的阻塞队列&emsp;&emsp;LinkedBlockingQueue是一个阻塞队列，内部由两个ReentrantLock来实现出入队列的线程安全，由各自的Condition对象的await和signal来实现等待和唤醒功能。它和ArrayBlockingQueue的不同点在于：

队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。
数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。
由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。
两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

通过源代码查看LinkedBlockingQueue实现：
/** * 创建一个 LinkedBlockingQueue ，容量为 Integer.MAX_VALUE 。  * * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;. */public LinkedBlockingQueue() &#123;    this(Integer.MAX_VALUE);&#125;/** * 创建一个具有给定（固定）容量的 LinkedBlockingQueue 。  * Creates a &#123;@code LinkedBlockingQueue&#125; with the given (fixed) capacity. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if &#123;@code capacity&#125; is not greater *         than zero */public LinkedBlockingQueue(int capacity) &#123;    if (capacity &lt;= 0) throw new IllegalArgumentException();    this.capacity = capacity;    last = head = new Node&lt;E&gt;(null);&#125;/** * 创建一个 LinkedBlockingQueue ，容量为 Integer.MAX_VALUE ，最初包含给定集合的元素，以集合的迭代* 器的遍历顺序添加。  * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;, initially containing the elements of the * given collection, * added in traversal order of the collection&#x27;s iterator. * * @param c the collection of elements to initially contain * @throws NullPointerException if the specified collection or any *         of its elements are null */public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) &#123;    this(Integer.MAX_VALUE);    final ReentrantLock putLock = this.putLock;    putLock.lock(); // Never contended, but necessary for visibility    try &#123;        int n = 0;        for (E e : c) &#123;            if (e == null)                throw new NullPointerException();            if (n == capacity)                throw new IllegalStateException(&quot;Queue full&quot;);            enqueue(new Node&lt;E&gt;(e));            ++n;        &#125;        count.set(n);    &#125; finally &#123;        putLock.unlock();    &#125;&#125;

1.3 常用的方法package com.yuanxw.thread.chapter27;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class LinkedBlockingQueueExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        // add();        // offer();        // put();        // poll();        // peek();        // element();         remove();    &#125;    /**     如果可以在不超过队列的容量的情况下立即将其指定的元素插入到该队列，     如果队列已满，则返回 true并抛出 IllegalStateException 。     执行结果：         =====执行add()签名方法-开始=====         linkedBlockingQueue.add()执行返回结果：true         linkedBlockingQueue.add()执行返回结果：true         linkedBlockingQueue.add()执行返回结果：true         Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full         at java.util.AbstractQueue.add(AbstractQueue.java:98)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.add(LinkedBlockingQueueExample.java:38)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.main(LinkedBlockingQueueExample.java:9)     */    public static void add() &#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        System.out.println(&quot;linkedBlockingQueue.add()执行返回结果：&quot;+linkedBlockingQueue.add(&quot;Message 1&quot;));        System.out.println(&quot;linkedBlockingQueue.add()执行返回结果：&quot;+linkedBlockingQueue.add(&quot;Message 2&quot;));        System.out.println(&quot;linkedBlockingQueue.add()执行返回结果：&quot;+linkedBlockingQueue.add(&quot;Message 3&quot;));        System.out.println(&quot;linkedBlockingQueue.add()执行返回结果：&quot;+linkedBlockingQueue.add(&quot;Message 4&quot;));        System.out.println(&quot;=====执行add()签名方法-结束=====&quot;);    &#125;    /**     * 如果可以在不超过队列容量的情况下立即将其指定的元素插入该队列的尾部，     * 则在成功时true如果该队列已满，则返回false 。     执行结果：         =====执行offer()签名方法-开始=====         linkedBlockingQueue.offer()执行返回结果：true         linkedBlockingQueue.offer()执行返回结果：true         linkedBlockingQueue.offer()执行返回结果：true         linkedBlockingQueue.offer()执行返回结果：false         =====执行offer()签名方法-结束=====     */    public static void offer()&#123;        System.out.println(&quot;=====执行offer()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        System.out.println(&quot;linkedBlockingQueue.offer()执行返回结果：&quot;+linkedBlockingQueue.offer(&quot;Message 1&quot;));        System.out.println(&quot;linkedBlockingQueue.offer()执行返回结果：&quot;+linkedBlockingQueue.offer(&quot;Message 2&quot;));        System.out.println(&quot;linkedBlockingQueue.offer()执行返回结果：&quot;+linkedBlockingQueue.offer(&quot;Message 3&quot;));        System.out.println(&quot;linkedBlockingQueue.offer()执行返回结果：&quot;+linkedBlockingQueue.offer(&quot;Message 4&quot;));        System.out.println(&quot;=====执行offer()签名方法-结束=====&quot;);    &#125;    /**     * 在该队列的尾部插入指定的元素，如果队列已满，则等待空间变为可用。     执行结果：     =====执行put()签名方法-开始=====     当前linkedBlockingQueue对象中的个数：3     当前linkedBlockingQueue对象中的容量：0     当前linkedBlockingQueue对象中take()数据值为：Message 1     Message 2     Message 3     Message 4     =====执行put()签名方法-结束=====     */    public static void put() throws InterruptedException &#123;        System.out.println(&quot;=====执行put()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        Executors.newSingleThreadExecutor().execute(()-&gt;&#123;            System.out.println(&quot;当前linkedBlockingQueue对象中的个数：&quot; + linkedBlockingQueue.size());            System.out.println(&quot;当前linkedBlockingQueue对象中的容量：&quot; + linkedBlockingQueue.remainingCapacity());            try &#123;                TimeUnit.SECONDS.sleep(5);                // 检索并删除此队列的头                Object take = linkedBlockingQueue.take();                System.out.println(&quot;当前linkedBlockingQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        linkedBlockingQueue.put(&quot;Message 4&quot;);        linkedBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行put()签名方法-结束=====&quot;);    &#125;    /**     * 检索并删除此队列的头，则等待空间变为可用。     执行结果：     =====执行poll()签名方法-开始=====     当前linkedBlockingQueue对象中的个数：【3】,容量：【0】     当前linkedBlockingQueue对象中poll()数据值为：Message 1     当前linkedBlockingQueue对象中poll()数据值为：Message 2     当前linkedBlockingQueue对象中的个数：【1】,容量：【2】     当前linkedBlockingQueue对象中poll()数据值为：Message 3     当前linkedBlockingQueue对象中poll()数据值为：null     当前linkedBlockingQueue对象中poll()数据值为：null     =====执行poll()签名方法-结束=====     */    public static void poll() throws InterruptedException &#123;        System.out.println(&quot;=====执行poll()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(&quot;=====执行poll()签名方法-结束=====&quot;);    &#125;    /**     * 检索但不删除此队列的头，如果此队列为空，则返回 null。     执行结果：         =====执行peek()签名方法-开始=====         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】         当前linkedBlockingQueue对象中peek()数据值为：Message 1         当前linkedBlockingQueue对象中peek()数据值为：Message 1         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】         当前linkedBlockingQueue对象中peek()数据值为：Message 1         当前linkedBlockingQueue对象中peek()数据值为：Message 1         当前linkedBlockingQueue对象中peek()数据值为：Message 1         =====执行peek()签名方法-结束=====     */    public static void peek() throws InterruptedException &#123;        System.out.println(&quot;=====执行peek()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(&quot;=====执行peek()签名方法-结束=====&quot;);    &#125;    /**     * 检索，但不删除，这个队列的头。 此方法与peek的不同之处在于，如果此队列为空，它将抛出异常。     执行结果：         =====执行element()签名方法-开始=====         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】         当前linkedBlockingQueue对象中的个数：【0】,容量：【3】         Exception in thread &quot;main&quot; java.util.NoSuchElementException         at java.util.AbstractQueue.element(AbstractQueue.java:136)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.element(LinkedBlockingQueueExample.java:181)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.main(LinkedBlockingQueueExample.java:14)     */    public static void element() throws InterruptedException &#123;        System.out.println(&quot;=====执行element()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        linkedBlockingQueue.clear();        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中element()数据值为：&quot; + linkedBlockingQueue.element());        System.out.println(&quot;=====执行element()签名方法-结束=====&quot;);    &#125;    /**     * 检索并删除此队列的头。 此方法与poll不同之处在于，如果此队列为空，它将抛出异常。     执行结果：         =====执行remove()签名方法-开始=====         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】         当前linkedBlockingQueue对象中remove()数据值为：Message 1         当前linkedBlockingQueue对象中remove()数据值为：Message 2         当前linkedBlockingQueue对象中remove()数据值为：Message 3         Exception in thread &quot;main&quot; java.util.NoSuchElementException         at java.util.AbstractQueue.remove(AbstractQueue.java:117)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.remove(LinkedBlockingQueueExample.java:205)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.main(LinkedBlockingQueueExample.java:15)     */    public static void remove() throws InterruptedException &#123;        System.out.println(&quot;=====执行remove()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot; + linkedBlockingQueue.remove());        System.out.println(&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot; + linkedBlockingQueue.remove());        System.out.println(&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot; + linkedBlockingQueue.remove());        System.out.println(&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot; + linkedBlockingQueue.remove());        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;=====执行remove()签名方法-结束=====&quot;);    &#125;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十一)Java多线程之SingleThreadExecutor单线程化线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%80)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSingleThreadExecutor%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA多线程(二十一)Java多线程之SingleThreadExecutor单线程化线程池1.1 单线程化线程池SingleThreadExecutor&emsp;&emsp; SingleThreadExecutor 是只有一个线程的线程池。通过源代码查看SingleThreadExecutor实现：
/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.)  Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * &#123;@code newFixedThreadPool(1)&#125; the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */public static ExecutorService newSingleThreadExecutor() &#123;    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue, and uses the provided ThreadFactory to * create a new thread when needed. Unlike the otherwise * equivalent &#123;@code newFixedThreadPool(1, threadFactory)&#125; the * returned executor is guaranteed not to be reconfigurable to use * additional threads. * * @param threadFactory the factory to use when creating new * threads * * @return the newly created single-threaded Executor * @throws NullPointerException if threadFactory is null */public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;(),                                threadFactory));&#125;/** * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;. */public LinkedBlockingQueue() &#123;    this(Integer.MAX_VALUE);&#125;
在SingleThreadExecutor实现中：

corePoolSize &amp;&amp; maximumPoolSize，corePoolSize 和 maximumPoolSize 都被设置为：1。
keepAliveTime &#x3D;&gt; keepAliveTime为0，意味着多余的空闲线程会被立即终止。
workQueue &#x3D;&gt; 采用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE），会在循环中反复从LinkedBlockingQueue获取任务来执行。

1.2 SingleThreadExecutor使用样例
单线程化线程池SingleThreadExecutor特点：
只有一个核心线程（保证所有任务按照指定顺序在一个线程中执行，不需要处理线程同步的问题）。
应用场景：不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作，文件操作等。


SingleThreadExecutor的意义：
缓存线程、进行池化，可实现线程重复利用、避免重复创建和销毁所带来的性能开销。
当线程调度任务出现异常时，会重新创建一个线程替代掉发生异常的线程。
任务执行按照规定的调度规则执行。线程池通过队列形式来接收任务。再通过空闲线程来逐一取出进行任务调度。即线程池可以控制任务调度的执行顺序。
可制定拒绝策略。即任务队列已满时，后来任务的拒绝处理规则。



package com.yuanxw.chapter21;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;public class ScheduledThreadPoolExample &#123;    // 随机数：使用long参数的所有64位作为因子值。    private static Random random = new Random(System.currentTimeMillis());    public static void main(String[] args) &#123;        // 使用Executors创建单个worker线程的Executor        ExecutorService executorService = Executors.newSingleThreadExecutor();        // 始终只有一个线程，执行ScheduledThreadPoolExample#processTask方法        IntStream.range(1, 10).forEach(i -&gt; executorService.execute(ScheduledThreadPoolExample::processTask));        // corePoolSize 和 maximumPoolSize都是：1，因此应用程序不会结束，需要调用executorService.shutdown()方法，关闭线程池。        executorService.shutdown();    &#125;    /**     * 线程休眠的方法     */    private static void processTask() &#123;        try &#123;            long start = System.currentTimeMillis();            TimeUnit.SECONDS.sleep(random.nextInt(5));            long end = System.currentTimeMillis();            System.out.println(String.format(&quot;【%s】线程执行结束，耗时【%s】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, Thread.currentThread().getName(),((end - start)/1000)));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
执行结果：
【pool-1-thread-1】线程执行结束，耗时【1】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【2】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【4】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【2】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【3】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【1】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【1】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【4】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【3】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

SingleThreadExecutor 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：

如果当前运行的线程数少于 corePoolSize，则创建一个新的线程执行任务；
当前线程池中有一个运行的线程后，将任务加入 LinkedBlockingQueue
线程执行完当前的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十一)Java多线程之SingleThreadExecutor单线程化线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%89)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BScheduledThreadPool%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池1.1 定时执行任务线程池ScheduledThreadPoolExecutor&emsp;&emsp; ScheduledThreadPoolExecutor是一个使用线程池执行定时任务的类，相较于Java中提供的另一个执行定时任务的类Timer，其主要有如下两个优点：

使用多线程执行任务，不用担心任务执行时间过长而导致任务相互阻塞的情况，Timer是单线程执行的，因而会出现这个问题。
不用担心任务执行过程中，如果线程失活，其会新建线程执行任务，Timer类的单线程挂掉之后是不会重新创建线程执行后续任务的。

时cheduledThreadPoolExecutor定 执行任务线程池继承结构关系图：
通过源代码查看ScheduledThreadPoolExecutor构造函数实现：
/** * 创建一个ScheduledThreadPoolExecutor，需要指定核心线程池大小。 * Creates a new &#123;@code ScheduledThreadPoolExecutor&#125; with the * given core pool size. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */public ScheduledThreadPoolExecutor(int corePoolSize) &#123;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue());&#125;/** * Creates a new ScheduledThreadPoolExecutor with the given * initial parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; * @throws NullPointerException if &#123;@code handler&#125; is null */public ScheduledThreadPoolExecutor(int corePoolSize,                                   RejectedExecutionHandler handler) &#123;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue(), handler);&#125;/** * Creates a new &#123;@code ScheduledThreadPoolExecutor&#125; with the * given initial parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param threadFactory the factory to use when the executor *        creates a new thread * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; * @throws NullPointerException if &#123;@code threadFactory&#125; is null */public ScheduledThreadPoolExecutor(int corePoolSize,                                   ThreadFactory threadFactory) &#123;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue(), threadFactory);&#125;/** * Creates a new ScheduledThreadPoolExecutor with the given * initial parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param threadFactory the factory to use when the executor *        creates a new thread * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; * @throws NullPointerException if &#123;@code threadFactory&#125; or *         &#123;@code handler&#125; is null */public ScheduledThreadPoolExecutor(int corePoolSize,                                   ThreadFactory threadFactory,                                   RejectedExecutionHandler handler) &#123;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue(), threadFactory, handler);&#125;
在ScheduledThreadPoolExecutor实现中：

corePoolSize &#x3D;&gt; 需要自己传递参数，指定核心线程数大小。
maximumPoolSize &#x3D;&gt; 允许最大的线程数默认Integer.MAX_VALUE无限大。
keepAliveTime &#x3D;&gt; keepAliveTime为0，意味着多余的空闲线程会被立即终止。
workQueue &#x3D;&gt; 采用DelayedWorkQueue作为线程池的工作队列。该队列是一个使用数组实现的优先队列，在调用ScheduledFutureTask::cancel()方法时，其会根据removeOnCancel变量的设置来确认是否需要将当前任务真正的从队列中移除，而不只是标识其为已删除状态。

1.2 ScheduledThreadPoolExecutor使用样例package com.yuanxw.chapter23;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ScheduledThreadPoolExample &#123;    public static void main(String[] args) &#123;        // schedule();        // scheduleAtFixedRate();        scheduleWithFixedDelay();    &#125;    /**     * 单次定时任务调用     * schedule(Runnable command, long delay, TimeUnit unit) // 无返回值的延迟任务     * schedule(Callable callable, long delay, TimeUnit unit) // 有返回值的延迟任务     */    private static void schedule() &#123;        // 设置核心线程数        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);        // 创建并执行在给定延迟后启用的单次操作。        ScheduledFuture&lt;?&gt; scheduledFuture = scheduledThreadPoolExecutor.schedule(() -&gt; System.out.println(&quot;定时任务正在被执行&gt;&gt;&gt;&quot;), 2L, TimeUnit.SECONDS);        // 尝试取消执行此任务。        System.out.println(scheduledFuture.cancel(true));    &#125;    /**         执行结果：          true     */          /**     * 固定频率周期任务     * 注意：一次任务超时，会持续的影响后续的任务周期；     */    private static void scheduleAtFixedRate()&#123;        // 设置核心线程数        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(5);        scheduledThreadPoolExecutor.scheduleAtFixedRate(()-&gt;System.out.println(String.format(&quot;===定时任务线程【%s】正在执行，执行时间：【%s】===&quot;, Thread.currentThread().getName(),System.currentTimeMillis())),2,2,TimeUnit.SECONDS);        /**         执行结果：          ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580728645370】===          ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580728647372】===          ===定时任务线程【pool-1-thread-2】正在执行，执行时间：【1580728649372】===          ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580728651374】===          ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580728653371】===         */    &#125;    /**     * 固定延迟周期任务     * 注意：固定延迟周期任务，即每次任务结束后，需要再加上等待固定时间；     */    private static void scheduleWithFixedDelay()&#123;        // 设置核心线程数        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(5);        scheduledThreadPoolExecutor.scheduleWithFixedDelay(() -&gt; &#123;            System.out.println(String.format(&quot;===定时任务线程【%s】正在执行，执行时间：【%s】===&quot;, Thread.currentThread().getName(),System.currentTimeMillis()));            try &#123;                // 睡眠5秒                TimeUnit.SECONDS.sleep(5);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,1,2,TimeUnit.SECONDS);        /**         执行结果：         ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580729087258】===         ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580729094268】===         ===定时任务线程【pool-1-thread-2】正在执行，执行时间：【1580729101272】===         ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580729108273】===         ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580729115275】===         ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580729122277】===         ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580729129279】===         */    &#125;&#125;

1.3 ScheduledThreadPoolExecutor运行机制&emsp;&emsp; ScheduledThreadPoolExecutor 使用的任务队列 DelayQueue 封装了一个 PriorityQueue，PriorityQueue 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(ScheduledFutureTask 的 time 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(ScheduledFutureTask 的 squenceNumber 变量小的先执行)。

ScheduledThreadPoolExecutor 和 Timer 的比较：

Timer 对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是；
Timer 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 ScheduledThreadPoolExecutor 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程;
在TimerTask 中抛出的运行时异常会杀死一个线程，从而导致 Timer 死机:-( …即计划任务将不再运行。ScheduledThreadExecutor 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 afterExecute 方法ThreadPoolExecutor）。抛出异常的任务将被取消，但其他任务将继续运行。


ScheduledThreadPoolExecutor 的执行主要分为两大部分：

当调用 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate() 方法或者scheduleWirhFixedDelay() 方法时，会向 ScheduledThreadPoolExecutor 的 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduledFutureTask 。  线程池中的线程从 DelayQueue 中获取 ScheduledFutureTask，然后执行任务。


ScheduledThreadPoolExecutor 为了实现周期性的执行任务，对 ThreadPoolExecutor 做了如下修改：

使用 DelayQueue 作为任务队列；
获取任务的方不同
执行周期任务后，增加了额外的处理



1.4 ScheduledThreadPoolExecutor 执行周期任务的步骤

线程 1 从 DelayQueue 中获取已到期的 ScheduledFutureTask（DelayQueue.take()）。到期任务是指 ScheduledFutureTask 的 time 大于等于当前系统的时间；
线程 1 执行这个 ScheduledFutureTask；
线程 1 修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间；
线程 1 把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add())。

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%BA%8C)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BWorkStealingPool%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池1.1 工作窃取线程池WorkStealingPool&emsp;&emsp; 在Java 8中，引入了一种新型的线程池，作为newWorkStealingPool()来补充现有的线程池。WorkStealingPool线程池，来维持相应的并行级别，它会通过工作窃取的方式，使得多核的 CPU 不会闲置，总会有活着的线程让 CPU 去运行。
&emsp;&emsp;顾名思义，它基于  工作窃取算法，其中任务可以生成其他较小的任务，这些任务将添加到并行处理线程的队列中。如果一个线程完成了工作并且无事可做，则可以从另一线程的队列中“窃取”工作。通过源代码查看WorkStealingPool实现：
/** * Creates a work-stealing thread pool using all * &#123;@link Runtime#availableProcessors available processors&#125; * as its target parallelism level. * @return the newly created thread pool * @see #newWorkStealingPool(int) * @since 1.8 */public static ExecutorService newWorkStealingPool() &#123;    return new ForkJoinPool        (Runtime.getRuntime().availableProcessors(),         ForkJoinPool.defaultForkJoinWorkerThreadFactory,         null, true);&#125;/** * Creates a thread pool that maintains enough threads to support * the given parallelism level, and may use multiple queues to * reduce contention. The parallelism level corresponds to the * maximum number of threads actively engaged in, or available to * engage in, task processing. The actual number of threads may * grow and shrink dynamically. A work-stealing pool makes no * guarantees about the order in which submitted tasks are * executed. * * @param parallelism the targeted parallelism level * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code parallelism &lt;= 0&#125; * @since 1.8 */public static ExecutorService newWorkStealingPool(int parallelism) &#123;    return new ForkJoinPool        (parallelism,         ForkJoinPool.defaultForkJoinWorkerThreadFactory,         null, true);&#125;
在WorkStealingPool实现中：

parallelism &#x3D;&gt; Runtime.getRuntime().availableProcessors() - 这是JVM可用的处理器数。
handler &#x3D;&gt; ForkJoinPool.defaultForkJoinWorkerThreadFactory - 返回新线程的默认线程工厂。
asyncMode &#x3D;&gt; true – 使其在aysnc模式下工作，并为分叉的任务设置FIFO顺序，这些任务永远不会从其工作队列中加入。


1.2 WorkStealingPool使用样例
单线程化线程池WorkStealingPool特点：
WorkStealingPool是守护线程，使用ForkJoinPool实现的WorkStealingPool根据当前操作系统的CPU有几个核就会创建几个线程。
应用场景：WorkStealingPool能够合理的使用CPU进行对任务操作（并行操作）适合使用在很耗时的操作。



package com.yuanxw.chapter22;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.stream.Collectors;import java.util.stream.IntStream;/** * 使用WorkStealingPool工作窃取线程池，创建Callable类型的多线程，并最终返回结果 * https://blog.csdn.net/yuan_xw/article/details/103730628 */public class WorkStealingPoolExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        System.out.println(&quot;获得JAVA虚拟机可用的最大CPU处理器数量：&quot; + Runtime.getRuntime().availableProcessors());        ExecutorService executorService = Executors.newWorkStealingPool();        /**         * call方法存在返回值futureTask的get方法可以获取这个返回值。         * 使用此种方法实现线程的好处是当你创建的任务的结果不是立即就要时，         * 你可以提交一个线程在后台执行，而你的程序仍可以正常运行下去，         * 在需要执行结果时使用futureTask去获取即可。         */        List&lt;Callable&lt;String&gt;&gt; callableList = IntStream.range(0, 20).boxed().map(i -&gt; (Callable&lt;String&gt;) () -&gt; &#123;            TimeUnit.SECONDS.sleep(3);            System.out.println(String.format(&quot;当前【%s】线程正在执行&gt;&gt;&gt;&quot;, Thread.currentThread().getName()));            return &quot;callable type thread task：&quot; + i;        &#125;).collect(Collectors.toList());        // 执行给定的任务，返回持有他们的状态和结果的所有完成的期待列表。        executorService.invokeAll(callableList).stream().map(futureTask-&gt; &#123;            try &#123;                return futureTask.get();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; catch (ExecutionException e) &#123;                e.printStackTrace();            &#125;            return null;        &#125;).forEach(System.out::println);    &#125;&#125;
执行结果：
获得JAVA虚拟机可用的最大CPU处理器数量：8当前【ForkJoinPool-1-worker-0】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-6】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-1】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-3】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-5】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-7】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-2】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-4】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-1】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-3】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-2】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-5】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-6】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-0】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-7】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-4】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-1】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-2】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-5】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-3】线程正在执行&gt;&gt;&gt;callable type thread task：0callable type thread task：1callable type thread task：2callable type thread task：3callable type thread task：4callable type thread task：5callable type thread task：6callable type thread task：7callable type thread task：8callable type thread task：9callable type thread task：10callable type thread task：11callable type thread task：12callable type thread task：13callable type thread task：14callable type thread task：15callable type thread task：16callable type thread task：17callable type thread task：18callable type thread task：19



 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%BA%94)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BArrayBlockingQueue%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[1.JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器1.1 什么是 BlockingQueue&emsp;&emsp;阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。
BlockingQueue 和 ArrayBlockingQueue 之间的关系：&emsp;&emsp;BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 继承结构关系图：
1.2 ArrayBlockingQueue 有界的阻塞队列&emsp;&emsp;ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。
ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。通过源代码查看 ArrayBlockingQueue 实现：
/** * 创建具有给定（固定）容量和默认访问策略的 ArrayBlockingQueue 。 * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed) * capacity and default access policy. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125; */public ArrayBlockingQueue(int capacity) &#123;    this(capacity, false);&#125;/** * 创建一个 ArrayBlockingQueue具有给定（固定）容量和指定访问策略。 * 如果true然后对插入或删除阻塞的线程进行队列访问，则按FIFO顺序处理; 如果false访问顺序未指定。 * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed) * capacity and the specified access policy. * * @param capacity the capacity of this queue * @param fair if &#123;@code true&#125; then queue accesses for threads blocked *        on insertion or removal, are processed in FIFO order; *        if &#123;@code false&#125; the access order is unspecified. * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125; */public ArrayBlockingQueue(int capacity, boolean fair) &#123;    if (capacity &lt;= 0)        throw new IllegalArgumentException();    this.items = new Object[capacity];    lock = new ReentrantLock(fair);    notEmpty = lock.newCondition();    notFull =  lock.newCondition();&#125;/** * 创建一个 ArrayBlockingQueue具有给定（固定）容量，指定访问策略和最初包含给定集合中的元素，添加在收集* 迭代器的遍历顺序。 * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed) * capacity, the specified access policy and initially containing the * elements of the given collection, * added in traversal order of the collection&#x27;s iterator. * * @param capacity the capacity of this queue * @param fair if &#123;@code true&#125; then queue accesses for threads blocked *        on insertion or removal, are processed in FIFO order; *        if &#123;@code false&#125; the access order is unspecified. * @param c the collection of elements to initially contain * @throws IllegalArgumentException if &#123;@code capacity&#125; is less than *         &#123;@code c.size()&#125;, or less than 1. * @throws NullPointerException if the specified collection or any *         of its elements are null */public ArrayBlockingQueue(int capacity, boolean fair,                          Collection&lt;? extends E&gt; c) &#123;    this(capacity, fair);    final ReentrantLock lock = this.lock;    lock.lock(); // Lock only for visibility, not mutual exclusion    try &#123;        int i = 0;        try &#123;            for (E e : c) &#123;                checkNotNull(e);                items[i++] = e;            &#125;        &#125; catch (ArrayIndexOutOfBoundsException ex) &#123;            throw new IllegalArgumentException();        &#125;        count = i;        putIndex = (i == capacity) ? 0 : i;    &#125; finally &#123;        lock.unlock();    &#125;&#125;

1.3 ArrayBlockingQueue 有界的阻塞队列特点
ArrayBlockingQueue 是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。
ArrayBlockingQueue 是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改。

1.4 常用的方法package com.yuanxw.thread.chapter25;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class ArrayBlockingQueueExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        // add();        // offer();        // put();        // poll();        // peek();        // element();        remove();    &#125;    /**     * 如果可以在不超过队列的容量的情况下立即将其指定的元素插入到该队列的尾部，     * 如果队列已满，则返回 true并抛出 IllegalStateException 。     * 执行结果：     *     =====执行add()签名方法-开始=====     *     arrayBlockingQueue.add()执行返回结果：true     *     arrayBlockingQueue.add()执行返回结果：true     *     arrayBlockingQueue.add()执行返回结果：true     *     Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full     *     at java.util.AbstractQueue.add(AbstractQueue.java:98)     *     at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)     *     at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.add(ArrayBlockingQueueExample.java:28)     *     at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.main(ArrayBlockingQueueExample.java:7)     */    public static void add() &#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        System.out.println(&quot;arrayBlockingQueue.add()执行返回结果：&quot;+arrayBlockingQueue.add(&quot;Message 1&quot;));        System.out.println(&quot;arrayBlockingQueue.add()执行返回结果：&quot;+arrayBlockingQueue.add(&quot;Message 2&quot;));        System.out.println(&quot;arrayBlockingQueue.add()执行返回结果：&quot;+arrayBlockingQueue.add(&quot;Message 3&quot;));        System.out.println(&quot;arrayBlockingQueue.add()执行返回结果：&quot;+arrayBlockingQueue.add(&quot;Message 4&quot;));        System.out.println(&quot;=====执行add()签名方法-结束=====&quot;);    &#125;    /**      * 如果可以在不超过队列容量的情况下立即将其指定的元素插入该队列的尾部，      * 则在成功时true如果该队列已满，则返回false 。      * 执行结果：      *  =====执行offer()签名方法-开始=====      *  arrayBlockingQueue.offer()执行返回结果：true      *  arrayBlockingQueue.offer()执行返回结果：true      *  arrayBlockingQueue.offer()执行返回结果：true      *  arrayBlockingQueue.offer()执行返回结果：false      *  =====执行offer()签名方法-结束=====      */    public static void offer()&#123;        System.out.println(&quot;=====执行offer()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        System.out.println(&quot;arrayBlockingQueue.offer()执行返回结果：&quot;+arrayBlockingQueue.offer(&quot;Message 1&quot;));        System.out.println(&quot;arrayBlockingQueue.offer()执行返回结果：&quot;+arrayBlockingQueue.offer(&quot;Message 2&quot;));        System.out.println(&quot;arrayBlockingQueue.offer()执行返回结果：&quot;+arrayBlockingQueue.offer(&quot;Message 3&quot;));        System.out.println(&quot;arrayBlockingQueue.offer()执行返回结果：&quot;+arrayBlockingQueue.offer(&quot;Message 4&quot;));        System.out.println(&quot;=====执行offer()签名方法-结束=====&quot;);    &#125;    /**      * 在该队列的尾部插入指定的元素，如果队列已满，则等待空间变为可用。      *  执行结果：      *   =====执行put()签名方法-开始=====      *   当前arrayBlockingQueue对象中的个数：3      *   当前arrayBlockingQueue对象中的容量：0      *   当前arrayBlockingQueue对象中take()数据值为：Message 1      *   Message 2      *   Message 3      *   Message 4      *   =====执行put()签名方法-结束=====     */    public static void put() throws InterruptedException &#123;        System.out.println(&quot;=====执行put()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        Executors.newSingleThreadExecutor().execute(()-&gt;&#123;            System.out.println(&quot;当前arrayBlockingQueue对象中的个数：&quot; + arrayBlockingQueue.size());            System.out.println(&quot;当前arrayBlockingQueue对象中的容量：&quot; + arrayBlockingQueue.remainingCapacity());            try &#123;                TimeUnit.SECONDS.sleep(5);                // 检索并删除此队列的头                Object take = arrayBlockingQueue.take();                System.out.println(&quot;当前arrayBlockingQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        arrayBlockingQueue.put(&quot;Message 4&quot;);        arrayBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行put()签名方法-结束=====&quot;);    &#125;    /**      * 检索并删除此队列的头，则等待空间变为可用。      *  执行结果：      *   =====执行poll()签名方法-开始=====      *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】      *   当前arrayBlockingQueue对象中poll()数据值为：Message 1      *   当前arrayBlockingQueue对象中poll()数据值为：Message 2      *   当前arrayBlockingQueue对象中的个数：【1】,容量：【2】      *   当前arrayBlockingQueue对象中poll()数据值为：Message 3      *   当前arrayBlockingQueue对象中poll()数据值为：null      *   当前arrayBlockingQueue对象中poll()数据值为：null      *   =====执行poll()签名方法-结束=====     */    public static void poll() throws InterruptedException &#123;        System.out.println(&quot;=====执行poll()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(&quot;=====执行poll()签名方法-结束=====&quot;);    &#125;    /**      * 检索但不删除此队列的头，如果此队列为空，则返回 null。      *  执行结果：      *   =====执行peek()签名方法-开始=====      *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   =====执行peek()签名方法-结束=====     */    public static void peek() throws InterruptedException &#123;        System.out.println(&quot;=====执行peek()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(&quot;=====执行peek()签名方法-结束=====&quot;);    &#125;    /**     * 检索，但不删除，这个队列的头。 此方法与peek的不同之处在于，如果此队列为空，它将抛出异常。     *  执行结果：     *   =====执行element()签名方法-开始=====     *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】     *   当前arrayBlockingQueue对象中take()数据值为：Message 1     *   当前arrayBlockingQueue对象中take()数据值为：Message 2     *   当前arrayBlockingQueue对象中take()数据值为：Message 3     *   当前arrayBlockingQueue对象中的个数：【0】,容量：【3】     *   Exception in thread &quot;main&quot; java.util.NoSuchElementException     *   at java.util.AbstractQueue.element(AbstractQueue.java:136)     *   at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.element(ArrayBlockingQueueExample.java:182)     *   at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.main(ArrayBlockingQueueExample.java:14)     */    public static void element() throws InterruptedException &#123;        System.out.println(&quot;=====执行element()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中take()数据值为：&quot; + arrayBlockingQueue.take());        System.out.println(&quot;当前arrayBlockingQueue对象中take()数据值为：&quot; + arrayBlockingQueue.take());        System.out.println(&quot;当前arrayBlockingQueue对象中take()数据值为：&quot; + arrayBlockingQueue.take());        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中element()数据值为：&quot; + arrayBlockingQueue.element());        System.out.println(&quot;=====执行element()签名方法-结束=====&quot;);    &#125;    /**      * 检索并删除此队列的头。 此方法与poll不同之处在于，如果此队列为空，它将抛出异常。      * 执行结果：      * =====执行remove()签名方法-开始=====      * 当前arrayBlockingQueue对象中的个数：【3】,容量：【0】      * 当前arrayBlockingQueue对象中remove()数据值为：Message 1      * 当前arrayBlockingQueue对象中remove()数据值为：Message 2      * 当前arrayBlockingQueue对象中remove()数据值为：Message 3      * Exception in thread &quot;main&quot; java.util.NoSuchElementException      * at java.util.AbstractQueue.remove(AbstractQueue.java:117)      * at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.remove(ArrayBlockingQueueExample.java:212)      * at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.main(ArrayBlockingQueueExample.java:15)     */    public static void remove() throws InterruptedException &#123;        System.out.println(&quot;=====执行remove()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot; + arrayBlockingQueue.remove());        System.out.println(&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot; + arrayBlockingQueue.remove());        System.out.println(&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot; + arrayBlockingQueue.remove());        System.out.println(&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot; + arrayBlockingQueue.remove());        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;=====执行remove()签名方法-结束=====&quot;);    &#125;&#125;

&emsp;&emsp;&emsp;&emsp;– 以上为《JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。
  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十八)Java多线程之SynchronousQueue容器</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%85%AB)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSynchronousQue/</url>
    <content><![CDATA[1.JAVA多线程(二十八)Java多线程之SynchronousQueue容器1.1 什么是SynchronousQueue&emsp;&emsp;Java 6的并发编程包中的SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。
不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的线程，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。
SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。
下面是 SynchronousQueue继承结构关系图：

通过源代码查看SynchronousQueue实现：
/** * 创建一个 SynchronousQueue非公平策略。  * Creates a &#123;@code SynchronousQueue&#125; with nonfair access policy. */public SynchronousQueue() &#123;    this(false);&#125;/** * 创建一个 SynchronousQueue非公平策略。 如果fair参数：true，等待线程在FIFO顺序中进行访问;  * Creates a &#123;@code SynchronousQueue&#125; with the specified fairness policy. * * @param fair if true, waiting threads contend in FIFO order for *        access; otherwise the order is unspecified. */public SynchronousQueue(boolean fair) &#123;    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();&#125;
1.2 SynchronousQueue队列特点
SynchronousQueue没有容量。与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。

因为没有容量，所以对应的peek、contains、clear、isEmpty…..等方法其实是无效的。例如clear是不执行任何操作的，contains始终返回false，peek始终返回null。

SynchronousQueue分为公平和非公平，默认情况下采用非公平性访问策略，当然也可以通过构造函数来设置为公平性访问策略（为true即可）。

SynchronousQueue内部采用了无锁实现（CAS）。


1.3 常用的方法package com.yuanxw.thread.chapter28;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;public class SynchronousQueueExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        // add();        // addAndTake();        // offer();        put();    &#125;    /**     如果可以在不超过队列的容量的情况下立即将其指定的元素插入到该队列中，     如果队列已满，则返回 true并抛出 IllegalStateException 。     执行结果：         =====执行add()签名方法-开始=====         Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full         at java.util.AbstractQueue.add(AbstractQueue.java:98)         at com.yuanxw.thread.chapter28.SynchronousQueueExample.add(SynchronousQueueExample.java:16)         at com.yuanxw.thread.chapter28.SynchronousQueueExample.main(SynchronousQueueExample.java:10)     */    public static void add() throws InterruptedException &#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        SynchronousQueue synchronousQueue = new SynchronousQueue();        synchronousQueue.add(&quot;Message 1&quot;);        System.out.println(&quot;=====执行add()签名方法-结束=====&quot;);    &#125;    public static void addAndTake() throws InterruptedException &#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        SynchronousQueue synchronousQueue = new SynchronousQueue();        ExecutorService executorService = Executors.newSingleThreadExecutor();        executorService.execute(()-&gt;&#123;            try &#123;                System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, synchronousQueue.size(),synchronousQueue.remainingCapacity()));                Object take = synchronousQueue.take();                System.out.println(&quot;当前synchronousQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        TimeUnit.SECONDS.sleep(3);        System.out.println(&quot;synchronousQueue.add()执行返回结果：&quot;+synchronousQueue.add(&quot;Message 1&quot;));        executorService.shutdown();        System.out.println(&quot;=====执行add()签名方法-结束=====&quot;);    &#125;    /**     如果另一个线程正在等待接收，则将指定的元素插入到此队列中。     true如果元素被添加到这个队列，否则 false     执行结果：         =====执行offer()签名方法-开始=====         synchronousQueue.offer()执行返回结果：false         ------------------------------------         synchronousQueue.offer()执行返回结果：true         当前synchronousQueue对象中take()数据值为：Message 2         =====执行offer()签名方法-结束=====     */    public static void offer() throws InterruptedException &#123;        System.out.println(&quot;=====执行offer()签名方法-开始=====&quot;);        SynchronousQueue synchronousQueue = new SynchronousQueue();        System.out.println(&quot;synchronousQueue.offer()执行返回结果：&quot;+synchronousQueue.offer(&quot;Message 1&quot;));        System.out.println(&quot;------------------------------------&quot;);        ExecutorService executorService = Executors.newSingleThreadExecutor();        executorService.execute(()-&gt;&#123;            try &#123;                Object take = synchronousQueue.take();                System.out.println(&quot;当前synchronousQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        TimeUnit.SECONDS.sleep(3);        System.out.println(&quot;synchronousQueue.offer()执行返回结果：&quot;+synchronousQueue.offer(&quot;Message 2&quot;));        executorService.shutdown();        System.out.println(&quot;=====执行offer()签名方法-结束=====&quot;);    &#125;    /**     * 将指定的元素添加到此队列，等待另一个线程接收它。     执行结果：         =====执行put()签名方法-开始=====         当前synchronousQueue对象中take()数据值为：Message 1         =====执行put()签名方法-结束=====     */    public static void put() throws InterruptedException &#123;        System.out.println(&quot;=====执行put()签名方法-开始=====&quot;);        SynchronousQueue synchronousQueue = new SynchronousQueue();        ExecutorService executorService = Executors.newSingleThreadExecutor();        executorService.execute(()-&gt;&#123;            try &#123;                TimeUnit.SECONDS.sleep(2);                // 检索并删除此队列的头                Object take = synchronousQueue.take();                System.out.println(&quot;当前synchronousQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        // put方法会阻塞，直到有一个线程获取。        synchronousQueue.put(&quot;Message 1&quot;);        executorService.shutdown();        System.out.println(&quot;=====执行put()签名方法-结束=====&quot;);    &#125;&#125;
1.4 应用场景 &emsp;&emsp;可缓存线程池CachedThreadPool的源码实现，使用SynchronousQueue作为工作队列，工作队列本身并不限制待执行的任务的数量。但此时需要限定线程池的最大大小为一个合理的有限值，而不是Integer.MAX_VALUE，否则可能导致线程池中的工作者线程的数量一直增加到系统资源所无法承受为止。如果应用程序确实需要比较大的工作队列容量，而又想避免无界工作队列可能导致的问题，不妨考虑SynchronousQueue。SynchronousQueue实现上并不使用缓存空间。使用SynchronousQueue的目的就是保证“对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务”。JAVA多线程(十九)Java多线程之CachedThreadPool可缓存线程池。
&emsp;&emsp;可缓存线程池CachedThreadPool源代码实现：
/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available.  These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */public static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());&#125;



 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十八)Java多线程之SynchronousQueue容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%85%AD)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BPriorityBlockingQueue%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[1.JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器1.1 什么是PriorityBlockingQueue&emsp;&emsp;PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。
PriorityBlockingQueue 并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。
下面是 PriorityBlockingQueue继承结构关系图：
1.2 PriorityBlockingQueue无界阻塞队列&emsp;&emsp;简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。通过源代码查看PriorityBlockingQueue实现：
/** * 创建一个PriorityBlockingQueue ，具有默认的初始容量（11），根据它们的Comparable对其元素进行排序 。  * * Creates a &#123;@code PriorityBlockingQueue&#125; with the default * initial capacity (11) that orders its elements according to * their &#123;@linkplain Comparable natural ordering&#125;. */public PriorityBlockingQueue() &#123;    this(DEFAULT_INITIAL_CAPACITY, null);&#125;/** * 创建一个PriorityBlockingQueue ，指定容量大小，根据它们的Comparable对其元素进行排序 。  * * Creates a &#123;@code PriorityBlockingQueue&#125; with the specified * initial capacity that orders its elements according to their * &#123;@linkplain Comparable natural ordering&#125;. * * @param initialCapacity the initial capacity for this priority queue * @throws IllegalArgumentException if &#123;@code initialCapacity&#125; is less *         than 1 */public PriorityBlockingQueue(int initialCapacity) &#123;    this(initialCapacity, null);&#125;/** * 创建具有 PriorityBlockingQueue初始容量的PriorityBlockingQueue，根据指定的比较器对其元素进行排序。  * * Creates a &#123;@code PriorityBlockingQueue&#125; with the specified initial * capacity that orders its elements according to the specified * comparator. * * @param initialCapacity the initial capacity for this priority queue * @param  comparator the comparator that will be used to order this *         priority queue.  If &#123;@code null&#125;, the &#123;@linkplain Comparable *         natural ordering&#125; of the elements will be used. * @throws IllegalArgumentException if &#123;@code initialCapacity&#125; is less *         than 1 */public PriorityBlockingQueue(int initialCapacity,                             Comparator&lt;? super E&gt; comparator) &#123;    if (initialCapacity &lt; 1)        throw new IllegalArgumentException();    this.lock = new ReentrantLock();    this.notEmpty = lock.newCondition();    this.comparator = comparator;    this.queue = new Object[initialCapacity];&#125;/** * 创建一个 PriorityBlockingQueue集合中的元素的PriorityBlockingQueue。  * 在指定的集合中。如果指定的集合是 &#123;@link SortedSet&#125;或&#123;@link PriorityQueue&#125;， * 这个优先队列将按照相同的顺序排序。否则，此优先队列将根据&#123;@linkplain可比较的自然排序&#125;。 * * Creates a &#123;@code PriorityBlockingQueue&#125; containing the elements * in the specified collection.  If the specified collection is a * &#123;@link SortedSet&#125; or a &#123;@link PriorityQueue&#125;, this * priority queue will be ordered according to the same ordering. * Otherwise, this priority queue will be ordered according to the * &#123;@linkplain Comparable natural ordering&#125; of its elements. * * @param  c the collection whose elements are to be placed *         into this priority queue * @throws ClassCastException if elements of the specified collection *         cannot be compared to one another according to the priority *         queue&#x27;s ordering * @throws NullPointerException if the specified collection or any *         of its elements are null */public PriorityBlockingQueue(Collection&lt;? extends E&gt; c) &#123;    this.lock = new ReentrantLock();    this.notEmpty = lock.newCondition();    boolean heapify = true; // true if not known to be in heap order    boolean screen = true;  // true if must screen for nulls    if (c instanceof SortedSet&lt;?&gt;) &#123;        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;        this.comparator = (Comparator&lt;? super E&gt;) ss.comparator();        heapify = false;    &#125;    else if (c instanceof PriorityBlockingQueue&lt;?&gt;) &#123;        PriorityBlockingQueue&lt;? extends E&gt; pq =            (PriorityBlockingQueue&lt;? extends E&gt;) c;        this.comparator = (Comparator&lt;? super E&gt;) pq.comparator();        screen = false;        if (pq.getClass() == PriorityBlockingQueue.class) // exact match            heapify = false;    &#125;    Object[] a = c.toArray();    int n = a.length;    // If c.toArray incorrectly doesn&#x27;t return Object[], copy it.    if (a.getClass() != Object[].class)        a = Arrays.copyOf(a, n, Object[].class);    if (screen &amp;&amp; (n == 1 || this.comparator != null)) &#123;        for (int i = 0; i &lt; n; ++i)            if (a[i] == null)                throw new NullPointerException();    &#125;    this.queue = a;    this.size = n;    if (heapify)        heapify();&#125;
1.3 PriorityBlockingQueue无界阻塞队列特点
PriorityBlockingQueue无界队列，只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容。
PriorityBlockingQueue不可以插入 null 值。
插入队列的对象必须是可比较大小的（comparable）。

1.4 常用的方法package com.yuanxw.thread.chapter26;import java.util.concurrent.PriorityBlockingQueue;public class PriorityBlockingQueueExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        // add();        // poll();        // peek();        // element();        // remove();        // addNoComparable();        addWithNull();            &#125;    /**     * PriorityBlockingQueue     * 将指定的元素插入到此优先级队列中。 由于队列无限制，此方法将永远不会返回false 。     * add()方法、put()方法，都调用用offer()方法。     执行结果：         =====执行add()签名方法-开始=====         Message 1         Message 2         Message 3         =====执行add()签名方法-开始=====     */    public static void add()&#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        // 创建一个PriorityBlockingQueue ，具有指定的初始容量，根据它们的natural ordering对其元素进行排序 。        // 超过容量之后会自动扩容        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(2);        priorityBlockingQueue.add(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.offer(&quot;Message 3&quot;);        priorityBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);    &#125;    /**     * 检索并删除此队列的头，则等待空间变为可用。     =====执行poll()签名方法-开始=====     执行结果：         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中poll()数据值为：Message 1         当前priorityBlockingQueue对象中poll()数据值为：Message 2         当前priorityBlockingQueue对象中的个数：【1】,容量：【2147483647】         当前priorityBlockingQueue对象中poll()数据值为：Message 3         当前priorityBlockingQueue对象中poll()数据值为：null         当前priorityBlockingQueue对象中poll()数据值为：null     =====执行poll()签名方法-结束=====     */    public static void poll() &#123;        System.out.println(&quot;=====执行poll()签名方法-开始=====&quot;);        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(2);        priorityBlockingQueue.put(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(&quot;=====执行poll()签名方法-结束=====&quot;);    &#125;    /**     * 检索但不删除此队列的头，如果此队列为空，则返回 null。     执行结果：         =====执行peek()签名方法-开始=====         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中peek()数据值为：Message 1         当前priorityBlockingQueue对象中peek()数据值为：Message 1         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中peek()数据值为：Message 1         当前priorityBlockingQueue对象中peek()数据值为：Message 1         当前priorityBlockingQueue对象中peek()数据值为：Message 1         =====执行peek()签名方法-结束=====     */    public static void peek()  &#123;        System.out.println(&quot;=====执行peek()签名方法-开始=====&quot;);        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(2);        priorityBlockingQueue.put(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(&quot;=====执行peek()签名方法-结束=====&quot;);    &#125;    /**     * 检索，但不删除，这个队列的头。 此方法与peek的不同之处在于，如果此队列为空，它将抛出异常。     执行结果：         =====执行element()签名方法-开始=====         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中take()数据值为：Message 1         当前priorityBlockingQueue对象中take()数据值为：Message 2         当前priorityBlockingQueue对象中take()数据值为：Message 3         当前priorityBlockingQueue对象中的个数：【0】,容量：【2147483647】         Exception in thread &quot;main&quot; java.util.NoSuchElementException         at java.util.AbstractQueue.element(AbstractQueue.java:136)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.element(PriorityBlockingQueueExample.java:123)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:11)     */    public static void element() throws InterruptedException &#123;        System.out.println(&quot;=====执行element()签名方法-开始=====&quot;);        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(3);        priorityBlockingQueue.put(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中take()数据值为：&quot; + priorityBlockingQueue.take());        System.out.println(&quot;当前priorityBlockingQueue对象中take()数据值为：&quot; + priorityBlockingQueue.take());        System.out.println(&quot;当前priorityBlockingQueue对象中take()数据值为：&quot; + priorityBlockingQueue.take());        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中element()数据值为：&quot; + priorityBlockingQueue.element());        System.out.println(&quot;=====执行element()签名方法-结束=====&quot;);    &#125;    /**     * 检索并删除此队列的头。 此方法与poll不同之处在于，如果此队列为空，它将抛出异常。     执行结果：         =====执行remove()签名方法-开始=====         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中remove()数据值为：Message 1         当前priorityBlockingQueue对象中remove()数据值为：Message 2         当前priorityBlockingQueue对象中remove()数据值为：Message 3         Exception in thread &quot;main&quot; java.util.NoSuchElementException         at java.util.AbstractQueue.remove(AbstractQueue.java:117)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.remove(PriorityBlockingQueueExample.java:151)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:12)     */    public static void remove() &#123;        System.out.println(&quot;=====执行remove()签名方法-开始=====&quot;);        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(3);        priorityBlockingQueue.put(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot; + priorityBlockingQueue.remove());        System.out.println(&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot; + priorityBlockingQueue.remove());        System.out.println(&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot; + priorityBlockingQueue.remove());        System.out.println(&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot; + priorityBlockingQueue.remove());        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;=====执行remove()签名方法-结束=====&quot;);    &#125;    /**     * 验证：     * 添加元素时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。     执行结果：         =====执行addNoComparable()签名方法-开始=====         Exception in thread &quot;main&quot; java.lang.ClassCastException: com.yuanxw.thread.chapter26.PriorityBlockingQueueExample$Order cannot be cast to java.lang.Comparable         at java.util.concurrent.PriorityBlockingQueue.siftUpComparable(PriorityBlockingQueue.java:358)         at java.util.concurrent.PriorityBlockingQueue.offer(PriorityBlockingQueue.java:490)         at java.util.concurrent.PriorityBlockingQueue.add(PriorityBlockingQueue.java:464)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.addNoComparable(PriorityBlockingQueueExample.java:166)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:12)     */    public static void addNoComparable()&#123;        System.out.println(&quot;=====执行addNoComparable()签名方法-开始=====&quot;);        // 默认长度为：11        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue();        priorityBlockingQueue.add(new Order());        priorityBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行addNoComparable()签名方法-结束=====&quot;);    &#125;    /**     * 验证：     * 添加元素时，插入队列的对象是null，报 NullPointerException 异常。     执行结果：         =====执行addWithNull()签名方法-开始=====         Exception in thread &quot;main&quot; java.lang.NullPointerException         at java.util.concurrent.PriorityBlockingQueue.offer(PriorityBlockingQueue.java:480)         at java.util.concurrent.PriorityBlockingQueue.add(PriorityBlockingQueue.java:464)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.addWithNull(PriorityBlockingQueueExample.java:194)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:13)     */    public static void addWithNull()&#123;        System.out.println(&quot;=====执行addWithNull()签名方法-开始=====&quot;);        // 默认长度为：11        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue();        priorityBlockingQueue.add(null);        priorityBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行addWithNull()签名方法-结束=====&quot;);    &#125;    private static class Order&#123;&#125;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十四)Java多线程之CompletableFuture类</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%9B%9B)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCompletableFuture%E7%B1%BB/</url>
    <content><![CDATA[1.JAVA多线程(二十四)Java多线程之CompletableFuture类1.1 什么是Future&emsp;&emsp;Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。
package com.yuanxw.chapter24;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.ThreadLocalRandom;import java.util.concurrent.TimeUnit;public class FutureExample &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        // 构造一个线程池        ExecutorService executorService = Executors.newCachedThreadPool();        // 提交线程任务        Future&lt;Integer&gt; future = executorService.submit(() -&gt; &#123;            try &#123;                System.out.println(String.format(&quot;当前【%s】线程工作-开始...&quot;, Thread.currentThread().getName()));                TimeUnit.SECONDS.sleep(10);                System.out.println(String.format(&quot;当前【%s】线程工作-结束...&quot;, Thread.currentThread().getName()));                return ThreadLocalRandom.current().nextInt(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();                return -1;            &#125;        &#125;);        System.out.println(String.format(&quot;【%s】在等待线程执行结果...&quot;, Thread.currentThread().getName()));        System.out.println(&quot;是否执行结束：&quot;+future.isDone());        System.out.println(future.get());        System.out.println(&quot;是否执行结束：&quot;+future.isDone());    &#125;&#125;
执行结果：
当前【pool-1-thread-1】线程工作-开始...【main】在等待线程执行结果...是否执行结束：false当前【pool-1-thread-1】线程工作-结束...76是否执行结束：true
1.2 Future的局限性&emsp;&emsp;虽然Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果。CompletableFuture的出现解决了Future模式的缺点。

不能手动完成：
当你写了一个函数，用于通过一个远程API获取一个电子商务产品最新价格。因为这个 API 太耗时，你把它允许在一个独立的线程中，并且从你的函数中返回一个 Future。现在假设这个API服务宕机了，这时你想通过该产品的最新缓存价格手工完成这个Future 。你会发现无法这样做。


Future的结果在非阻塞的情况下，不能执行更进一步的操作：
Future 不会通知你它已经完成了，它提供了一个阻塞的 get() 方法通知你结果。你无法给 Future 植入一个回调函数，当 Future 结果可用的时候，用该回调函数自动的调用 Future 的结果。


多个Future不能串联在一起组成链式调用：
有时候你需要执行一个长时间运行的计算任务，并且当计算任务完成的时候，你需要把它的计算结果发送给另外一个长时间运行的计算任务等等。你会发现你无法使用 Future 创建这样的一个工作流。  不能组合多个 Future 的结果  假设你有10个不同的Future，你想并行的运行，然后在它们运行未完成后运行一些函数。你会发现你也无法使用 Future 这样做。


没有异常处理：
Future API 没有任务的异常处理结构居然有如此多的限制，幸好我们有CompletableFuture，你可以使用 CompletableFuture 达到以上所有目的。



1.3 什么是CompletableFuture&emsp;&emsp; 在Java中CompletableFuture用于异步编程，异步编程是编写非阻塞的代码，运行的任务在一个单独的线程，与主线程隔离，并且会通知主线程它的进度，成功或者失败。在这种方式中，主线程不会被阻塞，不需要一直等到子线程完成。主线程可以并行的执行其他任务。使用这种并行方式，可以极大的提高程序的性能。&emsp;&emsp; CompletableFuture 实现了 Future 和 CompletionStage接口，并且提供了许多关于创建，链式调用和组合多个 Future 的便利方法集，而且有广泛的异常处理支持。&emsp;&emsp; CompletableFuture和Java8的Stream搭配使用，使用对于一些并行访问的耗时操作有很大的操作。
CompletableFuture继承结构关系图：
CompletableFuture类实现了CompletionStage和Future接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。
1.4 CompletableFuture方法分类1.4.1. 创建CompletableFuture对象&emsp;&emsp;以Async结尾并且没有指定Executor的方法会使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。runAsync方法也好理解，它以Runnable函数式接口类型为参数，所以CompletableFuture的计算结果为空。supplyAsync方法以Supplier&lt;U&gt;函数式接口类型为参数,CompletableFuture的计算结果类型为U。CompletableFuture的静态工厂方法：



方法名
描述



runAsync(Runnable runnable)
使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。


runAsync(Runnable runnable, Executor executor)
使用指定的thread pool执行异步代码。


supplyAsync(Supplier supplier)
使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值。


supplyAsync(Supplier supplier, Executor executor)
使用指定的thread pool执行异步代码，异步操作有返回值。



CompletableFuture.completedFuture是一个静态辅助方法，用来返回一个已经计算好的CompletableFuture。

/** * Returns a new CompletableFuture that is already completed with * the given value. * * @param value the value * @param &lt;U&gt; the type of the value * @return the completed CompletableFuture */public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value) &#123;    return new CompletableFuture&lt;U&gt;((value == null) ? NIL : value);&#125;


而以下四个静态方法用来为一段异步执行的代码创建CompletableFuture对象：

/** * Returns a new CompletableFuture that is asynchronously completed * by a task running in the &#123;@link ForkJoinPool#commonPool()&#125; with * the value obtained by calling the given Supplier. * * @param supplier a function returning the value to be used * to complete the returned CompletableFuture * @param &lt;U&gt; the function&#x27;s return type * @return the new CompletableFuture */public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) &#123;    return asyncSupplyStage(asyncPool, supplier);&#125;/** * Returns a new CompletableFuture that is asynchronously completed * by a task running in the given executor with the value obtained * by calling the given Supplier. * * @param supplier a function returning the value to be used * to complete the returned CompletableFuture * @param executor the executor to use for asynchronous execution * @param &lt;U&gt; the function&#x27;s return type * @return the new CompletableFuture */public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,Executor executor) &#123;    return asyncSupplyStage(screenExecutor(executor), supplier);&#125;/** * Returns a new CompletableFuture that is asynchronously completed * by a task running in the &#123;@link ForkJoinPool#commonPool()&#125; after * it runs the given action. * * @param runnable the action to run before completing the * returned CompletableFuture * @return the new CompletableFuture */public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) &#123;    return asyncRunStage(asyncPool, runnable);&#125;/** * Returns a new CompletableFuture that is asynchronously completed * by a task running in the given executor after it runs the given * action. * * @param runnable the action to run before completing the * returned CompletableFuture * @param executor the executor to use for asynchronous execution * @return the new CompletableFuture */public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,Executor executor) &#123;    return asyncRunStage(screenExecutor(executor), runnable);&#125;

1.4.2. 主动完成计算


方法名
描述



get()
方法同步等待结果。


get(timeout,unit)
get(timeout,unit)签名方法，给定时间，然后返回其结果，如果超时，抛出异常


join()
完成后返回结果值，如果完成异常，则返回（未检查）异常。


getNow()
如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.ThreadLocalRandom;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;public class CompletableFutureExample1 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        runAsync();        // get() 方法同步等待结果。        get();        // get(timeout,unit)签名方法，给定时间，然后返回其结果，如果超时，抛出异常        get(3,TimeUnit.SECONDS);        // join() 完成后返回结果值，如果完成异常，则返回（未检查）异常。        join();        // getNow() 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。        getNow();    &#125;    /**     * runAsync()异步执行runAsync返回的CompletableFuture是没有返回值的。     * supplyAsync()异步执行runAsync返回的CompletableFuture是有返回值的。     执行结果：     =====【main】执行runAsync()签名方法-开始=====     Hello world！！！     =====【main】执行runAsync()签名方法-结束=====     * @throws ExecutionException     * @throws InterruptedException     */    private static void runAsync() throws ExecutionException, InterruptedException &#123;        System.out.println(String.format(&quot;=====【%s】执行runAsync()签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Hello world！！！&quot;)).get();        System.out.println(String.format(&quot;=====【%s】执行runAsync()签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**     get() 方法同步等待结果。     执行结果：          =====【main】执行get()签名方法-开始=====          get()签名方法，执行结果：4          =====【main】执行get()签名方法-结束=====     * @throws ExecutionException     * @throws InterruptedException     */    private static void get() throws ExecutionException, InterruptedException &#123;        System.out.println(String.format(&quot;=====【%s】执行get()签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            return ThreadLocalRandom.current().nextInt(10) * 2;        &#125;);        /** get() 方法同步等待结果。 **/        System.out.println(&quot;get()签名方法，执行结果：&quot;+completableFuture.get());        System.out.println(String.format(&quot;=====【%s】执行get()签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**     get(timeout,unit)签名方法，给定时间，然后返回其结果，如果超时，抛出异常     执行结果：     =====【main】执行get(timeout,unit)签名方法-开始=====     java.util.concurrent.TimeoutException     	at java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1771)     	at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1915)     	at com.yuanxw.chapter24.CompletableFutureExample.get(CompletableFutureExample.java:53)     	at com.yuanxw.chapter24.CompletableFutureExample.main(CompletableFutureExample.java:11)     =====【main】执行get(timeout,unit)签名方法-结束=====     *     * @param timeout     * @param unit     * @throws ExecutionException     * @throws InterruptedException     */    private static void get(long timeout, TimeUnit unit) throws ExecutionException, InterruptedException &#123;        System.out.println(String.format(&quot;=====【%s】执行get(timeout,unit)签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            return ThreadLocalRandom.current().nextInt(10) * 2;        &#125;);        try &#123;            System.out.println(&quot;get(timeout,unit)签名方法，执行结果：&quot;+completableFuture.get(timeout,unit));        &#125; catch (TimeoutException e) &#123;            e.printStackTrace();        &#125;        System.out.println(String.format(&quot;=====【%s】执行get(timeout,unit)签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**      join() 完成后返回结果值，如果完成异常，则返回（未检查）异常。     执行结果：         =====【main】执行join()签名方法-开始=====         join()签名方法，执行结果：40         =====【main】执行join()签名方法-结束=====     * @throws ExecutionException     * @throws InterruptedException     */    private static void join() throws ExecutionException, InterruptedException &#123;        System.out.println(String.format(&quot;=====【%s】执行join()签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            return ThreadLocalRandom.current().nextInt(10) * 5;        &#125;);        /** join() 完成后返回结果值，如果完成异常，则返回（未检查）异常。 **/        System.out.println(&quot;join()签名方法，执行结果：&quot;+ completableFuture.join());        System.out.println(String.format(&quot;=====【%s】执行join()签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**     getNow() 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。     执行结果：      =====【main】执行getNow()签名方法-开始=====      getNow()签名方法，执行结果：===unknown===      getNow()签名方法，执行结果：N      =====【main】getNow()签名方法-结束=====     */    private static void getNow() &#123;        System.out.println(String.format(&quot;=====【%s】执行getNow()签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            // 生成随机字符            char c = (char) (ThreadLocalRandom.current().nextInt(25 )+ 65);            return String.valueOf(c);        &#125;);        /** getNow() 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。 **/        System.out.println(&quot;getNow()签名方法，执行结果：&quot;+ completableFuture.getNow(&quot;===unknown===&quot;));        processSleep(6);        System.out.println(&quot;getNow()签名方法，执行结果：&quot;+ completableFuture.getNow(&quot;===unknown===&quot;));        System.out.println(String.format(&quot;=====【%s】getNow()签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

1.4.3. 计算结果完成时的处理 &emsp;&emsp; 当CompletableFuture计算结果完成时,我们需要对结果进行处理，或者当CompletableFuture产生异常的时候需要对异常进行处理。有如下几种方法:



方法名
描述



whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action)
当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。


whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action)
当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用ForkJoinPool。


BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor)
当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用指定的线程池。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.TimeUnit;public class CompletableFutureExample2 &#123;    public static void main(String[] args) throws InterruptedException &#123;        whenComplete();        Thread.currentThread().join();    &#125;    /**     * runAsync()异步执行runAsync返回的CompletableFuture是没有返回值的。     * supplyAsync()异步执行runAsync返回的CompletableFuture是有返回值的。     执行结果：     =====【main】执行runAsync()签名方法-开始=====     Hello world！！！     =====【main】执行runAsync()签名方法-结束=====     */    /**     * whenComplete()：当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。     执行结果：         =====执行whenComplete()签名方法-开始=====         执行supplyAsync()签名方法-结束&gt;&gt;&gt;&gt;&gt;         统计字符串长度：14         =====执行whenComplete()签名方法-结束=====     */    private static void whenComplete()  &#123;        System.out.println(&quot;=====执行whenComplete()签名方法-开始=====&quot;);        CompletableFuture.supplyAsync(() -&gt;&#123;            // 睡眠5秒            processSleep(5);            System.out.println(&quot;执行supplyAsync()签名方法-结束&gt;&gt;&gt;&gt;&gt;&quot;);            return &quot;Hello world！！！&quot;;        &#125;).whenComplete((s, throwable) -&gt; &#123;            System.out.println(&quot;统计字符串长度：&quot;+s.length());            System.out.println(&quot;=====执行whenComplete()签名方法-结束=====&quot;);        &#125;);    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;


1.4.4. 计算结果完成时的转换 &emsp;&emsp; 这里同样也是返回CompletableFuture，但是这个结果会由我们自定义返回去转换他，同样的不以Async结尾的方法由原来的线程计算，以Async结尾的方法由默认的线程池ForkJoinPool.commonPool()或者指定的线程池executor运行。



方法名
描述



public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)
接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture。


public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)
接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用ForkJoinPool。


public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)
接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用指定的线程池。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.ThreadLocalRandom;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;public class CompletableFutureExample3 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        thenApply();    &#125;    /**     thenApply() 当原来的CompletableFuture计算完后，将结果传递给函数fn，将fn的结果作为新的CompletableFuture计算结果。     因此它的功能相当于将CompletableFuture&lt;T&gt;转换成CompletableFuture&lt;U&gt;。。     执行结果：         =====执行thenApply()签名方法-开始=====         thenApply()签名方法，在supplyAsync阶段，执行结果：DFRHHQ         thenApply()签名方法，执行结果：###【dfrhhq】###         =====thenApply()签名方法-结束=====     */    private static void thenApply() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====执行thenApply()签名方法-开始=====&quot;);        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            StringBuffer buffer = new StringBuffer();            IntStream.range(0,6).boxed().forEach(integer -&gt; &#123;                // 生成随机字符                char c = (char) (ThreadLocalRandom.current().nextInt(25 )+ 65);                buffer.append(c);            &#125;);            System.out.println(&quot;thenApply()签名方法，在supplyAsync阶段，执行结果：&quot; + buffer.toString());            return buffer.toString();        &#125;).thenApply(str -&gt; String.format(&quot;###【%s】###&quot;, str.toLowerCase()));        System.out.println(&quot;thenApply()签名方法，执行结果：&quot;+ completableFuture.get());        System.out.println(&quot;=====thenApply()签名方法-结束=====&quot;);    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

1.4.5. 计算结果完成时的消费 &emsp;&emsp; 这里还会有一个只会对计算结果消费不会返回任何结果的方法。同样的不以Async结尾的方法由原来的线程计算，以Async结尾的方法由默认的线程池ForkJoinPool.commonPool()或者指定的线程池executor运行。



方法名
描述



public CompletableFuture thenAccept(Consumer&lt;? super T&gt; action)
当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值。


public CompletableFuture thenAcceptAsync(Consumer&lt;? super T&gt; action)
当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值，使用ForkJoinPool。


public CompletableFuture thenAcceptAsync(Consumer&lt;? super T&gt; action,Executor executor)
当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.ThreadLocalRandom;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;public class CompletableFutureExample4 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        thenAccept();    &#125;    /**     thenAccept() CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值。     执行结果：     =====执行thenAccept()签名方法-开始=====     系统自动生成的6位验证码：EHSRHT，该验证码5分钟有效，请勿泄露给他人。     =====thenAccept()签名方法-结束=====     */    private static void thenAccept() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====执行thenAccept()签名方法-开始=====&quot;);        CompletableFuture                .supplyAsync(() -&gt; &quot;系统自动生成的6位验证码：&quot;)                .thenApply((str) -&gt; str + verifiCode())                .thenApply((str) -&gt; str + &quot;，该验证码5分钟有效，请勿泄露给他人。&quot;)                .thenAccept(System.out::println);        System.out.println(&quot;=====thenAccept()签名方法-结束=====&quot;);    &#125;    /**     * 生成6位数验证码     * @return     */    private static String verifiCode()&#123;        StringBuffer buffer = new StringBuffer();        IntStream.range(0,6).boxed().forEach(integer -&gt; &#123;            // 生成随机字符            char c = (char) (ThreadLocalRandom.current().nextInt(25 )+ 65);            buffer.append(c);        &#125;);        return buffer.toString();    &#125;&#125;
1.4.6. 计算结果完成时的消费合并结果 &emsp;&emsp; thenAcceptBoth以及相关方法提供了类似的功能，当两个CompletionStage都正常完成计算的时候，就会执行提供的action，它用来组合另外一个异步的结果。
&emsp;&emsp; runAfterBoth是当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。



方法名
描述



public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action)
当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。


public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action)
当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。


public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action, Executor executor)
当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。


public CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other,Runnable action)
当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。


public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action)
当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。使用ForkJoinPool。


public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)
当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。使用指定的线程池。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.TimeUnit;public class CompletableFutureExample5 &#123;    public static void main(String[] args) throws InterruptedException &#123;        thenAcceptBoth();        runAfterBoth();        Thread.currentThread().join();    &#125;    /**     thenAcceptBoth() 当你想要使用两个Future结果时，但不需要将任何结果值进行返回时，     可以用 thenAcceptBoth ，它表示后续的处理不需要返回值。     执行结果：         =====执行thenAcceptBoth()签名方法-开始=====         Hello World         =====thenAcceptBoth()签名方法-结束=====     */    private static void thenAcceptBoth() &#123;        System.out.println(&quot;=====执行thenAcceptBoth()签名方法-开始=====&quot;);        CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;)                .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &quot; World&quot;),                        (s1, s2) -&gt; System.out.println(s1 + s2));        System.out.println(&quot;=====thenAcceptBoth()签名方法-结束=====&quot;);    &#125;    /**     * runAfterBoth是当两个CompletionStage都正常完成计算的时候,     执行一个Runnable，这个Runnable并不使用计算的结果。     执行结果：          =====执行runAfterBoth()签名方法-开始=====          ForkJoinPool.commonPool-worker-1线程，工作-开始&gt;&gt;          ForkJoinPool.commonPool-worker-2线程，工作-开始&gt;&gt;          =====runAfterBoth()签名方法-结束=====          ForkJoinPool.commonPool-worker-2线程，工作-结束&lt;&lt;          ForkJoinPool.commonPool-worker-1线程，工作-结束&lt;&lt;          ===执行任务结束===     */    private static void runAfterBoth() &#123;        System.out.println(&quot;=====执行runAfterBoth()签名方法-开始=====&quot;);        CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-开始&gt;&gt;&quot;);            // 睡眠5秒            processSleep(5);            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-结束&lt;&lt;&quot;);            return 1;        &#125;).runAfterBoth(CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-开始&gt;&gt;&quot;);            // 睡眠1秒            processSleep(1);            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-结束&lt;&lt;&quot;);            return 2;        &#125;), () -&gt; System.out.println(&quot;===执行任务结束===&quot;));        System.out.println(&quot;=====runAfterBoth()签名方法-结束=====&quot;);    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;


1.4.7. 对计算结果的组合 &emsp;&emsp; 对于Compose可以连接两个CompletableFuture，其内部处理逻辑是当第一个CompletableFuture处理没有完成时会合并成一个CompletableFuture,如果处理完成，第二个future会紧接上一个CompletableFuture进行处理。



方法名
描述



public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn)
当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。


public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn)
当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。


public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)
当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;public class CompletableFutureExample6 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        thenCombine();    &#125;    /**     * 执行thenCombine()对于Compose可以连接两个CompletableFuture，     * 其内部处理逻辑是当第一个CompletableFuture处理没有完成时会合并成一个CompletableFuture,     * 如果处理完成，第二个future会紧接上一个CompletableFuture进行处理。      执行结果：         =====执行thenCombine()签名方法-开始=====         thenCombine()签名方法，执行结果：计算结果：30         =====thenCombine()签名方法-结束=====     */    private static void thenCombine() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====执行thenCombine()签名方法-开始=====&quot;);        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; 10);        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; 20);        CompletableFuture&lt;String&gt; completableFuture = future1.thenCombine(future2, (x, y) -&gt; &quot;计算结果：&quot; + (x + y));        System.out.println(&quot;thenCombine()签名方法，执行结果：&quot;+ completableFuture.get());        System.out.println(&quot;=====thenCombine()签名方法-结束=====&quot;);    &#125;&#125;

1.4.8. 对计算结果的异常处理 &emsp;&emsp; 当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。&emsp;&emsp; exceptionally() 方法将导致CompletableFuture 内发生问题的异常抛出。



方法名
描述



public  CompletableFuture handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)
当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。


public  CompletableFuture handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)
当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。使用ForkJoinPool。


public  CompletableFuture handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)
当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。使用指定的线程池。


public CompletableFuture exceptionally(Function&lt;Throwable, ? extends T&gt; fn)
exceptionally() 方法将导致CompletableFuture 内发生问题的异常抛出。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;public class CompletableFutureExample7 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        handle();        exceptionally();    &#125;    /**     handle() 当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。     执行结果：         =====handle()签名方法-开始=====         handle()签名方法，在supplyAsync阶段，执行1/0结果。         handle()签名方法，执行结果：-1         =====handle()签名方法-结束=====         java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero         at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273)         at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280)         at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1592)         at java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1582)         at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)         at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)         at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)         at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)         Caused by: java.lang.ArithmeticException: / by zero         at com.yuanxw.chapter24.CompletableFutureExample7.lambda$handle$0(CompletableFutureExample3.java:26)         at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1590)         ... 5 more     */    private static void handle() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====handle()签名方法-开始=====&quot;);        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(&quot;handle()签名方法，在supplyAsync阶段，执行1/0结果。&quot;);            return 1/0;        &#125;).handle((integer, throwable) -&gt; &#123;            if(throwable != null)&#123;                throwable.printStackTrace();                return -1;            &#125;           return integer;        &#125;);        System.out.println(&quot;handle()签名方法，执行结果：&quot;+ completableFuture.get());        System.out.println(&quot;=====handle()签名方法-结束=====&quot;);    &#125;    /**     * exceptionally() 方法将导致CompletableFuture 内发生问题的异常抛出。     * 这样，当执行任务发生异常时，调用get()方法的线程将会收到一个 ExecutionException 异常，     * 该异常接收了一个包含失败原因的Exception 参数。     * 执行结果：         =====exceptionally()签名方法-开始=====         exceptionally()签名方法，在supplyAsync阶段，执行1/0结果。         exceptionally()签名方法，执行结果：java.lang.ArrayIndexOutOfBoundsException: 1         =====exceptionally()签名方法-结束=====     * @throws ExecutionException     * @throws InterruptedException     */    private static void exceptionally() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====exceptionally()签名方法-开始=====&quot;);        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(&quot;exceptionally()签名方法，在supplyAsync阶段，执行1/0结果。&quot;);            String [] array = new String[]&#123;&#125;;            // 此处异常：java.lang.ArrayIndexOutOfBoundsException: 1            return array[1];        &#125;).exceptionally(ex -&gt; ex.getMessage());        System.out.println(&quot;exceptionally()签名方法，执行结果：&quot;+ completableFuture.get());        System.out.println(&quot;=====exceptionally()签名方法-结束=====&quot;);    &#125;&#125;
1.4.9. 其它方法 &emsp;&emsp;allOf方法是当所有的CompletableFuture都执行完后执行计算。anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。



方法名
描述



public static CompletableFuture allOf(CompletableFuture&lt;?&gt;… cfs)
allOf方法是当所有的CompletableFuture都执行完后执行计算。


public static CompletableFuture anyOf(CompletableFuture&lt;?&gt;… cfs)
anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeUnit;public class CompletableFutureExample8 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        anyAndAllOfCompletableFuture();    &#125;    /**     allOf方法是当所有的CompletableFuture都执行完后执行计算。     anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。     执行结果：         =====anyAndAllOfCompletableFuture()签名方法-开始=====         ForkJoinPool.commonPool-worker-1线程，工作-开始&gt;&gt;         ForkJoinPool.commonPool-worker-2线程，工作-开始&gt;&gt;         ForkJoinPool.commonPool-worker-2线程，工作-结束&lt;&lt;         anyOf()签名方法，执行结果：result-2         ForkJoinPool.commonPool-worker-1线程，工作-结束&lt;&lt;         =====anyAndAllOfCompletableFuture()签名方法-结束=====     */    private static void anyAndAllOfCompletableFuture() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====anyAndAllOfCompletableFuture()签名方法-开始=====&quot;);        CompletableFuture&lt;String&gt; completableFuture1=CompletableFuture.supplyAsync(()-&gt;&#123;            //模拟执行耗时任务            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-开始&gt;&gt;&quot;);            // 睡眠5秒            processSleep(5);            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-结束&lt;&lt;&quot;);            //返回结果            return &quot;result-1&quot;;        &#125;);        CompletableFuture&lt;String&gt; completableFuture2=CompletableFuture.supplyAsync(()-&gt;&#123;            //模拟执行耗时任务            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-开始&gt;&gt;&quot;);            // 睡眠5秒            processSleep(1);            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-结束&lt;&lt;&quot;);            //返回结果            return &quot;result-2&quot;;        &#125;);        CompletableFuture&lt;Object&gt; anyOfCompletableFuture = CompletableFuture.anyOf(completableFuture1,completableFuture2);        System.out.println(&quot;anyOf()签名方法，执行结果：&quot;+ anyOfCompletableFuture.get());        CompletableFuture&lt;Void&gt; allOfCompletableFuture = CompletableFuture.allOf(completableFuture1,completableFuture2);        // 阻塞等待所有任务执行完成        allOfCompletableFuture.join();        System.out.println(&quot;=====anyAndAllOfCompletableFuture()签名方法-结束=====&quot;);    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十四)Java多线程之CompletableFuture类》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(五)Java多线程之interrupted线程中断</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%94)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Binterrupted%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[1.JAVA多线程(五)Java多线程之interrupted线程中断1.1 interrupted(线程中断)&emsp;&emsp;一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。
package com.yuanxw.chapter5;/** * 中断线程 */public class InterruptThread &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread() &#123;            @Override            public void run() &#123;                try &#123;                    while (true) &#123;                        sleep(500);                        System.out.println(Thread.currentThread().getName() + &quot;正在运行...&quot;);                    &#125;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                    System.out.println(Thread.currentThread().getName() + &quot;线程被打断了...&quot;);                &#125;            &#125;        &#125;;        thread.start();        /** main线程休息2秒 **/        Thread.sleep(2000);        System.out.println(String.format(&quot;【%s】线程是否中断：%s&quot;, thread.getName(),thread.isInterrupted()));        /** 中断线程操作 **/        thread.interrupt();        System.out.println(String.format(&quot;【%s】线程是否中断：%s&quot;, thread.getName(),thread.isInterrupted()));    &#125;&#125;
执行结果：
Thread-0正在运行...Thread-0正在运行...Thread-0正在运行...Thread-0正在运行...【Thread-0】线程是否中断：false【Thread-0】线程是否中断：trueThread-0线程被打断了...java.lang.InterruptedException: sleep interrupted	at java.lang.Thread.sleep(Native Method)	at com.yuanxw.chapter3.InterruptThread$1.run(InterruptThread.java:13) 

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(五)Java多线程之interrupted线程中断》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(八)Java多线程之死锁</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%85%AB)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[1.JAVA多线程(八)Java多线程之死锁1.1什么是线程死锁?如何避免死锁?&emsp;&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。
如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。
![在这里插入图片描述](&#x2F;images&#x2F;java_multithreading&#x2F;chapter8&#x2F;20191230105715913.png
下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：
package com.yuanxw.chapter8;/** * 死锁 */public class DeadLockDemo &#123;    private static Object resource1 = new Object();//资源 1    private static Object resource2 = new Object();//资源 2    public static void main(String[] args) &#123;        new Thread(() -&gt; &#123;            synchronized (resource1) &#123;                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);                synchronized (resource2) &#123;                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                &#125;            &#125;        &#125;, &quot;线程A&quot;).start();        new Thread(() -&gt; &#123;            synchronized (resource2) &#123;                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);                synchronized (resource1) &#123;                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                &#125;            &#125;        &#125;, &quot;线程B&quot;).start();    &#125;&#125;
执行结果
Thread[线程A,5,main]get resource1Thread[线程B,5,main]get resource2Thread[线程B,5,main]waiting get resource1Thread[线程A,5,main]waiting get resource2

线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。
学过操作系统的朋友都知道产生死锁必须具备以下四个条件：

互斥条件：该资源任意一个时刻只由一个线程占用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

1.2通过命令检查死锁
 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(八)Java多线程之死锁》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(六)Java多线程之ThreadGroup</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%85%AD)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadGroup/</url>
    <content><![CDATA[1.JAVA多线程(六)Java多线程之ThreadGroup1.1 ThreadGroup&emsp;&emsp;ThreadGroup是Java提供的一种对线程进行分组管理的手段，可以对所有线程以组为单位进行操作，如设置优先级、守护线程等。
&emsp;&emsp;在Java程序中，默认情况下，新的线程都会加入到 main 线程所在的 group 中， main 线程的 group 和线程同名。和线程存在父子关系一样， ThreadGroup 也存在父子关系

package com.yuanxw.chapter6;import java.util.Arrays;public class ThreadGroupService &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread(&quot;thread-0&quot;)&#123;            @Override            public void run() &#123;                try &#123;                    // 睡眠100L                    sleep(100L);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;;        thread.start();        // 获得当前线程的名称        System.out.println(&quot;获得当前线程的名称：&quot;+Thread.currentThread().getName());        // 获得当前线程的线程线名称        System.out.println(&quot;获得当前线程的线程线名称：&quot;+Thread.currentThread().getThreadGroup().getName());        // 获得thread-0线程的线程线名称        System.out.println(&quot;获得&quot;+thread.getName()+&quot;线程的线程线名称：&quot;+thread.getThreadGroup().getName());        // 創建线程组        ThreadGroup syncDbGroup = new ThreadGroup(&quot;SYNC_DB_GROUP&quot;);        Arrays.asList(&quot;thread-A&quot;,&quot;thread-B&quot;,&quot;thread-C&quot;,&quot;thread-D&quot;).forEach(name -&gt;&#123;            Thread t = new Thread(syncDbGroup, () -&gt; &#123;                while (true) &#123;&#125;            &#125;, name);            t.setDaemon(true);            t.start();        &#125;);        ThreadGroup syncErpDbGroup = new ThreadGroup(syncDbGroup,&quot;SYNC_ERP_DB_GROUP&quot;);        ThreadGroup syncOADbGroup = new ThreadGroup(syncDbGroup,&quot;SYNC_OA_DB_GROUP&quot;);        Arrays.asList(&quot;thread-1&quot;,&quot;thread-2&quot;).forEach(name -&gt;&#123;            Thread t = new Thread(syncErpDbGroup, () -&gt; &#123;                while (true) &#123;&#125;            &#125;, name);            t.setDaemon(true);            t.start();        &#125;);        System.out.println(&quot;返回此线程组及其子组中活动线程数的估计：&quot;+syncDbGroup.activeCount());        System.out.println(&quot;返回此线程组及其子组中活动组数的估计：&quot;+syncDbGroup.activeGroupCount());        // 设置线程组为后台线程组----最后一个线程执行结束或者被销毁后,该后台线程组自动销毁        syncDbGroup.setDaemon(true);        // interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。        syncErpDbGroup.interrupt();    &#125;&#125;
执行结果：
获得当前线程的名称：main获得当前线程的线程线名称：main获得thread-0线程的线程线名称：main返回此线程组及其子组中活动线程数的估计：6返回此线程组及其子组中活动组数的估计：2


 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(六)Java多线程之ThreadGroup》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十)Java多线程之ThreadLocal</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/</url>
    <content><![CDATA[1.JAVA多线程(十)Java多线程之ThreadLocal1.1 ThreadLocal类&emsp;&emsp;  ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get()和 set())方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。
每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的，由于不需要共享信息，自然就不存在竞争问题了，从而保证了某些情况下线程的安全，以及避免了某些情况需要考虑线程安全必须同步带来的性能损失！
1.2 ThreadLocal示例package com.yuanxw.chapter10;import java.util.Random;/** * ThreadLocal * 线程局部变量 */public class ThreadLocalExample &#123;    private static ThreadLocal&lt;String&gt; defaultThreadLocal = new ThreadLocal()&#123;        @Override        protected Object initialValue() &#123;            return &quot;==initialValue==&quot;;        &#125;    &#125;;    private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal();    public static void main(String[] args) throws InterruptedException &#123;        System.out.println(&quot;获得defaultThreadLocal默认值：&quot;+defaultThreadLocal.get());        // 线程-A        Thread thread1 = new Thread(() -&gt; &#123;            // 设置【threadLocal】对象值为：张三            threadLocal.set(&quot;张三&quot;);            try &#123;                Thread.sleep(new Random().nextInt(1000));            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(String.format(&quot;【%s】线程-执行threadLocal值：【%s】&quot;, Thread.currentThread().getName(),threadLocal.get()));        &#125;, &quot;Thread-A&quot;);        // 线程-B        Thread thread2 = new Thread(() -&gt; &#123;            // 设置【threadLocal】对象值为：李四            threadLocal.set(&quot;李四&quot;);            try &#123;                Thread.sleep(new Random().nextInt(1000));            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(String.format(&quot;【%s】线程-执行threadLocal值：【%s】&quot;, Thread.currentThread().getName(),threadLocal.get()));        &#125;, &quot;Thread-B&quot;);        thread1.join();        thread2.join();        thread1.start();        thread2.start();        Thread.sleep(new Random().nextInt(1000));        System.out.println(String.format(&quot;【%s】线程-执行threadLocal值：【%s】&quot;, Thread.currentThread().getName(),threadLocal.get()));    &#125;&#125;
执行结果：
获得defaultThreadLocal默认值：==initialValue==【Thread-B】线程-执行threadLocal值：【李四】【Thread-A】线程-执行threadLocal值：【张三】【main】线程-执行threadLocal值：【null】
1.3 ThreadLocal对应的底层结构图
每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中，get() 方法类似。
/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;/** * Returns the value in the current thread&#x27;s copy of this * thread-local variable.  If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread&#x27;s value of this thread-local */public T get() &#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) &#123;        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) &#123;            @SuppressWarnings(&quot;unchecked&quot;)            T result = (T)e.value;            return result;        &#125;    &#125;    return setInitialValue();&#125;/** * Sets the current thread&#x27;s copy of this thread-local variable * to the specified value.  Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread&#x27;s copy of *        this thread-local. */public void set(T value) &#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);&#125;

1.3 ThreadLocal 内存泄露问题在一些场景 (尤其是使用线程池) 下，ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法。
 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十)Java多线程之ThreadLocal》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十一)Java多线程之自定义线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B8%80)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA多线程(十一)Java多线程之自定义线程池1.1 什么是用线程池&emsp;&emsp; 线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。
1.2 为什么要用线程池&emsp;&emsp;池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。
这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处：

降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

1.3 如何自定义线程池&emsp;&emsp;自定义简单的线程池，线程池大小，任务队列大小，拒绝策略等，下面的代码简单实现线程池。

定义任务状态

package com.yuanxw.chapter11;/** * 任务状态 */public enum TaskState &#123;        /**         * 空闲         **/        FREE,        /**         * 运行中         **/        RUNNING,        /**         * 阻塞         **/        BLOCKED,        /**         * 死亡         **/        DEAD;&#125;


自定义异常

package com.yuanxw.chapter11;/** * 自定义异常 */public class DiscardException extends RuntimeException&#123;    public DiscardException(String message) &#123;        super(message);    &#125;&#125;


定义拒绝策略接口

package com.yuanxw.chapter11;/** * 拒绝策略 */public interface DiscardPolicy &#123;    /** 定义拒绝策略 **/    void discard() throws DiscardException;&#125;


定义拒绝策略接口实现

package com.yuanxw.chapter11;/** * 默认：拒绝策略 */public class DefaultDiscardPolicyImpl implements DiscardPolicy&#123;    @Override    public void discard() throws DiscardException &#123;        throw new DiscardException(&quot;该任务已经被拒绝！&quot;);    &#125;&#125;


线程池实现方法

package com.yuanxw.chapter11;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;/** * 自定义简单的线程池 */public class SimpleThreadPool &#123;    /**     * 线程池大小     **/    private final int size;    /**     * 任务队列大小     **/    private final int taskQueueSize;    /**     * 默认线程池大小为：5     **/    private final static int DEFAULT_SIZE = 5;    /**     * 默认任务队列大小：2000     **/    private final static int DEFAULT_TASK_QUEUE_SIZE = 2000;    /**     * 线程序号     */    private static volatile int seq = 0;    /**     * 线程前缀     **/    private final static String THREAD_PREFIX = &quot;SIMPLE-THREAD-POOL-&quot;;    /**     * 定义线程程     **/    private final static ThreadGroup GROUP = new ThreadGroup(&quot;POOL_GROUP&quot;);    /**     * 定线程队列     **/    private final static List&lt;WorkerTask&gt; THREAD_QUEUE = new ArrayList&lt;&gt;();    /**     * 任务队列     */    private static LinkedList&lt;Runnable&gt; TASK_QUEUE = new LinkedList&lt;&gt;();    /**     * 默认策略     **/    public static final DiscardPolicy DEFAULT_DISCARD_POLICY = new DefaultDiscardPolicyImpl();    /** 定义策略变量 **/    private final DiscardPolicy discardPolicy;    /** 是否已经销毁 **/    private volatile boolean destroy = false;    public SimpleThreadPool() &#123;        this(DEFAULT_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);    &#125;    public SimpleThreadPool(int size, int taskQueueSize, DiscardPolicy discardPolicy) &#123;        this.size = size;        this.taskQueueSize = taskQueueSize;        this.discardPolicy = discardPolicy;        init();    &#125;    /**     * 初始化方法     */    private void init() &#123;        // 创建size线程        for (int i = 0; i &lt; size; i++) &#123;            createWorkTask();        &#125;    &#125;    /**     * 创建线程函数     */    private void createWorkTask() &#123;        /** 创建线程 **/        WorkerTask task = new WorkerTask(GROUP, THREAD_PREFIX + (seq++));        /** 启动线程 **/        task.start();        /** 线程添加到组中 **/        THREAD_QUEUE.add(task);    &#125;    /**     * 任务提交     * @param runnable     */    public void submit(Runnable runnable) &#123;        if(destroy)&#123;            throw new IllegalStateException(&quot;线程池已经销毁不能再提交新的任务...&quot;);        &#125;        synchronized (TASK_QUEUE) &#123;            // 队列长度大于指定队列长度，执行策略            if (TASK_QUEUE.size() &gt; taskQueueSize) &#123;                discardPolicy.discard();            &#125;            // 从后面添加新任务            TASK_QUEUE.addLast(runnable);            // 通知唤醒线程            TASK_QUEUE.notifyAll();        &#125;    &#125;    /**     * 停止线程池运行     */    public void shutdonw() throws InterruptedException &#123;        // 如果线程队列中还有在执行的结程，那执行停止的方法需要等待。等待到所有线程都执行完成。        while (!TASK_QUEUE.isEmpty()) &#123;            Thread.sleep(50);        &#125;        int initVal = THREAD_QUEUE.size();        while (initVal &gt; 0) &#123;            for (WorkerTask workerTask : THREAD_QUEUE) &#123;                if (workerTask.getTaskState() == TaskState.BLOCKED) &#123;                    // 打断线程                    workerTask.interrupt();                    // 修改线程状态为结束状态                    workerTask.close();                    initVal--;                &#125; else &#123;                    Thread.sleep(10);                &#125;            &#125;        &#125;        this.destroy = true;        System.out.println(&quot;线程已经运行结束...&quot;);    &#125;    private static class WorkerTask extends Thread &#123;        /**         * 默认线程的状态是空闲的         **/        private volatile TaskState taskState = TaskState.FREE;        /**         * 设置线程组         **/        public WorkerTask(ThreadGroup group, String name) &#123;            super(group, name);        &#125;        @Override        public void run() &#123;            OUTTER:            // 状态不是DEAD状态，一直处理线程            while (this.taskState != TaskState.DEAD) &#123;                Runnable runnable;                synchronized (TASK_QUEUE) &#123;                    // 程线池中一直是空的，一直等待                    while (TASK_QUEUE.isEmpty()) &#123;                        try &#123;                            this.taskState = TaskState.BLOCKED;                            TASK_QUEUE.wait();                        &#125; catch (InterruptedException e) &#123;                            // e.printStackTrace();                            break OUTTER;                        &#125;                    &#125;                    // 从此列表中删除并返回第一个元素。                    runnable = TASK_QUEUE.removeFirst();                &#125;                if (runnable != null) &#123;                    // 设置线程状态，运行中                    taskState = TaskState.RUNNING;                    // run函数                    runnable.run();                    // 设置线程状态，空闲                    taskState = TaskState.FREE;                &#125;            &#125;        &#125;        /**         * 获得线程状态         *         * @return         */        public TaskState getTaskState() &#123;            return this.taskState;        &#125;        /**         * 结束线程状态         */        public void close() &#123;            this.taskState = TaskState.DEAD;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        SimpleThreadPool simpleThreadPool = new SimpleThreadPool();        // 拒绝策略        // SimpleThreadPool simpleThreadPool = new SimpleThreadPool(6, 10, DEFAULT_DISCARD_POLICY);        for (int i = 0; i &lt; 50; i++) &#123;            simpleThreadPool.submit(new Runnable() &#123;                @Override                public void run() &#123;                    System.out.println(String.format(&quot;线程【%s】，已经开始&gt;&gt;运行&quot;, Thread.currentThread()));                    try &#123;                        Thread.sleep(1000L);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(String.format(&quot;线程【%s】，已经&lt;&lt;结束&quot;, Thread.currentThread()));                &#125;            &#125;);        &#125;        Thread.sleep(1000L);        simpleThreadPool.shutdonw();    &#125;&#125;
执行结果：
线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程已经运行结束...



 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十一)Java多线程之自定义线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十七)Java多线程之ForkJoin框架</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B8%83)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BForkJoin%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[1.JAVA多线程(十七)Java多线程之ForkJoin框架1.1 什么是ForkJoin框架？&emsp;&emsp; Fork&#x2F;Join 框架，可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。通过这种方式，Fork&#x2F;Join 能试着去使用所有可用的处理器，以达到加速处理多线程的目的。本文中对Fork&#x2F;Join框架的讲解，基于JDK1.8+中的Fork&#x2F;Join框架实现。

Fork&#x2F;Join框架要完成两件事情：

任务分割：&emsp;&emsp; 首先Fork&#x2F;Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割。

执行任务并合并结果：&emsp;&emsp; 分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。

ForkJoinTask类：&emsp;&emsp;使用Fork&#x2F;Join框架，首先需要创建一个ForkJoin任务。该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集成ForkJoinTask类，只需要继承它的子类，Fork&#x2F;Join框架提供了两个子类:&emsp;&emsp;RecursiveTask： 用于有返回结果的任务&emsp;&emsp;RecursiveAction：用于没有返回结果的任务



1.2 RecursiveTask使用样例使用CalculatorRecursiveTask extends RecursiveTask完成1到10000累加的需求，代码如下：
package com.yuanxw.chapter17;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;import java.util.stream.IntStream;/** * 使用CalculatorRecursiveTask extends RecursiveTask完成1到10000累加的需求 */public class ForkJoinRecursiveTask &#123;    // 阈值    private final static int THRESHOLD = 200;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        // 计算1-50累加值        CalculatorRecursiveTask calculatorRecursiveTask = new CalculatorRecursiveTask(1,10000);        ForkJoinPool forkJoinPool = new ForkJoinPool();        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(calculatorRecursiveTask);        System.out.println(&quot;计算结果：&quot;+forkJoinTask.get());    &#125;    /**     * 有返回值ForkJoin任务     */    private static class CalculatorRecursiveTask extends RecursiveTask&lt;Integer&gt; &#123;        // 开始计算机位置        public int first;        // 结束计算机位置        private int last;        /**         * 构造函数         *         * @param first         * @param last         */        public CalculatorRecursiveTask(int first, int last) &#123;            this.first = first;            this.last = last;        &#125;        @Override        protected Integer compute() &#123;            if (last - first &lt;= THRESHOLD) &#123;                /**                 * 任务足够小则直接计算                 * 使用lambda表达式简化如下代码                 * &lt;pre&gt;                 * for (int i = first; i &lt;= last; i++) &#123;                 *     result += i;                 * &#125;                 * &lt;/pre&gt;                 */                return IntStream.rangeClosed(first, last).sum();            &#125; else &#123;                // 获得中间值，向上取整                int middle = (first + last) / 2;                CalculatorRecursiveTask leftTask = new CalculatorRecursiveTask(first, middle);                CalculatorRecursiveTask rightTask = new CalculatorRecursiveTask(middle + 1, last);                leftTask.fork();                rightTask.fork();                return leftTask.join() + rightTask.join();            &#125;        &#125;    &#125;&#125;
执行结果：
计算结果：50005000

1.3 ForkJoinPool线程池&emsp;&emsp;ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。
public class ForkJoinPool extends AbstractExecutorService &#123;    /**     * Creates a &#123;@code ForkJoinPool&#125; with parallelism equal to &#123;@link     * java.lang.Runtime#availableProcessors&#125;, using the &#123;@linkplain     * #defaultForkJoinWorkerThreadFactory default thread factory&#125;,     * no UncaughtExceptionHandler, and non-async LIFO processing mode.     *     * @throws SecurityException if a security manager exists and     *         the caller is not permitted to modify threads     *         because it does not hold &#123;@link     *         java.lang.RuntimePermission&#125;&#123;@code (&quot;modifyThread&quot;)&#125;     */    public ForkJoinPool() &#123;        this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),             defaultForkJoinWorkerThreadFactory, null, false);    &#125;
ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。

1.4 RecursiveAction使用样例
用于没有返回结果的任务，利用RecursiveAction，拆分大文件。代码如下：

package com.yuanxw.chapter17;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.nio.channels.FileChannel;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveAction;import java.util.concurrent.TimeUnit;/** * 利用RecursiveAction，拆分大文件 */public class ForkJoinRecursiveAction &#123;    // 阈值    private final static int SPLIT_THRESHOLD = 100_000_000;    public static void main(String[] args) throws IOException, InterruptedException &#123;        String fileFullPath = &quot;G:\\当幸福来敲门BD中英双字1280高清.rmvb&quot;;        File bigFile = new File(fileFullPath);        FileInputStream fileInputStream = new FileInputStream(bigFile);        ForkJoinPool forkJoinPool = new ForkJoinPool();        ForkJoinTask&lt;Void&gt; submit = forkJoinPool.submit(new SplitFileRecursiveAction(fileInputStream, fileFullPath, 0, (int) bigFile.length()));        // 等待任务执行结束        forkJoinPool.awaitTermination(1, TimeUnit.SECONDS);    &#125;    /**     * 无返回值ForkJoin任务     */    private static class SplitFileRecursiveAction extends RecursiveAction &#123;        // 文件输出流        private FileInputStream fileInputStream;        // 文件全路径        private String fileFullPath;        // 开始位置        private int start;        // 结束位置        private int end;        public SplitFileRecursiveAction(FileInputStream fileInputStream, String fileFullPath, int start, int end) &#123;            this.fileInputStream = fileInputStream;            this.fileFullPath = fileFullPath;            this.start = start;            this.end = end;        &#125;        @Override        protected void compute() &#123;            // 如果任务计算小于阈值，则开始拆分文件            int length = end - start;            System.out.println(start +&quot;-&quot;+end);            if(length &lt;= SPLIT_THRESHOLD)&#123;                try &#123;                    // 每次切割大小                    byte[] buffer = new byte[length];                    File currentTempFile = new File(fileFullPath);                    String[] split = currentTempFile.getName().split(&quot;\\.&quot;);                    File fileName = new File(String.format(&quot;%s_%s_%s.%s&quot;, currentTempFile.getParent()+split[0], start, end, split[1]));                    FileOutputStream fileOutputStream = new FileOutputStream(fileName);                    FileChannel outputChannel = fileOutputStream.getChannel();                    // 通道传输文件数据                    fileInputStream.getChannel().transferTo(start, end, outputChannel);                    fileOutputStream.write(buffer);                    fileOutputStream.flush();                    outputChannel.close();                &#125; catch (FileNotFoundException e) &#123;                    e.printStackTrace();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125; else &#123;                // 获得中间值，向上取整                int middle = (end + start) / 2;                SplitFileRecursiveAction leftAction = new SplitFileRecursiveAction(fileInputStream,fileFullPath,start,middle);                SplitFileRecursiveAction rightAction = new SplitFileRecursiveAction(fileInputStream,fileFullPath,middle+1,end);                leftAction.fork();                rightAction.fork();                leftAction.join();                rightAction.join();            &#125;        &#125;    &#125;&#125;
执行结果：

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十七)Java多线程之ForkJoin框架》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十三)Java多线程之CyclicBarrier</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B8%89)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCyclicBarrier/</url>
    <content><![CDATA[1.JAVA多线程(十三)Java多线程之CyclicBarrier&emsp;&emsp; CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。
1.1 CyclicBarrier类&emsp;&emsp;  CyclicBarrier是java.util.concurrent包下面的一个工具类，字面意思是可循环使用（Cyclic）的屏障（Barrier），通过它可以实现让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，所有被屏障拦截的线程才会继续执行。

CyclicBarrier是一种同步机制,它可以使得一组线程在同一个障碍点进行等待。
CyclicBarriers 可以通过重置计数器从而重新使用。
CyclicBarrier支持一个可选的Runnable命令(实例化构造函数中的参数)，该命令在最后一个线程到达后，但在任何线程被释放之前被执行。这一命令在barrier处只会被执行一次,且由最后到达的线程完成。这种屏障行为对于在任何一方继续之前更新共享状态都很有用。
all-or-none破损模型：如果一个线程因为中断(or执行过程的失败,超时等)过早的离开了barrier点,那么等待在barrier点的其他所有线程也会在同一时间因为BrokenBarrierException或者InterruptedException异常而离开barrier。内存一致性影响：

线程在调用await()方法之前的行为要优先于barrier action中的任何行为。



barrier action成功返回这一行为要优先于所有其他等待线程await()后的行为。



1.2 CyclicBarrier示例package com.yuanxw.chapter13;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;/** * CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。 * 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 * CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。 */public class CyclicBarrierExample &#123;    private static volatile boolean isRunning = true;    public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123;        final CyclicBarrier cyclicBarrier = new CyclicBarrier(2, new Runnable() &#123;            @Override            public void run() &#123;                isRunning = false;                System.out.println(&quot;任务执行结束后，回调函数！！！&quot;);            &#125;        &#125;);        /** 线程-A **/        new Thread(()-&gt;&#123;            try &#123;                TimeUnit.SECONDS.sleep(20);                System.out.println(String.format(&quot;线程【%s】执行完成&quot;, Thread.currentThread().getName()));                cyclicBarrier.await();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; catch (BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;Thread-A&quot;).start();        /** 线程-A **/        new Thread(()-&gt;&#123;            try &#123;                TimeUnit.SECONDS.sleep(10);                System.out.println(String.format(&quot;线程【%s】执行完成&quot;, Thread.currentThread().getName()));                cyclicBarrier.await();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; catch (BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;Thread-B&quot;).start();        while (isRunning) &#123;            System.out.println(String.format(&quot;当前正在等待数量：【%s】&quot;, cyclicBarrier.getNumberWaiting()));            System.out.println(String.format(&quot;正在等待所需数量：【%s】 &quot;, cyclicBarrier.getParties()));            System.out.println(String.format(&quot;中断或超时：【%s】&quot;, cyclicBarrier.isBroken()));            TimeUnit.SECONDS.sleep(5);        &#125;    &#125;&#125;
执行结果：
当前正在等待数量：【0】正在等待所需数量：【2】 中断或超时：【false】当前正在等待数量：【0】正在等待所需数量：【2】 中断或超时：【false】线程【Thread-B】执行完成当前正在等待数量：【1】正在等待所需数量：【2】 中断或超时：【false】当前正在等待数量：【1】正在等待所需数量：【2】 中断或超时：【false】线程【Thread-A】执行完成任务执行结束后，回调函数！！！

1.3 CyclicBarrier 和 CountDownLatch 的区别
CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。
对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。
CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十三)Java多线程之CyclicBarrier》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 多线程(十九)Java 多线程之 CachedThreadPool 可缓存线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B9%9D)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BnewCachedThreadPool%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB/</url>
    <content><![CDATA[1.JAVA 多线程(十九)Java 多线程之 CachedThreadPool 可缓存线程池1.1 可缓存线程池 CachedThreadPool&emsp;&emsp; 可缓存线程池 CachedThreadPool 是一个根据需要创建新线程的线程池。通过源代码查看 CachedThreadPool 实现：
/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available.  These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */public static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());&#125;/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available, and uses the provided * ThreadFactory to create new threads when needed. * @param threadFactory the factory to use when creating new threads * @return the newly created thread pool * @throws NullPointerException if threadFactory is null */public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;(),                                  threadFactory);&#125;

在 CachedThreadPool 实现中：

corePoolSize &#x3D;&gt; 0，核心线程池的数量为：0
maximumPoolSize &#x3D;&gt; Integer.MAX_VALUE，线程池最大数量为 Integer.MAX_VALUE，可以认为可以无限创建线程。在资源有限的情况下容易引起 OOM 异常。
keepAliveTime &#x3D;&gt; keepAliveTime 为 60 少，意味着线程空闲时间超过 60S 就会被杀死；
workQueue &#x3D;&gt; 采用 SynchronousQueue 装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。

1.2 CachedThreadPool 使用样例CachedThreadPool 线程池特点：

工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
keepAliveTime 时长为 60 秒，超过 60 秒的空闲线程就会被回收，当线程池都处于闲置状态时，线程池中的线程都会因为超时而被回收，所以几乎不会占用什么系统资源。任务队列采用的是 SynchronousQueue，这个队列是无法插入任务的，一有任务立即执行，所以 CachedThreadPool 比较适合任务量大但耗时少的任务。

package com.yuanxw.chapter19;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class CachedThreadPoolExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        ExecutorService executorService = Executors.newCachedThreadPool();        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());        executorService.execute(()-&gt;System.out.println(String.format(&quot;线程【%s】正在工作......&quot;, Thread.currentThread().getName())));        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());        for (int i = 0; i &lt; 20; i++) &#123;            executorService.execute(()-&gt;&#123;                    try &#123;                        TimeUnit.SECONDS.sleep(1);                        System.out.println(String.format(&quot;线程【%s】正在工作&gt;&gt;&gt;&gt;&quot;, Thread.currentThread().getName()));                        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;            &#125;);        &#125;        TimeUnit.SECONDS.sleep(5);        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());    &#125;&#125;

执行结果：
获得活动的线程评估数：0获得活动的线程评估数：1线程【pool-1-thread-1】正在工作......线程【pool-1-thread-3】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-7】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-5】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：20线程【pool-1-thread-4】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-6】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-2】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：19获得活动的线程评估数：19获得活动的线程评估数：20获得活动的线程评估数：20获得活动的线程评估数：19线程【pool-1-thread-19】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-15】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-21】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-16】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-20】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-14】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14线程【pool-1-thread-8】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14获得活动的线程评估数：14线程【pool-1-thread-11】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-12】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-18】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14获得活动的线程评估数：11获得活动的线程评估数：11获得活动的线程评估数：11获得活动的线程评估数：13线程【pool-1-thread-9】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-13】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14线程【pool-1-thread-10】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14线程【pool-1-thread-17】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5获得活动的线程评估数：6获得活动的线程评估数：6获得活动的线程评估数：4获得活动的线程评估数：0

CachedThreadPool 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：

首先执行 SynchronousQueue.offer(Runnable task) 提交任务到任务队列。如果当前 maximumPool 中有闲线程正在执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)，那么主线程执行 offer 操作与空闲线程执行的 poll 操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成，否则执行下面的步骤

当初始 maximumPool 为空，或者 maximumPool 中没有空闲线程时，将没有线程执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)。这种情况下，步骤 1 将失败，此时 CachedThreadPool 会创建新线程执行任务，execute 方法执行完成；


&emsp;&emsp;&emsp;&emsp;– 以上为《JAVA 多线程(十九)Java 多线程之 CachedThreadPool 可缓存线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。
  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十二)Java多线程之CountDownLatch</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%BA%8C)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCountDownLatch/</url>
    <content><![CDATA[1.JAVA多线程(十二)Java多线程之CountDownLatch1.1 CountDownLatch是什么?&emsp;&emsp; CountDownLatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。

某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减 1 countdownlatch.countDown()，当计数器的值变为 0 时，在CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。

实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 ：new CountDownLatch(1)，多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。

CountDownLatch维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。



1.2 CountdownLatch使用例子package com.yuanxw.chapter12;import java.util.Random;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.stream.IntStream;public class CountdownLatchExample &#123;    /** 随机数：使用long参数的所有64位作为因子值。 **/    private static Random random = new Random(System.currentTimeMillis());    /** 总线程数 **/    private static final int TOTAL_THREAD_NUMBER = 5;    /** 通过线程池，创建5个线程 **/    private static ExecutorService executorService = Executors.newFixedThreadPool(TOTAL_THREAD_NUMBER);    /** 创建CountDownLatch对象 **/    private static CountDownLatch countDownLatch = new CountDownLatch(TOTAL_THREAD_NUMBER);    public static void main(String[] args) throws InterruptedException &#123;        IntStream.range(0,5).forEach(i-&gt;&#123;            executorService.execute(()-&gt;&#123;                doWorking();                /** 将count值减1 **/                countDownLatch.countDown();            &#125;);        &#125;);        /** 当前线程等到锁存器计数到零  **/        countDownLatch.await();        executorService.shutdown();        System.out.println(&quot;所有线程工作已经执行完成！！！&quot;);    &#125;    /**     * 模拟工作方法     */    private static void doWorking()&#123;        try &#123;            System.out.println(String.format(&quot;线程【%s】工作&gt;&gt;开始&quot;, Thread.currentThread().getName()));            Thread.sleep(random.nextInt(1000));            System.out.println(String.format(&quot;线程【%s】工作&lt;&lt;结束&quot;, Thread.currentThread().getName()));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
执行结果：
线程【pool-1-thread-2】工作&gt;&gt;开始线程【pool-1-thread-5】工作&gt;&gt;开始线程【pool-1-thread-3】工作&gt;&gt;开始线程【pool-1-thread-4】工作&gt;&gt;开始线程【pool-1-thread-1】工作&gt;&gt;开始线程【pool-1-thread-4】工作&lt;&lt;结束线程【pool-1-thread-2】工作&lt;&lt;结束线程【pool-1-thread-3】工作&lt;&lt;结束线程【pool-1-thread-1】工作&lt;&lt;结束线程【pool-1-thread-5】工作&lt;&lt;结束所有线程工作已经执行完成！！！


 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十一)Java多线程之CountDownLatch》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十五)Java多线程之ReentrantLock重入锁</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%BA%94)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BReentrantLock%E9%87%8D%E5%85%A5%E9%94%81/</url>
    <content><![CDATA[1.JAVA多线程(十五)Java多线程之ReentrantLock重入锁1.1 什么是ReentrantLock重入锁？&emsp;&emsp; 重入锁：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。
1.2 synchronized和ReentrantLock 的区别
两者都是可重入锁。
synchronized 依赖于 JVM 而 ReentrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。
ReentrantLock 比 synchronized 增加了一些高级功能:


等待可中断：&emsp;&emsp; ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。

可实现公平锁：ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的

可实现选择性通知（锁可以绑定多个条件）synchronized关键字与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。



两者都是可重入锁&emsp;&emsp;JDK5中，synchronized是性能低效的，因为这是一个重量级操作，对性能的最大影响是阻塞的实现，挂起线程和恢复线程的操作，都需要转入内核态中完成，给并发带来了很大压力。JDK6中synchronized加入了自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等一系列优化，官方也支持synchronized，提倡在synchronized能实现需求的前提下，优先考虑synchronized来进行同步。

1.3 ReentrantLock使用样例package com.yuanxw.chapter15;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.stream.IntStream;/** * ReentrantLock重入锁 */public class ReentrantLockExample &#123;    private static final Lock LOCK = new ReentrantLock();    public static void main(String[] args) &#123;        // 创建两个线程        IntStream.range(0, 2).forEach(i -&gt; &#123;            new Thread(() -&gt; testReentrantLock()).start();        &#125;);    &#125;    public static void testReentrantLock() &#123;        try &#123;            LOCK.lock();            System.out.println(String.format(&quot;线程【%s】工作---&gt;开始&quot;, Thread.currentThread().getName()));            TimeUnit.SECONDS.sleep(5);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            LOCK.unlock();            System.out.println(String.format(&quot;线程【%s】工作---&gt;结束&quot;, Thread.currentThread().getName()));        &#125;    &#125;&#125;

执行结果：
线程【Thread-0】工作---&gt;开始线程【Thread-0】工作---&gt;结束线程【Thread-1】工作---&gt;开始线程【Thread-1】工作---&gt;结束
1.4 ReentrantLock源码
构造方法，我们可以看出默认的无参是非公平锁，有参构造true表示公平，false表示非公平。lock()获取锁，其实就是把state从0变成n（重入锁可以累加）。实际调用的是sync的lock方法，分公平和非公平。

/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123;    sync = new NonfairSync();&#125;/** * Creates an instance of &#123;@code ReentrantLock&#125; with the * given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy */public ReentrantLock(boolean fair) &#123;    sync = fair ? new FairSync() : new NonfairSync();&#125;

公平实现：FairSync，我们发现其实调用的是acquire，其实这个是AQS的acquire，然后aqs的acquire的方法里面又会调用tryAcquire方法，因为这个方法需要同步组件自己去实现，所以ReentrantLock里面重写了AQS的tryAcquire方法,所以我们获取到锁就会返回true，没有就会返回false；然后没有获取到锁的线程就交给AQS去处理。

/** * Sync object for fair locks */static final class FairSync extends Sync &#123;    private static final long serialVersionUID = -3000897897090466540L;    final void lock() &#123;        acquire(1);    &#125;    /**     * Fair version of tryAcquire.  Don&#x27;t grant access unless     * recursive call or no waiters or is first.     */    protected final boolean tryAcquire(int acquires) &#123;        // 获取当前的线程        final Thread current = Thread.currentThread();        // 获取锁的状态        int c = getState();        if (c == 0) &#123;            /**              * hasQueuedPredecessors 判断队列还有没有其它node,要保证公平             * 没有在用cas设置状态            **/            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                // 设置获取锁的线程                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        // 判断当前线程有没有获取到锁        else if (current == getExclusiveOwnerThread()) &#123;            // 获取过了就累加，因为可以重入            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error(&quot;Maximum lock count exceeded&quot;);            // 重新设置锁的状态            setState(nextc);            return true;        &#125;        return false;    &#125;&#125;

非公平实现：NonfairSync,我们可以发现基本和公平一样，就没有hasQueuedPredecessors方法，没有遵循FIFO队列的模式，而是不管队列有没有node，自己都可以去获取锁，不需要排队

/** * Sync object for fair locks */static final class FairSync extends Sync &#123;    private static final long serialVersionUID = -3000897897090466540L;    final void lock() &#123;        acquire(1);    &#125;    /**     * Fair version of tryAcquire.  Don&#x27;t grant access unless     * recursive call or no waiters or is first.     */    protected final boolean tryAcquire(int acquires) &#123;        final Thread current = Thread.currentThread();        int c = getState();        if (c == 0) &#123;            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        else if (current == getExclusiveOwnerThread()) &#123;            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error(&quot;Maximum lock count exceeded&quot;);            setState(nextc);            return true;        &#125;        return false;    &#125;&#125;

unlock释放锁：其实就是把state从n（可能发生了锁的重入，需要多次释放）变成0，这个不区分公平与非公平，首先其实也是调用AQS的release方法，然后AQS在调用子类Sync的tryRelease方法。

/** * Attempts to release this lock. * * &lt;p&gt;If the current thread is the holder of this lock then the hold * count is decremented.  If the hold count is now zero then the lock * is released.  If the current thread is not the holder of this * lock then &#123;@link IllegalMonitorStateException&#125; is thrown. * * @throws IllegalMonitorStateException if the current thread does not *         hold this lock */public void unlock() &#123;    sync.release(1);&#125;protected final boolean tryRelease(int releases) &#123;    // 获取锁的状态    int c = getState() - releases;    // 获得锁的线程才能释放锁    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    // 直到锁的状态是0，说明锁释放成功，因为有重入锁    // 说明我们在一个线程里面调用几次lock，就要调用几次unlock，才能最终释放锁    if (c == 0) &#123;        free = true;        // 释放线程的拥有者        setExclusiveOwnerThread(null);    &#125;    // 设置锁的状态    setState(c);    return free;&#125;/** * Releases in exclusive mode.  Implemented by unblocking one or * more threads if &#123;@link #tryRelease&#125; returns true. * This method can be used to implement method &#123;@link Lock#unlock&#125;. * * @param arg the release argument.  This value is conveyed to *        &#123;@link #tryRelease&#125; but is otherwise uninterpreted and *        can represent anything you like. * @return the value returned from &#123;@link #tryRelease&#125; */public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十五)Java多线程之ReentrantLock重入锁》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十八)Java多线程之Executor框架&amp;ThreadPoolExecutor类</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E5%85%AB)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BExecutor%E6%A1%86%E6%9E%B6&amp;ThreadPoolExecutor%E7%B1%BB/</url>
    <content><![CDATA[1.JAVA多线程(十八)Java多线程之Executor框架&amp;ThreadPoolExecutor类&emsp;&emsp; Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。

this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。

在开发中如果需要创建线程可优先考虑使用Executor，无论你需要多线程还是单线程，Executor为你提供了很多其他功能，包括线程状态，生命周期的管理。Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。
1.1 无限制创建线程不足在生产环境中，“为每个任务分配一个线程”这种方法存在一些缺陷，尤其是当需要创建大量线程时：

管理线程的生命周期开销非常高：管理这些线程的生命周期会明显增加 CPU 的执行时间，会消耗大量计算资源。
资源消耗：活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可用的处理器的数量，那么有些线程将闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。如果你已经拥有足够多的线程使所有的CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。
稳定性：创建线程的数量存在一个限制，这个限制将随着平台的不同而不同，并且受多个因素制约，包括jvm的启动参数、Thread构造函数中请求的栈大小，以及底层操作的限制等。如果超过了这个限制，那么很可能抛出OutOfMemoryError异常，这对于运行中的应用来说是非常危险的。

所有的这些因素都会导致系统吞吐量下降。线程池通过保持一些存活线程并重用这些线程来克服这个问题。当提交到线程池中的任务多于线程池最大任务数时，那些多余的任务将被放到一个队列中。 一旦正在执行的线程有空闲了，它们会从队列中取下一个任务来执行。JDK 中的 Executors中， 此任务队列是没有长度限制的。
1.2 Executor的实现关系图Executor框架包括3大部分：

任务：包括被执行的任务需要实现的接口：Runable 接口、Callable接口；Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。
任务的执行：包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口：ThreadPoolExecutor 和 ScheduledThreadPoolExecutor、ForkJoinPool；这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 ThreadPoolExecutor 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。
任务的异步计算结果：包括Future接口和实现Future接口的FutureTask类、ForkJoinTask类，都可以代表异步计算的结果。当我们把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 submit() 方法时会返回一个 FutureTask 对象）

Java优秀框架的设计思路，顶级接口-次级接口-虚拟实现类-实现类。



属性
说明



Executor
执行者，java线程池框架的最上层父接口，地位类似于spring的BeanFactry、集合框架的Collection接口，在Executor这个接口中只有一个execute方法，该方法的作用是向线程池提交任务并执行。


ExecutorService
该接口继承自Executor接口，添加了shutdown、shutdownAll、submit、invokeAll等一系列对线程的操作方法，该接口比较重要，在使用线程池框架的时候，经常用到该接口。


AbstractExecutorService
这是一个抽象类，实现ExecuotrService接口


ThreadPoolExecutor
这是Java线程池最核心的一个类，该类继承自AbstractExecutorService，主要功能是创建线程池，给任务分配线程资源，执行任务。


ScheduledExecutorSerivce
提供了另一种线程池：延迟执行和周期性执行的线程池。


ScheduledThreadPoolExecutor
提供了另一种线程池：延迟执行和周期性执行的线程池。


Executors
这是一个静态工厂类，该类定义了一系列静态工厂方法，通过这些工厂方法可以返回各种不同的线程池。


1.3 ThreadPoolExecutor 类
线程池实现类 ThreadPoolExecutor 是 Executor 框架最核心的类。ThreadPoolExecutor 类中提供的四个构造方法，直接看参数最多的构造方法，其余三个都是在这个构造方法的基础上产生。源代码如下：

/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the *        pool * @param keepAliveTime when the number of threads is greater than *        the core, this is the maximum time that excess idle threads *        will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are *        executed.  This queue will hold only the &#123;@code Runnable&#125; *        tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor *        creates a new thread * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; *         &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize,     // 线程池的核心线程数量，即使空闲时仍保留在池中的线程数，除非设置 allowCoreThreadTimeOut                           int maximumPoolSize,  // 池中允许的最大线程数                           long keepAliveTime,   // 当线程数大于内核时，这是多余的空闲线程在终止前等待新任务的最大时间。                           TimeUnit unit,        // keepAliveTime参数的时间单位                          BlockingQueue&lt;Runnable&gt; workQueue,    // 用于在执行任务之前使用的队列。 这个队列将仅保存execute方法提交的Runnable任务。                           ThreadFactory threadFactory,  // 线程工厂，用来创建线程，一般默认即可                          RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务                          ) &#123;    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.acc = System.getSecurityManager() == null ?            null :            AccessController.getContext();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;&#125;



使用Executors风险：&emsp;&emsp;线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

【说明】：Executors返回的线程池对象的弊端如下： 

FixedThreadPool和SingleThreadPool： 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。 
CachedThreadPool： 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。摘自《阿里巴巴Java开发手册（华山版）》

package com.yuanxw.chapter18;import java.util.Random;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolExecutorExample &#123;    // 随机数：使用long参数的所有64位作为因子值。    private static Random random = new Random(System.currentTimeMillis());    public static void main(String[] args) throws InterruptedException &#123;        /**         * ThreadPoolExecutor 构造函数创建线程池         * int corePoolSize,     // 线程池的核心线程数量，即使空闲时仍保留在池中的线程数，除非设置 allowCoreThreadTimeOut。         * int maximumPoolSize,  // 池中允许的最大线程数。         * long keepAliveTime,   // 当线程数大于内核时，这是多余的空闲线程在终止前等待新任务的最大时间。         * TimeUnit unit,        // keepAliveTime参数的时间单位。         * BlockingQueue&lt;Runnable&gt; workQueue,    // 用于在执行任务之前使用的队列。 这个队列将仅保存execute方法提交的Runnable任务。         * ThreadFactory threadFactory,  // 线程工厂，用来创建线程，一般默认即可。         * RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务。         */        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), r -&gt; new Thread(r), new ThreadPoolExecutor.AbortPolicy());        threadPoolExecutor.execute(() -&gt; processTask(random.nextInt(100)));        threadPoolExecutor.execute(() -&gt; processTask(random.nextInt(100)));        threadPoolExecutor.execute(() -&gt; processTask(random.nextInt(100)));        /**         * shutdown() VS shutdownNow()         * - shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。         * - shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。         */        threadPoolExecutor.shutdown();        int activeCount = -1;        int queueSize = -1;        while (true) &#123;            /**             * isTerminated() VS isShutdown()             * - isShutDown 当调用 shutdown() 方法后返回为 true。             * - isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true。             */            if(threadPoolExecutor.isTerminated())&#123;                break;            &#125;            if (activeCount != threadPoolExecutor.getActiveCount()                    || queueSize != threadPoolExecutor.getQueue().size()) &#123;                System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());                System.out.println(&quot;核心线程数：&quot; + threadPoolExecutor.getCorePoolSize());                System.out.println(&quot;执行程序使用的任务队列大小：&quot; + threadPoolExecutor.getQueue().size());                System.out.println(&quot;允许的最大线程数：&quot; + threadPoolExecutor.getMaximumPoolSize());                activeCount = threadPoolExecutor.getActiveCount();                queueSize = threadPoolExecutor.getQueue().size();                System.out.println(&quot;--------------------------------------------&quot;);                TimeUnit.SECONDS.sleep(1);            &#125;        &#125;    &#125;    /**     * 线程休眠的方法     *     * @param seconds     */    private static void processTask(long seconds) &#123;        try &#123;            System.out.println(String.format(&quot;&gt;&gt;&gt;&gt;&gt;【%s】线程正在处理任务&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, Thread.currentThread().getName()));            TimeUnit.SECONDS.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
执行结果：
获得活动的线程评估数：2核心线程数：1执行程序使用的任务队列大小：1允许的最大线程数：2--------------------------------------------&gt;&gt;&gt;&gt;&gt;【Thread-0】线程正在处理任务&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【Thread-1】线程正在处理任务&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;获得活动的线程评估数：1&gt;&gt;&gt;&gt;&gt;【Thread-0】线程正在处理任务&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;核心线程数：1执行程序使用的任务队列大小：0允许的最大线程数：2--------------------------------------------获得活动的线程评估数：0核心线程数：1执行程序使用的任务队列大小：0允许的最大线程数：2--------------------------------------------

1.4 ThreadPoolExecutor线程池原理分析&emsp;&emsp;为了搞懂线程池的原理，我们需要首先分析一下 execute方法。threadPoolExecutor.execute()，来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：
// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// Packing and unpacking ctlprivate static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;/** * The queue used for holding tasks and handing off to worker * threads.  We do not require that workQueue.poll() returning * null necessarily means that workQueue.isEmpty(), so rely * solely on isEmpty to see if the queue is empty (which we must * do for example when deciding whether to transition from * SHUTDOWN to TIDYING).  This accommodates special-purpose * queues such as DelayQueues for which poll() is allowed to * return null even if it may later return non-null when delays * expire. */private final BlockingQueue&lt;Runnable&gt; workQueue;/** * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;. * * @param command the task to execute * @throws RejectedExecutionException at discretion of *         &#123;@code RejectedExecutionHandler&#125;, if the task *         cannot be accepted for execution * @throws NullPointerException if &#123;@code command&#125; is null */public void execute(Runnable command) &#123;    // 如果任务为null，则抛出异常。    if (command == null)        throw new NullPointerException();    /*     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn&#x27;t, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */     // ctl 中保存的线程池当前的一些状态信息    int c = ctl.get();    // 下面会涉及到 3 步 操作    // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize    // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务    if (workerCountOf(c) &lt; corePoolSize) &#123;        if (addWorker(command, true))            return;        c = ctl.get();    &#125;    // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里    // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。        int recheck = ctl.get();        if (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        // 如果当前线程池为空就新创建一个线程并执行。        else if (workerCountOf(recheck) == 0)            addWorker(null, false);    &#125;    // 3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。    // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。    else if (!addWorker(command, false))        reject(command);&#125;
&emsp;&emsp;执行threadPoolExecutor.execute()方法，提交任务效果图，通过下图可以更好的对上面这 3 步做一个展示：

1.5 ThreadPoolExecutor拒绝策略&emsp;&emsp;如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:

ThreadPoolExecutor.AbortPolicy：（默认策略）抛出 RejectedExecutionException异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。
ThreadPoolExecutor.CallerRunsPolicy：（建议使用）调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略当最大池被填满时，此策略为我们提供可伸缩队列。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。
ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。
ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十八)Java多线程之Executor框架&amp;ThreadPoolExecutor类》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十六)Java多线程之Condition对象</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E5%85%AD)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCondition/</url>
    <content><![CDATA[1.JAVA多线程(十六)Java多线程之Condition对象1.1 什么是Condition？&emsp;&emsp; Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，阻塞队列实际上是使用了Condition来模拟线程间协作。
&emsp;&emsp; 我们使用synchronized来控制同步，配合Object的wait()、notify()系列方法可以实现等待&#x2F;通知模式。在Java SE5后，Java提供了Lock接口，相对于Synchronized而言，Lock提供了条件Condition，对线程的等待、唤醒操作更加详细和灵活。下图是Condition与Object的监视器方法的对比（摘自《Java并发编程的艺术》）
1.2 Condition使用样例package com.yuanxw.chapter16;import java.util.Arrays;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ConditionExample &#123;    // 定义【重入锁】非公平锁    private static final ReentrantLock REENTRANT_LOCK = new ReentrantLock();    // 获得Condition实例    private static final Condition CONDITION = REENTRANT_LOCK.newCondition();    // volatile:内存可见性关键字，默认为没有生产，可以进行生产    private static volatile boolean isProducted = false;    // 生产数量    private static int num = 0;    /**     * 生产方法     */    public static void produce() &#123;        try &#123;            // 加锁            REENTRANT_LOCK.lock();            while (isProducted) &#123;                CONDITION.await();            &#125;            // 生产消息数量 + 1            num++;            // 设置为已经生产消息            isProducted = true;            // 通知消费者，可以进行消费            CONDITION.signalAll();            System.out.println(String.format(&quot;线程【%s】，生产消息&gt;&gt;【%s】&quot;, Thread.currentThread().getName(), num));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            // 解锁            REENTRANT_LOCK.unlock();        &#125;    &#125;    /**     * 消息方法     */    public static void consumer() &#123;        // 加锁        try &#123;            REENTRANT_LOCK.lock();            // 如果已经生产，那么消费者消费            while (!isProducted) &#123;                CONDITION.await();            &#125;            System.out.println(String.format(&quot;线程【%s】，消费消息&lt;&lt;&lt;&lt;【%s】&quot;, Thread.currentThread().getName(), num));            // 设置标记：未生产            isProducted = false;            // 通知生产者已经消费            CONDITION.signalAll();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            REENTRANT_LOCK.unlock();        &#125;    &#125;    public static void main(String[] args) &#123;        // 创建两个生产者线程分别为：Produce1、Produce2        Arrays.asList(&quot;Produce1&quot;, &quot;Produce2&quot;).forEach(produceName -&gt; &#123;            new Thread(() -&gt; &#123;                while (true) &#123;                    ConditionExample.produce();                    try &#123;                        TimeUnit.SECONDS.sleep(1);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;,produceName).start();        &#125;);        // 创建三个生产者线程分别为：Consumer1、Consumer2、Consumer3        Arrays.asList(&quot;Consumer1&quot;, &quot;Consumer2&quot;, &quot;Consumer3&quot;).forEach(consumerName -&gt; &#123;            new Thread(() -&gt; &#123;                while (true) &#123;                    ConditionExample.consumer();                    try &#123;                        TimeUnit.SECONDS.sleep(1);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;,consumerName).start();        &#125;);    &#125;&#125;
执行结果：
线程【Produce1】，生产消息&gt;&gt;【1】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【1】线程【Produce2】，生产消息&gt;&gt;【2】线程【Consumer2】，消费消息&lt;&lt;&lt;&lt;【2】线程【Produce1】，生产消息&gt;&gt;【3】线程【Consumer3】，消费消息&lt;&lt;&lt;&lt;【3】线程【Produce2】，生产消息&gt;&gt;【4】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【4】线程【Produce1】，生产消息&gt;&gt;【5】线程【Consumer2】，消费消息&lt;&lt;&lt;&lt;【5】线程【Produce2】，生产消息&gt;&gt;【6】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【6】线程【Produce1】，生产消息&gt;&gt;【7】线程【Consumer3】，消费消息&lt;&lt;&lt;&lt;【7】线程【Produce2】，生产消息&gt;&gt;【8】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【8】线程【Produce2】，生产消息&gt;&gt;【9】线程【Consumer2】，消费消息&lt;&lt;&lt;&lt;【9】线程【Produce1】，生产消息&gt;&gt;【10】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【10】

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十六)Java多线程之Condition对象》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十四)Java多线程之Semaphore信号量</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E5%9B%9B)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSemaphore%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[1.JAVA多线程(十四)Java多线程之Semaphore信号量&emsp;&emsp; Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。把它比作是控制流量的红绿灯，比如一条马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入马路，但是如果前一百辆中有五辆车已经离开了马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。
1.1 Semaphore(信号量)-允许多个线程同时访问&emsp;&emsp; 执行 acquire 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 release 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。
&emsp;&emsp; 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10，代码如下：
package com.yuanxw.chapter14;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;public class SemaphoreExample &#123;    /** 随机数：使用long参数的所有64位作为因子值。 **/    private static Random random = new Random(System.currentTimeMillis());    /** 总线程数 **/    private static final int TOTAL_THREAD_NUMBER = 10;    /** 允许执行的线程数 **/    final static int ACQUIRE_THREAD_NUMBER = 3;    public static void main(String[] args) throws InterruptedException &#123;        Semaphore semaphore = new Semaphore(ACQUIRE_THREAD_NUMBER);        ExecutorService executorService = Executors.newFixedThreadPool(TOTAL_THREAD_NUMBER);        IntStream.range(0,TOTAL_THREAD_NUMBER).forEach(i -&gt; &#123;            executorService.execute(()-&gt;&#123;                try &#123;                    System.out.println(String.format(&quot;线程【%s】&gt;&gt;&gt;&gt;准备工作&quot;, Thread.currentThread().getName()));                    semaphore.acquire();                    System.out.println(String.format(&quot;线程【%s】工作===&gt;开始&quot;, Thread.currentThread().getName()));                    TimeUnit.SECONDS.sleep(random.nextInt(5));                    System.out.println(String.format(&quot;线程【%s】工作&lt;====结束&quot;, Thread.currentThread().getName()));                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    semaphore.release();                &#125;            &#125;);        &#125;);        executorService.shutdown();        // main线程监控信号量中许可数变化        while (true) &#123;            if(executorService.isTerminated())&#123;break;&#125;            System.out.println(&quot;信号量中当前可用的许可数：&quot; + semaphore.availablePermits());            System.out.println(&quot;等待获取的线程数:&quot; + semaphore.getQueueLength());            TimeUnit.SECONDS.sleep(1);        &#125;    &#125;&#125;

执行结果：
信号量中当前可用的许可数：3等待获取的线程数:0线程【pool-1-thread-6】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-5】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-7】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-1】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-3】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-8】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-7】工作===&gt;开始线程【pool-1-thread-5】工作===&gt;开始线程【pool-1-thread-6】工作===&gt;开始线程【pool-1-thread-2】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-4】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-9】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-10】&gt;&gt;&gt;&gt;准备工作信号量中当前可用的许可数：0等待获取的线程数:7信号量中当前可用的许可数：0等待获取的线程数:7线程【pool-1-thread-5】工作&lt;====结束线程【pool-1-thread-6】工作&lt;====结束线程【pool-1-thread-7】工作&lt;====结束线程【pool-1-thread-3】工作===&gt;开始线程【pool-1-thread-1】工作===&gt;开始线程【pool-1-thread-8】工作===&gt;开始信号量中当前可用的许可数：0等待获取的线程数:4信号量中当前可用的许可数：0等待获取的线程数:4线程【pool-1-thread-8】工作&lt;====结束线程【pool-1-thread-1】工作&lt;====结束线程【pool-1-thread-3】工作&lt;====结束线程【pool-1-thread-2】工作===&gt;开始线程【pool-1-thread-4】工作===&gt;开始线程【pool-1-thread-9】工作===&gt;开始信号量中当前可用的许可数：0等待获取的线程数:1信号量中当前可用的许可数：0等待获取的线程数:1线程【pool-1-thread-4】工作&lt;====结束线程【pool-1-thread-2】工作&lt;====结束线程【pool-1-thread-9】工作&lt;====结束线程【pool-1-thread-10】工作===&gt;开始信号量中当前可用的许可数：2等待获取的线程数:0信号量中当前可用的许可数：2等待获取的线程数:0线程【pool-1-thread-10】工作&lt;====结束
1.3 Semaphore(信号量)-构造Lock锁Semaphore类其实就是synchronized关键字的升级版，这个类主要作用就是控制线程并发的数量。当我们把许可的数量设置为1时，就变成了同步锁.
package com.yuanxw.chapter14;import java.util.Random;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;/** * 信号量锁 */public class SemaphoreExampleV2 &#123;    /**     * 随机数：使用long参数的所有64位作为因子值。     **/    private static Random random = new Random(System.currentTimeMillis());    public static void main(String[] args) &#123;        final SemaphoreLock semaphoreLock = new SemaphoreLock();        IntStream.range(0, 5).forEach(i -&gt; &#123;            new Thread(() -&gt; &#123;                try &#123;                    System.out.println(String.format(&quot;线程【%s】已经开始工作&quot;, Thread.currentThread().getName()));                    semaphoreLock.lock();                    System.out.println(String.format(&quot;线程【%s】获得锁&quot;, Thread.currentThread().getName()));                    TimeUnit.SECONDS.sleep(random.nextInt(5));                    System.out.println(String.format(&quot;线程【%s】已经释放锁&quot;, Thread.currentThread().getName()));                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    semaphoreLock.unLock();                &#125;            &#125;).start();        &#125;);    &#125;    static class SemaphoreLock &#123;        /**         * 在JDK1.8，需要加上volatile关键字         * 构造一个 Semaphore与给只有一个数量的许可证         **/        private volatile static  Semaphore semaphore = new Semaphore(1);        /**         * 加锁方法         *         * @throws InterruptedException         */        public void lock() throws InterruptedException &#123;            semaphore.acquire(1);        &#125;        /**         * 解锁方法         */        public void unLock() &#123;            semaphore.release(1);        &#125;    &#125;&#125;
执行结果：
线程【Thread-1】已经开始工作线程【Thread-3】已经开始工作线程【Thread-0】已经开始工作线程【Thread-4】已经开始工作线程【Thread-2】已经开始工作线程【Thread-1】获得锁线程【Thread-1】已经释放锁线程【Thread-0】获得锁线程【Thread-0】已经释放锁线程【Thread-3】获得锁线程【Thread-3】已经释放锁线程【Thread-4】获得锁线程【Thread-4】已经释放锁线程【Thread-2】获得锁线程【Thread-2】已经释放锁

1.3 Semaphore(信号量)JDK源码-构造方法Semaphore这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。

公平模式： 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；
抢占式：  有可能一个新的获取线程恰好在一个许可证释放时得到了这个许可证，而前面还有等待的线程。

/** * Creates a &#123;@code Semaphore&#125; with the given number of * permits and nonfair fairness setting. * * @param permits the initial number of permits available. *        This value may be negative, in which case releases *        must occur before any acquires will be granted. */public Semaphore(int permits) &#123;    sync = new NonfairSync(permits);&#125;/** * Creates a &#123;@code Semaphore&#125; with the given number of * permits and the given fairness setting. * * @param permits the initial number of permits available. *        This value may be negative, in which case releases *        must occur before any acquires will be granted. * @param fair &#123;@code true&#125; if this semaphore will guarantee *        first-in first-out granting of permits under contention, *        else &#123;@code false&#125; */public Semaphore(int permits, boolean fair) &#123;    sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十四)Java多线程之Semaphore》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(四)Java多线程之join等待结束</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bjoin%E7%AD%89%E5%BE%85%E7%BB%93%E6%9D%9F/</url>
    <content><![CDATA[1.JAVA多线程(四)Java多线程之join等待结束1.1 join(等待结束)&emsp;&emsp;join()方法的作用，是等待这个线程结束；
也就是说，thread.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程thread完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。
package com.yuanxw.chapter4;public class ThreadJoin &#123;    public static void main(String[] args) throws InterruptedException &#123;        long startTime = System.currentTimeMillis();        Thread thread1 = new Thread(new SyncDatabase(&quot;T1&quot;,&quot;192.168.185.26&quot;,1000L));        Thread thread2 = new Thread(new SyncDatabase(&quot;T2&quot;,&quot;192.168.185.27&quot;,1500L));        Thread thread3 = new Thread(new SyncDatabase(&quot;T3&quot;,&quot;192.168.185.28&quot;,2500L));        thread1.start();        thread2.start();        thread3.start();        // 等待【thread1、thread2、thread3】对象线程死亡（结束）        thread1.join();        thread2.join();        thread3.join();        long endTime = System.currentTimeMillis();        System.out.println(String.format(&quot;所有服务器数据同步完成，共耗时【%s】毫秒&quot;,endTime - startTime ));    &#125;&#125;/** * 同步数据库数据 */class SyncDatabase implements Runnable&#123;    /** 同步服务器名称 **/    private String serviceName;    /** 同步服务IP地址 **/    private String ipAddr;    /** 同步时间 **/    private long syncTime;    public SyncDatabase(String serviceName, String ipAddr, long syncTime) &#123;        this.serviceName = serviceName;        this.ipAddr = ipAddr;        this.syncTime = syncTime;    &#125;    @Override    public void run() &#123;        try &#123;            Thread.sleep(syncTime);            System.out.println(String.format(&quot;同步【%s】服务器，IP地址【%s】，数据同步完成，共耗时【%s】毫秒&quot;, serviceName,ipAddr,syncTime));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
执行结果：
同步【T1】服务器，IP地址【192.168.185.26】，数据同步完成，共耗时【1000】毫秒同步【T2】服务器，IP地址【192.168.185.27】，数据同步完成，共耗时【1500】毫秒同步【T3】服务器，IP地址【192.168.185.28】，数据同步完成，共耗时【2500】毫秒所有服务器数据同步完成，共耗时【2502】毫秒

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(四)Java多线程之join等待结束》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
