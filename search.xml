<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Arthas诊断工具(一)Arthas（阿尔萨斯）快速入门</title>
    <url>/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E4%B8%80)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[Arthas诊断工具(一)Arthas（阿尔萨斯）快速入门1. Arthas（阿尔萨斯） 能为你做什么？Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。

当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：

这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？
我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？
遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？
线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！
是否有一个全局视角来查看系统的运行状况？
有什么办法可以监控到JVM的实时运行状态？
怎么快速定位应用的热点，生成火焰图？
怎样直接从JVM内查找某个类的实例？

Arthas支持JDK 6+，支持Linux&#x2F;Mac&#x2F;Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。
2. 安装和卸载2.1 在线安装Arthas
如果下载速度比较慢，可以使用 aliyun 的镜像：java -jar arthas-boot.jar --repo-mirror aliyun --use-http

[root@localhost arthas]# curl -O https://arthas.aliyun.com/arthas-boot.jar  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100  141k  100  141k    0     0   271k      0 --:--:-- --:--:-- --:--:--  271k

2.2离线安装[root@localhost software]# wget https://github.com/alibaba/arthas/releases/download/arthas-all-4.0.5/arthas-bin.zip--2025-06-07 04:46:25--  https://github.com/alibaba/arthas/releases/download/arthas-all-4.0.5/arthas-bin.zipResolving github.com (github.com)... 20.205.243.166Connecting to github.com (github.com)|20.205.243.166|:443... connected.HTTP request sent, awaiting response... 302 FoundLocation: https://objects.githubusercontent.com/github-production-release-asset-2e65be/146633589/8f7c17e7-21d1-4e42-92b8-4ecefa107242?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=releaseassetproduction%2F20250607%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20250607T084434Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=0b3b5544008f728b619ef27e1c0a18f18a65a0948840e4201cabf902ac108612&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=attachment%3B%20filename%3Darthas-bin.zip&amp;response-content-type=application%2Foctet-stream [following]--2025-06-07 04:46:26--  https://objects.githubusercontent.com/github-production-release-asset-2e65be/146633589/8f7c17e7-21d1-4e42-92b8-4ecefa107242?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=releaseassetproduction%2F20250607%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20250607T084434Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=0b3b5544008f728b619ef27e1c0a18f18a65a0948840e4201cabf902ac108612&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=attachment%3B%20filename%3Darthas-bin.zip&amp;response-content-type=application%2Foctet-streamResolving objects.githubusercontent.com (objects.githubusercontent.com)... 185.199.108.133, 185.199.111.133, 185.199.110.133, ...Connecting to objects.githubusercontent.com (objects.githubusercontent.com)|185.199.108.133|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 14402310 (14M) [application/octet-stream]Saving to: ‘arthas-bin.zip’100%[====================================================================================================================================================================================================================================&gt;] 14,402,310  5.22MB/s   in 2.6s   2025-06-07 04:46:29 (5.22 MB/s) - ‘arthas-bin.zip’ saved [14402310/14402310]## 解压缩到指定目录[root@localhost software]# unzip arthas-bin.zip -d /usr/local/software/arthas-binArchive:  arthas-bin.zip   creating: /usr/local/software/arthas-bin/async-profiler/   creating: /usr/local/software/arthas-bin/lib/  inflating: /usr/local/software/arthas-bin/arthas-spy.jar    inflating: /usr/local/software/arthas-bin/arthas-core.jar    inflating: /usr/local/software/arthas-bin/logback.xml    inflating: /usr/local/software/arthas-bin/arthas.properties    inflating: /usr/local/software/arthas-bin/arthas-agent.jar    inflating: /usr/local/software/arthas-bin/arthas-client.jar    inflating: /usr/local/software/arthas-bin/arthas-boot.jar    inflating: /usr/local/software/arthas-bin/math-game.jar    inflating: /usr/local/software/arthas-bin/install-local.sh    inflating: /usr/local/software/arthas-bin/as.sh    inflating: /usr/local/software/arthas-bin/as.bat    inflating: /usr/local/software/arthas-bin/as-service.bat    inflating: /usr/local/software/arthas-bin/async-profiler/libasyncProfiler-linux-arm64.so    inflating: /usr/local/software/arthas-bin/async-profiler/libasyncProfiler-linux-x64.so    inflating: /usr/local/software/arthas-bin/async-profiler/libasyncProfiler-mac.dylib    inflating: /usr/local/software/arthas-bin/lib/libArthasJniLibrary-aarch64.so    inflating: /usr/local/software/arthas-bin/lib/libArthasJniLibrary-x64.dll    inflating: /usr/local/software/arthas-bin/lib/libArthasJniLibrary-x64.so    inflating: /usr/local/software/arthas-bin/lib/libArthasJniLibrary.dyli

2.3 启动Arthas如果没有java进程是启动不了。会看报错信息：Can not find java process. Try to run jps command lists the instrumented Java HotSpot VMs on the target system.Please select an available pid.

执行该程序的用户需要和目标进程具有相同的权限。比如以admin用户来执行：sudo su admin &amp;&amp; java -jar arthas-boot.jar 或 sudo -u admin -EH java -jar arthas-boot.jar。
如果 attach 不上目标进程，可以查看~/logs/arthas/ 目录下的日志。
java -jar arthas-boot.jar -h 打印更多参数信息。

[root@localhost arthas]# java -jar arthas-boot.jar[INFO] JAVA_HOME: /usr/local/software/jdk-11.0.16.1[INFO] arthas-boot version: 4.0.5[INFO] Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.Please select an available pid.[root@localhost arthas]# 


启动 math-game

math-game是一个简单的程序，每隔一秒生成一个随机数，再执行质因数分解，并打印出分解结果。
math-game源代码：查看
[root@localhost arthas]# curl -O https://arthas.aliyun.com/math-game.jar  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100  4510  100  4510    0     0  16208      0 --:--:-- --:--:-- --:--:-- 16223[root@localhost arthas]# java -jar math-game.jar


重新启动 Arthas

启动命令：java -jar arthas-boot.jar。如果不存在arthas则会自动下载arthas相关的包。
java -jar arthas-boot.jar* **[1]: 5167 math-game.jar**

选择应用 java 进程，服务器上只有一个进程，math-game进程是第 1 个，则输入 1，再输入回车/enter。Arthas 会 attach 到目标进程上，并输出日志：
[root@localhost arthas]# java -jar arthas-boot.jar[INFO] JAVA_HOME: /usr/local/software/jdk-11.0.16.1[INFO] arthas-boot version: 4.0.5[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.* **[1]: 5167 math-game.jar**1[INFO] Start download arthas from remote server: https://arthas.aliyun.com/download/4.0.5?mirror=center[INFO] File size: 13.75 MB, downloaded size: 424.56 KB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 1.33 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 2.12 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 2.88 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 3.72 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 4.77 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 5.71 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 6.52 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 7.56 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 8.44 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 9.51 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 10.41 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 11.43 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 12.08 MB, downloading ...[INFO] File size: 13.75 MB, downloaded size: 12.90 MB, downloading ...[INFO] Download arthas success.[INFO] arthas home: /root/.arthas/lib/4.0.5/arthas[INFO] Try to attach process 5167Picked up JAVA_TOOL_OPTIONS: [INFO] Attach process 5167 success.[INFO] arthas-client connect 127.0.0.1 3658  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                            /  O  \ |  .--. &#x27;&#x27;--.  .--&#x27;|  &#x27;--&#x27;  | /  O  \ &#x27;   .-&#x27;                          |  .-.  ||  &#x27;--&#x27;.&#x27;   |  |   |  .--.  ||  .-.  |`.  `-.                          |  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-&#x27;    |                         `--&#x27; `--&#x27;`--&#x27; &#x27;--&#x27;   `--&#x27;   `--&#x27;  `--&#x27;`--&#x27; `--&#x27;`-----&#x27;                          wiki        https://arthas.aliyun.com/doc                                       tutorials   https://arthas.aliyun.com/doc/arthas-tutorials.html                 version     4.0.5                                                               main_class  math-game.jar                                                       pid         5167                                                                start_time  2025-06-06 05:55:57.044                                             currnt_time 2025-06-06 05:56:41.167   

2.4 卸载Arthas在线安装 删除目录
[root@localhost arthas]# rm -rf ~/.arthas/[root@localhost arthas]# rm -rf ~/logs/arthas*

离线安装 删除&#x2F;usr&#x2F;local&#x2F;software&#x2F;arthas-bin目录
[root@localhost arthas]# rm -rf /usr/local/software/arthas-bin]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>Arthas诊断工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas诊断工具(七)Arthas（阿尔萨斯）profiler命令生成火焰图</title>
    <url>/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E4%B8%83)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89profiler%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E7%81%AB%E7%84%B0%E5%9B%BE/</url>
    <content><![CDATA[Arthas诊断工具(七)Arthas（阿尔萨斯）profiler命令生成火焰图1. profiler命令profiler 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。
profiler 命令基本运行结构是 profiler action [actionArg]
profiler 命令的格式基本与上游项目 async-profiler在新窗口打开 保持一致，详细的使用方式可参考上游项目的 README、Github Disscussions 以及其他文档资料

💡

使用async-profiler在新窗口打开生成火焰图



参数说明




参数名称
参数说明



action
要执行的操作


actionArg
属性名模式


[i:]
采样间隔（单位：ns）（默认值：10’000’000，即 10 ms）


[f:]
将输出转储到指定路径


[d:]
运行评测指定秒


[e:]
要跟踪哪个事件（cpu, alloc, lock, cache-misses 等），默认是 cpu


2. 启动 profiler 命令
💡

默认情况下，生成的是 cpu 的火焰图，即 event 为cpu。可以用--event参数指定其他性能分析模式，见下文


[arthas@8161]$ profiler startProfiling started

3. 获取已采集的 sample 的数量[arthas@8161]$ profiler getSamples 34

4. 查看 profiling 状态[arthas@8161]$ profiler statusProfiling is running for 230 seconds

5. 查看 profiler 自身的内存占用[arthas@8161]$ profiler meminfo Call trace storage:   10244 KB  Flight recording:       0 KB      Dictionaries:      72 KB        Code cache:   12685 KB------------------------------             Total:   23001 KB

6. 停止 profiler
生成火焰图格式结果

默认情况下，结果是 Flame Graph在新窗口打开 格式的 html 文件，也可以用 -o 或 --format 参数指定其他内容格式，包括 flat、traces、collapsed、flamegraph、tree、jfr。
## 停止采集数据，并生成火焰图[arthas@8161]$ profiler stop --format flamegraphOKprofiler output file: /usr/local/software/arthas/arthas-output/20250607-110904.html## 退出arthas[arthas@8161]$ stopResetting all enhanced classes ...Affect(class count: 1 , method count: 0) cost in 74 ms, listenerId: 0Arthas Server is going to shutdown...[arthas@8161]$ session (95b458b7-9c4b-4201-a619-de2dae2e85a7) is closed because server is going to shutdown.## 下载火焰图[root@localhost arthas]# sz /usr/local/software/arthas/arthas-output/20250607-110904.html




arthas 火焰图颜色说明：
绿色： java 代码
黄色： jvm c++ 代码
红色： 用户态 c 代码
橙色： 内核态 c 代码


arthas 火焰图x-y轴
x轴代表的不是时间，而是采样总量
y轴代表方法的调用栈深度，倘若方法调用得越多，火焰越高，顶部的栈就是当前正在执行的方法


栈宽含义（CPU时间）
宽度可以理解为CPU采样率的占比，越宽代表当前栈在采样数中占比高，其可能为三种含义 该函数运行时间长 该函数被调用次数多


平顶现象（一定要格外注意）
平顶现象是由于当前程序的采样数在总采样数中占用过高导致的，出现这种现象需要特意关注一下程序具体的调用栈，采样比例占用率过高，即代表方法在CPU中的占用率过高



总结：
火焰图只是用于辅助程序分析定位问题，查看程序在采样期间的大致情况，实际场景还需结合CPU占用率、查看JVM的DUMP快照等方式进行定位

火焰图的顶部代表CPU消耗最高的方法，越往下方法的消耗越低。宽度过宽的方法表示其被调用频繁或自身执行时间长，是性能瓶颈的候选点。
通过观察火焰图，你可以识别出哪些方法占用CPU最多，进而针对性地优化这些“热点”方法，提升程序性能。

7. profiler 支持的 events在不同的平台，不同的 OS 下面，支持的 events 各有不同。比如在 centos下面：
[arthas@8161]$ profiler listBasic events:  cpu  alloc  nativemem  lock  wall  itimer  ctimerJava method calls:  ClassName.methodNamePerf events:  cpu-clock  page-faults  context-switches  cycles  instructions  cache-references  cache-misses  branch-instructions  branch-misses  bus-cycles  L1-dcache-load-misses  LLC-load-misses  dTLB-load-misses  rNNN  pmu/event-descriptor/  mem:breakpoint  trace:tracepoint  kprobe:func  uprobe:path]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>Arthas诊断工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas诊断工具(三)Arthas（阿尔萨斯）JVM相关命令</title>
    <url>/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E4%B8%89)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89JVM%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[Arthas诊断工具(三)Arthas（阿尔萨斯）JVM相关命令1. jvm命令查看当前 JVM 信息
[arthas@5167]$ jvm RUNTIME                                                                                                                                                                                                                                                                      ------------------------------------------------------------------------------------------------------------------------------------------------ MACHINE-NAME                                                                 5167@localhost.localdomain                                         JVM-START-TIME                                                               2025-06-06 05:55:57                                                MANAGEMENT-SPEC-VERSION                                                      2.0                                                                SPEC-NAME                                                                    Java Virtual Machine Specification                                 SPEC-VENDOR                                                                  Oracle Corporation                                                 SPEC-VERSION                                                                 11                                                                 VM-NAME                                                                      Java HotSpot(TM) 64-Bit Server VM                                  VM-VENDOR                                                                    Oracle Corporation                                                 VM-VERSION                                                                   11.0.16.1+1-LTS-1                                                  INPUT-ARGUMENTS                                                              []                                                                 CLASS-PATH                                                                   math-game.jar                                                      BOOT-CLASS-PATH                                                                                                                                 LIBRARY-PATH                                                                 /usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib                                                                                                                                                            ------------------------------------------------------------------------------------------------------------------------------------------------ CLASS-LOADING                                                                                                                                  ------------------------------------------------------------------------------------------------------------------------------------------------ LOADED-CLASS-COUNT                                                           6215                                                               TOTAL-LOADED-CLASS-COUNT                                                     6272                                                               UNLOADED-CLASS-COUNT                                                         57                                                                 IS-VERBOSE                                                                   false                                                                                                                                                                                                             ------------------------------------------------------------------------------------------------------------------------------------------------ COMPILATION                                                                                                                                    ------------------------------------------------------------------------------------------------------------------------------------------------ NAME                                                                         HotSpot 64-Bit Tiered Compilers                                    TOTAL-COMPILE-TIME                                                           22523                                                              [time (ms)]                                                                                                                                                                                                                                                                                    ------------------------------------------------------------------------------------------------------------------------------------------------ GARBAGE-COLLECTORS                                                                                                                             ------------------------------------------------------------------------------------------------------------------------------------------------ G1 Young Generation                                                          name : G1 Young Generation                                         [count/time (ms)]                                                            collectionCount : 7                                                                                                                             collectionTime : 182                                               G1 Old Generation                                                            name : G1 Old Generation                                           [count/time (ms)]                                                            collectionCount : 0                                                                                                                             collectionTime : 0                                                                                                                                                                                                ------------------------------------------------------------------------------------------------------------------------------------------------ MEMORY-MANAGERS                                                                                                                                ------------------------------------------------------------------------------------------------------------------------------------------------ CodeCacheManager                                                             CodeHeap &#x27;non-nmethods&#x27;                                                                                                                         CodeHeap &#x27;profiled nmethods&#x27;                                                                                                                    CodeHeap &#x27;non-profiled nmethods&#x27;                                   Metaspace Manager                                                            Metaspace                                                                                                                                       Compressed Class Space                                             G1 Young Generation                                                          G1 Eden Space                                                                                                                                   G1 Survivor Space                                                                                                                               G1 Old Gen                                                         G1 Old Generation                                                            G1 Eden Space                                                                                                                                   G1 Survivor Space                                                                                                                               G1 Old Gen                                                                                                                                                                                                        ------------------------------------------------------------------------------------------------------------------------------------------------ MEMORY                                                                                                                                         ------------------------------------------------------------------------------------------------------------------------------------------------ HEAP-MEMORY-USAGE                                                            init : 130023424(124.0 MiB)                                        [memory in bytes]                                                            used : 40942912(39.0 MiB)                                                                                                                       committed : 130023424(124.0 MiB)                                                                                                                max : 2051014656(1.9 GiB)                                          NO-HEAP-MEMORY-USAGE                                                         init : 7667712(7.3 MiB)                                            [memory in bytes]                                                            used : 60157088(57.4 MiB)                                                                                                                       committed : 63004672(60.1 MiB)                                                                                                                  max : -1(-1 B)                                                     PENDING-FINALIZE-COUNT                                                       0                                                                                                                                                                                                                 ------------------------------------------------------------------------------------------------------------------------------------------------ OPERATING-SYSTEM                                                                                                                               ------------------------------------------------------------------------------------------------------------------------------------------------ OS                                                                           Linux                                                              ARCH                                                                         amd64                                                              PROCESSORS-COUNT                                                             4                                                                  LOAD-AVERAGE                                                                 0.0                                                                VERSION                                                                      3.10.0-957.el7.x86_64                                                                                                                                                                                             ------------------------------------------------------------------------------------------------------------------------------------------------ THREAD                                                                                                                                         ------------------------------------------------------------------------------------------------------------------------------------------------ COUNT                                                                        20                                                                 DAEMON-COUNT                                                                 19                                                                 PEAK-COUNT                                                                   20                                                                 STARTED-COUNT                                                                27                                                                 DEADLOCK-COUNT                                                               0                                                                                                                                                                                                                 ------------------------------------------------------------------------------------------------------------------------------------------------ FILE-DESCRIPTOR                                                                                                                                ------------------------------------------------------------------------------------------------------------------------------------------------ MAX-FILE-DESCRIPTOR-COUNT                                                    -1                                                                 OPEN-FILE-DESCRIPTOR-COUNT                                                   -1                                                                


THREAD 相关
COUNT: JVM 当前活跃的线程数
DAEMON-COUNT: JVM 当前活跃的守护线程数
PEAK-COUNT: 从 JVM 启动开始曾经活着的最大线程数
STARTED-COUNT: 从 JVM 启动开始总共启动过的线程次数
DEADLOCK-COUNT: JVM 当前死锁的线程数


文件描述符相关
MAX-FILE-DESCRIPTOR-COUNT：JVM 进程最大可以打开的文件描述符数
OPEN-FILE-DESCRIPTOR-COUNT：JVM 当前打开的文件描述符数



2. sysprop 命令查看当前 JVM 的系统属性(System Property)
[arthas@5167]$ sysprop  KEY                                                   VALUE                                                                                                                                                                                                                  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ awt.toolkit                                           sun.awt.X11.XToolkit                                                                                                                                                                                                    java.specification.version                            11                                                                                                                                                                                                                      sun.cpu.isalist                                                                                                                                                                                                                                                               sun.jnu.encoding                                      UTF-8                                                                                                                                                                                                                   java.class.path                                       math-game.jar                                                                                                                                                                                                           java.vm.vendor                                        Oracle Corporation                                                                                                                                                                                                      sun.arch.data.model                                   64                                                                                                                                                                                                                      java.vendor.url                                       https://openjdk.java.net/                                                                                                                                                                                               user.timezone                                         America/New_York                                                                                                                                                                                                        os.name                                               Linux                                                                                                                                                                                                                   java.vm.specification.version                         11                                                                                                                                                                                                                      sun.java.launcher                                     SUN_STANDARD                                                                                                                                                                                                            user.country                                          US                                                                                                                                                                                                                      sun.boot.library.path                                 /usr/local/software/jdk-11.0.16.1/lib                                                                                                                                                                                   sun.java.command                                      math-game.jar                                                                                                                                                                                                           jdk.debug                                             release                                                                                                                                                                                                                 sun.cpu.endian                                        little                                                                                                                                                                                                                  user.home                                             /root                                                                                                                                                                                                                   user.language                                         en                                                                                                                                                                                                                      java.specification.vendor                             Oracle Corporation                                                                                                                                                                                                      java.version.date                                     2022-08-18                                                                                                                                                                                                              java.home                                             /usr/local/software/jdk-11.0.16.1                                                                                                                                                                                       file.separator                                        /                                                                                                                                                                                                                       java.vm.compressedOopsMode                            32-bit                                                                                                                                                                                                                  line.separator                                                                                                                                                                                                                                                                java.specification.name                               Java Platform API Specification                                                                                                                                                                                         java.vm.specification.vendor                          Oracle Corporation                                                                                                                                                                                                      java.awt.graphicsenv                                  sun.awt.X11GraphicsEnvironment                                                                                                                                                                                          sun.management.compiler                               HotSpot 64-Bit Tiered Compilers                                                                                                                                                                                         java.runtime.version                                  11.0.16.1+1-LTS-1                                                                                                                                                                                                       user.name                                             root                                                                                                                                                                                                                    path.separator                                        :                                                                                                                                                                                                                       os.version                                            3.10.0-957.el7.x86_64                                                                                                                                                                                                   java.runtime.name                                     Java(TM) SE Runtime Environment                                                                                                                                                                                         file.encoding                                         UTF-8                                                                                                                                                                                                                   java.vm.name                                          Java HotSpot(TM) 64-Bit Server VM                                                                                                                                                                                       java.vendor.version                                   18.9                                                                                                                                                                                                                    java.vendor.url.bug                                   https://bugreport.java.com/bugreport/                                                                                                                                                                                   java.io.tmpdir                                        /tmp                                                                                                                                                                                                                    java.version                                          11.0.16.1                                                                                                                                                                                                               user.dir                                              /usr/local/software/arthas                                                                                                                                                                                              os.arch                                               amd64                                                                                                                                                                                                                   java.vm.specification.name                            Java Virtual Machine Specification                                                                                                                                                                                      java.awt.printerjob                                   sun.print.PSPrinterJob                                                                                                                                                                                                  sun.os.patch.level                                    unknown                                                                                                                                                                                                                 java.library.path                                     /usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib                                                                                                                                                                  java.vendor                                           Oracle Corporation                                                                                                                                                                                                      java.vm.info                                          mixed mode                                                                                                                                                                                                              java.vm.version                                       11.0.16.1+1-LTS-1                                                                                                                                                                                                       sun.io.unicode.encoding                               UnicodeLittle                                                                                                                                                                                                           java.class.version                                    55.0  


查看某一个系统属性

[arthas@5167]$ sysprop file.encoding KEY                                                   VALUE                                                                                                                                                                                                                  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ file.encoding                                         UTF-8                                                                                                                                                                                                                  [arthas@5167]$ 


修改某一个属性

[arthas@5167]$ sysprop production.mode trueSuccessfully changed the system property. KEY                                                   VALUE                                                                                                                                                                                                                  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ production.mode                                       true                                                                                                                                                                                                                   

3. sysprop 命令查看当前 JVM 的系统属性(System Property)
[arthas@7339]$ sysenv  KEY                                                   VALUE                                                                                                                                                                                                                  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ CLASSPATH                                             .:/usr/local/software/jdk-11.0.16.1/lib/dt.jar:/usr/local/software/jdk-11.0.16.1/lib/tools.jar                                                                                                                          HISTCONTROL                                           ignoredups                                                                                                                                                                                                              HISTSIZE                                              1000                                                                                                                                                                                                                    HOME                                                  /root                                                                                                                                                                                                                   HOSTNAME                                              localhost.localdomain                                                                                                                                                                                                   JAVA_HOME                                             /usr/local/software/jdk-11.0.16.1                                                                                                                                                                                       LANG                                                  en_US.UTF-8                                                                                                                                                                                                             LESSOPEN                                              ||/usr/bin/lesspipe.sh %s                                                                                                                                                                                               LOGNAME                                               root                                                                                                                                                                                                                    LS_COLORS                                             rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01                                                        ;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*                                                        .bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*                                                        .cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01                                                        ;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.fl                                                        c=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mi                                                        d=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:                                                                           MAIL                                                  /var/spool/mail/root                                                                                                                                                                                                    OLDPWD                                                /usr/local/software                                                                                                                                                                                                     PATH                                                  /usr/local/software/jdk-11.0.16.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin                                                                                                                       PWD                                                   /usr/local/software/arthas                                                                                                                                                                                              SELINUX_LEVEL_REQUESTED                                                                                                                                                                                                                                                       SELINUX_ROLE_REQUESTED                                                                                                                                                                                                                                                        SELINUX_USE_CURRENT_RANGE                                                                                                                                                                                                                                                     SHELL                                                 /bin/bash                                                                                                                                                                                                               SHLVL                                                 1                                                                                                                                                                                                                       SSH_CLIENT                                            192.168.3.74 2421 22                                                                                                                                                                                                    SSH_CONNECTION                                        192.168.3.74 2421 192.168.3.125 22                                                                                                                                                                                      SSH_TTY                                               /dev/pts/2                                                                                                                                                                                                              TERM                                                  xterm                                                                                                                                                                                                                   USER                                                  root                                                                                                                                                                                                                    XDG_RUNTIME_DIR                                       /run/user/0                                                                                                                                                                                                             XDG_SESSION_ID                                        25                                                                                                                                                                                                                      _                                                     /usr/local/software/jdk-11.0.16.1/bin/java 


查看单个环境变量

sysenv JAVA_HOME
[arthas@7339]$ sysenv JAVA_HOME KEY                                                   VALUE                                                                                                                                                                                                                  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ JAVA_HOME                                             /usr/local/software/jdk-11.0.16.1 

4. vmoption命令查看，更新 VM 诊断相关的参数
[arthas@7339]$ vmoption  KEY                                                                 VALUE                                                              ORIGIN                                                              WRITEABLE                                                         ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ HeapDumpBeforeFullGC                                                false                                                              DEFAULT                                                             true                                                               HeapDumpAfterFullGC                                                 false                                                              DEFAULT                                                             true                                                               HeapDumpOnOutOfMemoryError                                          false                                                              DEFAULT                                                             true                                                               HeapDumpPath                                                                                                                           DEFAULT                                                             true                                                               PrintClassHistogram                                                 false                                                              DEFAULT                                                             true                                                               MinHeapFreeRatio                                                    40                                                                 DEFAULT                                                             true                                                               MaxHeapFreeRatio                                                    70                                                                 DEFAULT                                                             true                                                               PrintConcurrentLocks                                                false                                                              DEFAULT                                                             true                                                               CMSAbortablePrecleanWaitMillis                                      100                                                                DEFAULT                                                             true                                                               CMSWaitDuration                                                     2000                                                               DEFAULT                                                             true                                                               CMSTriggerInterval                                                  -1                                                                 DEFAULT                                                             true                                                              


更新指定的 option

[arthas@7339]$ vmoption HeapDumpBeforeFullGC trueSuccessfully updated the vm option. NAME                  BEFORE-VALUE  AFTER-VALUE                                                                                                                                                                                                                              -------------------------------------------------                                                                                                                                                                                                                              HeapDumpBeforeFullGC  false         true   

5. getstatic 命令通过 getstatic 命令可以方便的查看类的静态属性。使用方法为getstatic class_name field_name
[arthas@7339]$ getstatic demo.MathGame randomfield: random@Random[    serialVersionUID=@Long[3905348978240129619],    seed=@AtomicLong[279863952692122],    multiplier=@Long[25214903917],    addend=@Long[11],    mask=@Long[281474976710655],    DOUBLE_UNIT=@Double[1.1102230246251565E-16],    BadBound=@String[bound must be positive],    BadRange=@String[bound must be greater than origin],    BadSize=@String[size must be non-negative],    seedUniquifier=@AtomicLong[-2942033378085796212],    nextNextGaussian=@Double[0.0],    haveNextNextGaussian=@Boolean[false],    serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3],    unsafe=@Unsafe[jdk.internal.misc.Unsafe@1004ff20],    seedOffset=@Long[24],]Affect(row-cnt:1) cost in 29 ms.

6. ognl命令执行 ognl 表达式，从 3.0.5 版本增加

参数说明




参数名称
参数说明



express
执行的表达式


[c:]
执行表达式的 ClassLoader 的 hashcode，默认值是 SystemClassLoader


[classLoaderClass:]
指定执行表达式的 ClassLoader 的 class name


[x]
结果对象的展开层次，默认值 1



使用参考
OGNL 特殊用法请参考：https://github.com/alibaba/arthas/issues/71
OGNL 表达式官方指南：https://commons.apache.org/dormant/commons-ognl/language-guide.html

举例：
## java.lang.System.out.printlnn(&quot;hello&quot;) 方法没有返回值[arthas@7339]$ ognl &#x27;@java.lang.System@out.println(&quot;hello&quot;)&#x27;null## java.lang.System.currentTimeMillis()返回值为Long类型[arthas@7339]$ ognl &#x27;@java.lang.System@currentTimeMillis()&#x27;@Long[1749270125080]## 获取静态变量属性[arthas@7339]$ ognl &#x27;@demo.MathGame@random&#x27;@Random[    serialVersionUID=@Long[3905348978240129619],    seed=@AtomicLong[66121191540312],    multiplier=@Long[25214903917],    addend=@Long[11],    mask=@Long[281474976710655],    DOUBLE_UNIT=@Double[1.1102230246251565E-16],    BadBound=@String[bound must be positive],    BadRange=@String[bound must be greater than origin],    BadSize=@String[size must be non-negative],    seedUniquifier=@AtomicLong[-2942033378085796212],    nextNextGaussian=@Double[0.0],    haveNextNextGaussian=@Boolean[false],    serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3],    unsafe=@Unsafe[jdk.internal.misc.Unsafe@1004ff20],    seedOffset=@Long[24],]## 获取JVM环境变量中的属性值，把获取到的结果，分别赋值给value1,value2。最后再将value1&amp;value2的值放入ArrayList集中，最后打印ArrayList结果。[arthas@7339]$ ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;@ArrayList[    @String[/usr/local/software/jdk-11.0.16.1],    @String[Java(TM) SE Runtime Environment],]]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>Arthas诊断工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas诊断工具(一)Arthas（阿尔萨斯）快速入门</title>
    <url>/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E4%BA%8C)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[Arthas诊断工具(二)Arthas（阿尔萨斯）常用命令1. dashboard命令1.1 数据说明
ID: Java 级别的线程 ID，注意这个 ID 不能跟 jstack 中的 nativeID 一一对应。
NAME: 线程名
GROUP: 线程组名
PRIORITY: 线程优先级, 1~10 之间的数字，越大表示优先级越高
STATE: 线程的状态
CPU%: 线程的 cpu 使用率。比如采样间隔 1000ms，某个线程的增量 cpu 时间为 100ms，则 cpu 使用率&#x3D;100&#x2F;1000&#x3D;10%
DELTA_TIME: 上次采样之后线程运行增量 CPU 时间，数据格式为秒
TIME: 线程运行总 CPU 时间，数据格式为分:秒
INTERRUPTED: 线程当前的中断位状态
DAEMON: 是否是 daemon 线程

1.2 JVM 内部线程Java 8 之后支持获取 JVM 内部线程 CPU 时间，这些线程只有名称和 CPU 时间，没有 ID 及状态等信息（显示 ID 为-1）。 通过内部线程可以观测到 JVM 活动，如 GC、JIT 编译等占用 CPU 情况，方便了解 JVM 整体运行状况。

当 JVM 堆(heap)&#x2F;元数据(metaspace)空间不足或 OOM 时，可以看到 GC 线程的 CPU 占用率明显高于其他的线程。
当执行trace/watch/tt/redefine等命令后，可以看到 JIT 线程活动变得更频繁。因为 JVM 热更新 class 字节码时清除了此 class 相关的 JIT 编译结果，需要重新编译。

JVM 内部线程包括下面几种：

JIT 编译线程: 如 C1 CompilerThread0, C2 CompilerThread0
GC 线程: 如GC Thread0, G1 Young RemSet Sampling
其它内部线程: 如VM Periodic Task Thread, VM Thread, Service Thread


2. thread 命令通过 thread 命令来获取到math-game进程的 Main Class。thread 1会打印线程 ID 1 的栈，通常是 main 函数的线程。
[arthas@5167]$ **thread** Threads Total: 30, NEW: 0, RUNNABLE: 12, BLOCKED: 0, WAITING: 2, TIMED_WAITING: 4, TERMINATED: 0, Internal threads: 12                                                                                                                                                        ID         NAME                                                                GROUP                             PRIORITY              STATE                  %CPU                  DELTA_TIME             TIME                  INTERRUPTED            DAEMON                -1         C1 CompilerThread0                                                  -                                 -1                    -                      0.26                  0.000                  0:3.219               false                  true                  24         arthas-command-execute                                              system                            5                     RUNNABLE               0.15                  0.000                  0:0.016               false                  true                  -1         VM Periodic Task Thread                                             -                                 -1                    -                      0.05                  0.000                  0:3.005               false                  true                  -1         GC Thread#1                                                         -                                 -1                    -                      0.03                  0.000                  0:0.405               false                  true                  -1         VM Thread                                                           -                                 -1                    -                      0.03                  0.000                  0:0.487               false                  true                  -1         GC Thread#0                                                         -                                 -1                    -                      0.03                  0.000                  0:0.409               false                  true                  -1         G1 Young RemSet Sampling                                            -                                 -1                    -                      0.02                  0.000                  0:0.879               false                  true                  -1         C2 CompilerThread0                                                  -                                 -1                    -                      0.0                   0.000                  0:5.703               false                  true                  2          Reference Handler                                                   system                            10                    RUNNABLE               0.0                   0.000                  0:0.001               false                  true                  3          Finalizer                                                           system                            8                     WAITING                0.0                   0.000                  0:0.000               false                  true                  4          Signal Dispatcher                                                   system                            9                     RUNNABLE               0.0                   0.000                  0:0.003               false                  true                  11         Attach Listener                                                     system                            9                     RUNNABLE               0.0                   0.000                  0:0.119               false                  true                  13         arthas-timer                                                        system                            9                     WAITING                0.0                   0.000                  0:0.000               false                  true                  16         arthas-NettyHttpTelnetBootstrap-3-1                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.040               false                  true                  17         arthas-NettyWebsocketTtyBootstrap-4-1                               system                            5                     RUNNABLE               0.0                   0.000                  0:0.000               false                  true                  18         arthas-NettyWebsocketTtyBootstrap-4-2                               system                            5                     RUNNABLE               0.0                   0.000                  0:0.001               false                  true                  19         arthas-shell-server                                                 system                            9                     TIMED_WAITING          0.0                   0.000                  0:0.020               false                  true                  20         arthas-session-manager                                              system                            9                     TIMED_WAITING          0.0                   0.000                  0:0.009               false                  true                  22         arthas-NettyHttpTelnetBootstrap-3-2                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.337               false                  true                  23         arthas-NettyHttpTelnetBootstrap-3-3                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.029               false                  true                  25         arthas-NettyHttpTelnetBootstrap-3-4                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.025               false                  true                  26         arthas-NettyHttpTelnetBootstrap-3-5                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.027               false                  true                  27         arthas-NettyHttpTelnetBootstrap-3-6                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.500               false                  true                  1          main                                                                main                              5                     TIMED_WAITING          0.0                   0.000                  0:1.265               false                  false                 10         Common-Cleaner                                                      InnocuousThreadGroup              8                     TIMED_WAITING          0.0                   0.000                  0:0.005               false                  true                  -1         Sweeper thread                                                      -                                 -1                    -                      0.0                   0.000                  0:0.000               false                  true                  -1         G1 Conc#0                                                           -                                 -1                    -                      0.0                   0.000                  0:0.012               false                  true                  -1         G1 Refine#0                                                         -                                 -1                    -                      0.0                   0.000                  0:0.003               false                  true                  -1         G1 Main Marker                                                      -                                 -1                    -                      0.0                   0.000                  0:0.000               false                  true                  -1         Service Thread                                                      -                                 -1                    -                      0.0                   0.000                  0:0.000               false                  true                                                                                                                                                                                                                                                                                                [arthas@5167]$ **thread 1**&quot;main&quot; Id=1 TIMED_WAITING    at java.base@11.0.16.1/java.lang.Thread.sleep(Native Method)    at java.base@11.0.16.1/java.lang.Thread.sleep(Thread.java:339)    at java.base@11.0.16.1/java.util.concurrent.TimeUnit.sleep(TimeUnit.java:446)    at app//demo.MathGame.main(MathGame.java:17)


支持一键展示当前最忙的前 N 个线程并打印堆栈：

[arthas@5167]$ thread -n 3&quot;arthas-command-execute&quot; Id=24 cpuUsage=0.31% deltaTime=0ms time=1521ms RUNNABLE    at java.management@11.0.16.1/sun.management.ThreadImpl.dumpThreads0(Native Method)    at java.management@11.0.16.1/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:485)    at com.taobao.arthas.core.command.monitor200.ThreadCommand.processTopBusyThreads(ThreadCommand.java:206)    at com.taobao.arthas.core.command.monitor200.ThreadCommand.process(ThreadCommand.java:122)    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.process(AnnotatedCommandImpl.java:82)    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.access$100(AnnotatedCommandImpl.java:18)    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:111)    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:108)    at com.taobao.arthas.core.shell.system.impl.ProcessImpl$CommandProcessTask.run(ProcessImpl.java:385)    at java.base@11.0.16.1/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)    at java.base@11.0.16.1/java.util.concurrent.FutureTask.run(FutureTask.java:264)    at java.base@11.0.16.1/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)    at java.base@11.0.16.1/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)    at java.base@11.0.16.1/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)    at java.base@11.0.16.1/java.lang.Thread.run(Thread.java:834)


thread -b, 找出当前阻塞其他线程的线程

有时候我们发现应用卡住了， 通常是由于某个线程拿住了某个锁， 并且其他线程都在等待这把锁造成的。 为了排查这类问题， arthas 提供了thread -b， 一键找出那个罪魁祸首。
[arthas@5167]$ thread -bNo most blocking thread found!


thread -i, 指定采样时间间隔
thread -i 1000 : 统计最近 1000ms 内的线程 CPU 时间。

[arthas@5167]$ thread -i 1000Threads Total: 32, NEW: 0, RUNNABLE: 14, BLOCKED: 0, WAITING: 2, TIMED_WAITING: 4, TERMINATED: 0, Internal threads: 12                                                                                                                                                        ID         NAME                                                                GROUP                             PRIORITY              STATE                  %CPU                  DELTA_TIME             TIME                  INTERRUPTED            DAEMON                -1         VM Periodic Task Thread                                             -                                 -1                    -                      0.08                  0.000                  0:29.457              false                  true                  -1         C1 CompilerThread0                                                  -                                 -1                    -                      0.04                  0.000                  0:6.510               false                  true                  24         arthas-command-execute                                              system                            5                     RUNNABLE               0.02                  0.000                  0:1.580               false                  true                  -1         G1 Young RemSet Sampling                                            -                                 -1                    -                      0.02                  0.000                  0:10.490              false                  true                  1          main                                                                main                              5                     TIMED_WAITING          0.01                  0.000                  0:9.671               false                  false                 -1         VM Thread                                                           -                                 -1                    -                      0.01                  0.000                  0:5.414               false                  true                  -1         GC Thread#1                                                         -                                 -1                    -                      0.01                  0.000                  0:3.250               false                  true                  -1         GC Thread#0                                                         -                                 -1                    -                      0.0                   0.000                  0:3.276               false                  true                  2          Reference Handler                                                   system                            10                    RUNNABLE               0.0                   0.000                  0:0.002               false                  true                  3          Finalizer                                                           system                            8                     WAITING                0.0                   0.000                  0:0.000               false                  true                  4          Signal Dispatcher                                                   system                            9                     RUNNABLE               0.0                   0.000                  0:0.003               false                  true                  11         Attach Listener                                                     system                            9                     RUNNABLE               0.0                   0.000                  0:0.119               false                  true                  13         arthas-timer                                                        system                            9                     WAITING                0.0                   0.000                  0:0.000               false                  true                  16         arthas-NettyHttpTelnetBootstrap-3-1                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.042               false                  true                  17         arthas-NettyWebsocketTtyBootstrap-4-1                               system                            5                     RUNNABLE               0.0                   0.000                  0:0.000               false                  true                  18         arthas-NettyWebsocketTtyBootstrap-4-2                               system                            5                     RUNNABLE               0.0                   0.000                  0:0.001               false                  true                  19         arthas-shell-server                                                 system                            9                     TIMED_WAITING          0.0                   0.000                  0:0.106               false                  true                  20         arthas-session-manager                                              system                            9                     TIMED_WAITING          0.0                   0.000                  0:0.072               false                  true                  22         arthas-NettyHttpTelnetBootstrap-3-2                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.337               false                  true                  23         arthas-NettyHttpTelnetBootstrap-3-3                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.029               false                  true                  25         arthas-NettyHttpTelnetBootstrap-3-4                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.025               false                  true                  26         arthas-NettyHttpTelnetBootstrap-3-5                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.027               false                  true                  27         arthas-NettyHttpTelnetBootstrap-3-6                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.572               false                  true                  33         arthas-NettyHttpTelnetBootstrap-3-7                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.022               false                  true                  34         arthas-NettyHttpTelnetBootstrap-3-8                                 system                            5                     RUNNABLE               0.0                   0.000                  0:0.674               false                  true                  10         Common-Cleaner                                                      InnocuousThreadGroup              8                     TIMED_WAITING          0.0                   0.000                  0:0.044               false                  true                  -1         Sweeper thread                                                      -                                 -1                    -                      0.0                   0.000                  0:0.008               false                  true                  -1         G1 Conc#0                                                           -                                 -1                    -                      0.0                   0.000                  0:0.066               false                  true                  -1         G1 Refine#0                                                         -                                 -1                    -                      0.0                   0.000                  0:0.005               false                  true                  -1         C2 CompilerThread0                                                  -                                 -1                    -                      0.0                   0.000                  0:15.009              false                  true                  -1         G1 Main Marker                                                      -                                 -1                    -                      0.0                   0.000                  0:0.001               false                  true                  -1         Service Thread                                                      -                                 -1                    -                      0.0                   0.000                  0:0.000               false                  true  


thread -n 3 -i 100 : 列出 100ms 内最忙的 3 个线程栈

[arthas@5167]$ thread -n 3 -i 100&quot;arthas-command-execute&quot; Id=24 cpuUsage=0.26% deltaTime=0ms time=1585ms RUNNABLE    at java.management@11.0.16.1/sun.management.ThreadImpl.dumpThreads0(Native Method)    at java.management@11.0.16.1/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:485)    at com.taobao.arthas.core.command.monitor200.ThreadCommand.processTopBusyThreads(ThreadCommand.java:206)    at com.taobao.arthas.core.command.monitor200.ThreadCommand.process(ThreadCommand.java:122)    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.process(AnnotatedCommandImpl.java:82)    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.access$100(AnnotatedCommandImpl.java:18)    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:111)    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:108)    at com.taobao.arthas.core.shell.system.impl.ProcessImpl$CommandProcessTask.run(ProcessImpl.java:385)    at java.base@11.0.16.1/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)    at java.base@11.0.16.1/java.util.concurrent.FutureTask.run(FutureTask.java:264)    at java.base@11.0.16.1/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)    at java.base@11.0.16.1/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)    at java.base@11.0.16.1/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)    at java.base@11.0.16.1/java.lang.Thread.run(Thread.java:834)


thread –state ，查看指定状态的线程

[arthas@5167]$ thread --state WAITINGThreads Total: 20, NEW: 0, RUNNABLE: 14, BLOCKED: 0, WAITING: 2, TIMED_WAITING: 4, TERMINATED: 0                                                                                                                                                                              ID         NAME                                                                GROUP                             PRIORITY              STATE                  %CPU                  DELTA_TIME             TIME                  INTERRUPTED            DAEMON                3          Finalizer                                                           system                            8                     WAITING                0.0                   0.000                  0:0.000               false                  true                  13         arthas-timer                                                        system                            9                     WAITING                0.0                   0.000                  0:0.000               false                  true         

3. watch 命令通过watch命令来查看demo.MathGame#primeFactors函数的返回值：
 watch demo.MathGame primeFactors returnObj 

demo.MathGame 全类名
primeFactors 方法名
返回对象

[arthas@5167]$ watch demo.MathGame primeFactors returnObj Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 204 ms, listenerId: 1method=demo.MathGame.primeFactors location=AtExitts=2025-06-06 10:28:13.587; [cost=4.005634ms] result=@ArrayList[    @Integer[7],    @Integer[11],    @Integer[1301],]method=demo.MathGame.primeFactors location=AtExceptionExitts=2025-06-06 10:28:14.591; [cost=0.129017ms] result=nullmethod=demo.MathGame.primeFactors location=AtExitts=2025-06-06 10:28:15.602; [cost=8.688466ms] result=@ArrayList[    @Integer[2],    @Integer[3],    @Integer[12409],]method=demo.MathGame.primeFactors location=AtExitts=2025-06-06 10:28:16.606; [cost=0.057975ms] result=@ArrayList[    @Integer[2],    @Integer[2],    @Integer[5],    @Integer[23],    @Integer[173],

4.退出 arthas如果只是退出当前的连接，可以用quit或者exit命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。
如果想完全退出 arthas，可以执行stop命令。
5.帮助Help查看命令帮助信息，可以查看当前 arthas 版本支持的指令，或者查看具体指令的使用说明。
[arthas@5167]$ help NAME         DESCRIPTION                                                                                                                                                                                                                                                      help         Display Arthas Help                                                                                                                                                                                                                                              auth         Authenticates the current session                                                                                                                                                                                                                                keymap       Display all the available keymap for the specified connection.                                                                                                                                                                                                   sc           Search all the classes loaded by JVM                                                                                                                                                                                                                             sm           Search the method of classes loaded by JVM                                                                                                                                                                                                                       classloader  Show classloader info                                                                                                                                                                                                                                            jad          Decompile class                                                                                                                                                                                                                                                  getstatic    Show the static field of a class                                                                                                                                                                                                                                 monitor      Monitor method execution statistics, e.g. total/success/failure count, average rt, fail rate, etc.                                                                                                                                                               stack        Display the stack trace for the specified class and method                                                                                                                                                                                                       thread       Display thread info, thread stack                                                                                                                                                                                                                                trace        Trace the execution time of specified method invocation.                                                                                                                                                                                                         watch        Display the input/output parameter, return object, and thrown exception of specified method invocation                                                                                                                                                           tt           Time Tunnel                                                                                                                                                                                                                                                      jvm          Display the target JVM information                                                                                                                                                                                                                               memory       Display jvm memory info.                                                                                                                                                                                                                                         perfcounter  Display the perf counter information.                                                                                                                                                                                                                            ognl         Execute ognl expression.                                                                                                                                                                                                                                         mc           Memory compiler, compiles java files into bytecode and class files in memory.                                                                                                                                                                                    redefine     Redefine classes. @see Instrumentation#redefineClasses(ClassDefinition...)                                                                                                                                                                                       retransform  Retransform classes. @see Instrumentation#retransformClasses(Class...)                                                                                                                                                                                           dashboard    Overview of target jvm&#x27;s thread, memory, gc, vm, tomcat info.                                                                                                                                                                                                    dump         Dump class byte array from JVM                                                                                                                                                                                                                                   heapdump     Heap dump                                                                                                                                                                                                                                                        options      View and change various Arthas options                                                                                                                                                                                                                           cls          Clear the screen                                                                                                                                                                                                                                                 reset        Reset all the enhanced classes                                                                                                                                                                                                                                   version      Display Arthas version                                                                                                                                                                                                                                           session      Display current session information                                                                                                                                                                                                                              sysprop      Display and change the system properties.                                                                                                                                                                                                                        sysenv       Display the system env.                                                                                                                                                                                                                                          vmoption     Display, and update the vm diagnostic options.                                                                                                                                                                                                                   logger       Print logger info, and update the logger level                                                                                                                                                                                                                   history      Display command history                                                                                                                                                                                                                                          cat          Concatenate and print files                                                                                                                                                                                                                                      base64       Encode and decode using Base64 representation                                                                                                                                                                                                                    echo         write arguments to the standard output                                                                                                                                                                                                                           pwd          Return working directory name                                                                                                                                                                                                                                    mbean        Display the mbean information                                                                                                                                                                                                                                    grep         grep command for pipes.                                                                                                                                                                                                                                          tee          tee command for pipes.                                                                                                                                                                                                                                           profiler     Async Profiler. https://github.com/jvm-profiling-tools/async-profiler                                                                                                                                                                                            vmtool       jvm tool                                                                                                                                                                                                                                                         stop         Stop/Shutdown Arthas server and exit the console.                                                                                                                                                                                                                jfr          Java Flight Recorder Command

6.group分组类似传统的grep命令。

过滤包含java关键的数据

## 过滤包含java关键的数据[arthas@5167]$ sysprop | grep java java.specification.version                            11 java.class.path                                       math-game.jar java.vm.vendor                                        Oracle Corporation java.vendor.url                                       https://openjdk.java.net/ java.vm.specification.version                         11 sun.java.launcher                                     SUN_STANDARD sun.java.command                                      math-game.jar java.specification.vendor                             Oracle Corporation java.version.date                                     2022-08-18 java.home                                             /usr/local/software/jdk-11.0.16.1 java.vm.compressedOopsMode                            32-bit java.specification.name                               Java Platform API Specification java.vm.specification.vendor                          Oracle Corporation java.awt.graphicsenv                                  sun.awt.X11GraphicsEnvironment java.runtime.version                                  11.0.16.1+1-LTS-1 java.runtime.name                                     Java(TM) SE Runtime Environment java.vm.name                                          Java HotSpot(TM) 64-Bit Server VM java.vendor.version                                   18.9 java.vendor.url.bug                                   https://bugreport.java.com/bugreport/ java.io.tmpdir                                        /tmp java.version                                          11.0.16.1 java.vm.specification.name                            Java Virtual Machine Specification java.awt.printerjob                                   sun.print.PSPrinterJob java.library.path                                     /usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib java.vendor                                           Oracle Corporation java.vm.info                                          mixed mode java.vm.version                                       11.0.16.1+1-LTS-1 java.class.version                                    55.


过滤包含java关键的数据，并显示出对应的行号

[arthas@5167]$ sysprop | grep java -n4: java.specification.version                            117: java.class.path                                       math-game.jar8: java.vm.vendor                                        Oracle Corporation10: java.vendor.url                                       https://openjdk.java.net/13: java.vm.specification.version                         1114: sun.java.launcher                                     SUN_STANDARD17: sun.java.command                                      math-game.jar22: java.specification.vendor                             Oracle Corporation23: java.version.date                                     2022-08-1824: java.home                                             /usr/local/software/jdk-11.0.16.126: java.vm.compressedOopsMode                            32-bit28: java.specification.name                               Java Platform API Specification29: java.vm.specification.vendor                          Oracle Corporation30: java.awt.graphicsenv                                  sun.awt.X11GraphicsEnvironment32: java.runtime.version                                  11.0.16.1+1-LTS-136: java.runtime.name                                     Java(TM) SE Runtime Environment38: java.vm.name                                          Java HotSpot(TM) 64-Bit Server VM39: java.vendor.version                                   18.940: java.vendor.url.bug                                   https://bugreport.java.com/bugreport/41: java.io.tmpdir                                        /tmp42: java.version                                          11.0.16.145: java.vm.specification.name                            Java Virtual Machine Specification46: java.awt.printerjob                                   sun.print.PSPrinterJob48: java.library.path                                     /usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib49: java.vendor                                           Oracle Corporation50: java.vm.info                                          mixed mode51: java.vm.version                                       11.0.16.1+1-LTS-153: java.class.version                                    55.0


过滤不包含java关键的数据

[arthas@5167]$ sysenv | grep -v JAVA KEY                                                   VALUE                                                                                                                                                                                                                 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ CLASSPATH                                             .:/usr/local/software/jdk-11.0.16.1/lib/dt.jar:/usr/local/software/jdk-11.0.16.1/lib/tools.jar HISTCONTROL                                           ignoredups HISTSIZE                                              1000 HOME                                                  /root HOSTNAME                                              localhost.localdomain LANG                                                  en_US.UTF-8 LESSOPEN                                              ||/usr/bin/lesspipe.sh %s LOGNAME                                               root LS_COLORS                                             rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01                                                       ;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*                                                       .bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*                                                       .cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01                                                       ;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.fl                                                       c=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mi                                                       d=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36: MAIL                                                  /var/spool/mail/root OLDPWD                                                /usr/local/software PATH                                                  /usr/local/software/jdk-11.0.16.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin PWD                                                   /usr/local/software/arthas SELINUX_LEVEL_REQUESTED SELINUX_ROLE_REQUESTED SELINUX_USE_CURRENT_RANGE SHELL                                                 /bin/bash SHLVL                                                 1 SSH_CLIENT                                            192.168.3.74 6122 22 SSH_CONNECTION                                        192.168.3.74 6122 192.168.3.125 22 SSH_TTY                                               /dev/pts/1 TERM                                                  xterm USER                                                  root XDG_RUNTIME_DIR                                       /run/user/0 XDG_SESSION_ID                                        5 _                                                     /usr/local/software/jdk-11.0.16.1/bin/java


使用正则表达式过滤所需要数据

[arthas@5167]$ sysenv | grep -e &quot;(?i)(JAVA|sun)&quot; JAVA_HOME                                             /usr/local/software/jdk-11.0.16.1 _                                                     /usr/local/software/jdk-11.0.16.1/bin/java

7.快捷键映射表keymapkeymap命令输出当前的快捷键映射表：
[arthas@5167]$ keymap Shortcut                                                            Description                                                        Name                                                                                                                                  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &quot;\C-a&quot;                                                              Ctrl + a                                                            beginning-of-line                                                                                                                     &quot;\C-e&quot;                                                              Ctrl + e                                                            end-of-line                                                                                                                           &quot;\C-f&quot;                                                              Ctrl + f                                                            forward-word                                                                                                                          &quot;\C-b&quot;                                                              Ctrl + b                                                            backward-word                                                                                                                         &quot;\e[D&quot;                                                              Left arrow                                                          backward-char                                                                                                                         &quot;\e[C&quot;                                                              Right arrow                                                         forward-char                                                                                                                          &quot;\e[A&quot;                                                              Up arrow                                                            history-search-backward                                                                                                               &quot;\e[B&quot;                                                              Down arrow                                                          history-search-forward                                                                                                                &quot;\C-h&quot;                                                              Ctrl + h                                                            backward-delete-char                                                                                                                  &quot;\C-?&quot;                                                              Ctrl + ?                                                            backward-delete-char                                                                                                                  &quot;\C-u&quot;                                                              Ctrl + u                                                            undo                                                                                                                                  &quot;\C-d&quot;                                                              Ctrl + d                                                            delete-char                                                                                                                           &quot;\C-k&quot;                                                              Ctrl + k                                                            kill-line                                                                                                                             &quot;\C-i&quot;                                                              Ctrl + i                                                            complete                                                                                                                              &quot;\C-j&quot;                                                              Ctrl + j                                                            accept-line                                                                                                                           &quot;\C-m&quot;                                                              Ctrl + m                                                            accept-line                                                                                                                           &quot;\C-w&quot;                                                              Ctrl + w                                                            backward-delete-word                                                                                                                  &quot;\C-x\e[3~&quot;                                                         &quot;\C-x\e[3~&quot;                                                         backward-kill-line                                                                                                                    &quot;\e\C-?&quot;                                                            &quot;\e\C-?&quot;                                                            backward-kill-word                                                                                                                    &quot;\e[1~&quot;                                                             &quot;\e[1~&quot;                                                             beginning-of-line                                                                                                                     &quot;\e[4~&quot;                                                             &quot;\e[4~&quot;                                                             end-of-line                                                                                                                           &quot;\e[5~&quot;                                                             &quot;\e[5~&quot;                                                             beginning-of-history                                                                                                                  &quot;\e[6~&quot;                                                             &quot;\e[6~&quot;                                                             end-of-history                                                                                                                        &quot;\e[3~&quot;                                                             &quot;\e[3~&quot;                                                             delete-char                                                                                                                           &quot;\e[2~&quot;                                                             &quot;\e[2~&quot;                                                             quoted-insert                                                                                                                         &quot;\e[7~&quot;                                                             &quot;\e[7~&quot;                                                             beginning-of-line                                                                                                                     &quot;\e[8~&quot;                                                             &quot;\e[8~&quot;                                                             end-of-line                                                                                                                           &quot;\eOH&quot;                                                              &quot;\eOH&quot;                                                              beginning-of-line                                                                                                                     &quot;\eOF&quot;                                                              &quot;\eOF&quot;                                                              end-of-line                                                                                                                           &quot;\e[H&quot;                                                              &quot;\e[H&quot;                                                              beginning-of-line                                                                                                                     &quot;\e[F&quot;                                                              &quot;\e[F&quot;                                                              end-of-lin

默认的快捷键如下：



快捷键
快捷键说明
命令名称
命令说明



&quot;\C-a&quot;
ctrl + a
beginning-of-line
跳到行首


&quot;\C-e&quot;
ctrl + e
end-of-line
跳到行尾


&quot;\C-f&quot;
ctrl + f
forward-word
向前移动一个单词


&quot;\C-b&quot;
ctrl + b
backward-word
向后移动一个单词


&quot;\e[D&quot;
键盘左方向键
backward-char
光标向前移动一个字符


&quot;\e[C&quot;
键盘右方向键
forward-char
光标向后移动一个字符


&quot;\e[B&quot;
键盘下方向键
next-history
下翻显示下一个命令


&quot;\e[A&quot;
键盘上方向键
previous-history
上翻显示上一个命令


&quot;\C-h&quot;
ctrl + h
backward-delete-char
向后删除一个字符


&quot;\C-?&quot;
ctrl + shift + &#x2F;
backward-delete-char
向后删除一个字符


&quot;\C-u&quot;
ctrl + u
undo
撤销上一个命令，相当于清空当前行


&quot;\C-d&quot;
ctrl + d
delete-char
删除当前光标所在字符


&quot;\C-k&quot;
ctrl + k
kill-line
删除当前光标到行尾的所有字符


&quot;\C-i&quot;
ctrl + i
complete
自动补全，相当于敲TAB


&quot;\C-j&quot;
ctrl + j
accept-line
结束当前行，相当于敲回车


&quot;\C-m&quot;
ctrl + m
accept-line
结束当前行，相当于敲回车


&quot;\C-w&quot;

backward-delete-word



&quot;\C-x\e[3~&quot;

backward-kill-line



&quot;\e\C-?&quot;

backward-kill-word




任何时候 tab 键，会根据当前的输入给出提示
命令后敲  或 - ，然后按 tab 键，可以展示出此命令具体的选项

自定义快捷键
在当前用户目录下新建$USER_HOME/.arthas/conf/inputrc文件，加入自定义配置。
假设我是 vim 的重度用户，我要把ctrl+h设置为光标向前一个字符，则设置如下，首先拷贝默认配置
&quot;\C-a&quot;: beginning-of-line&quot;\C-e&quot;: end-of-line&quot;\C-f&quot;: forward-word&quot;\C-b&quot;: backward-word&quot;\e[D&quot;: backward-char&quot;\e[C&quot;: forward-char&quot;\e[B&quot;: next-history&quot;\e[A&quot;: previous-history&quot;\C-h&quot;: backward-delete-char&quot;\C-?&quot;: backward-delete-char&quot;\C-u&quot;: undo&quot;\C-d&quot;: delete-char&quot;\C-k&quot;: kill-line&quot;\C-i&quot;: complete&quot;\C-j&quot;: accept-line&quot;\C-m&quot;: accept-line&quot;\C-w&quot;: backward-delete-word&quot;\C-x\e[3~&quot;: backward-kill-line&quot;\e\C-?&quot;: backward-kill-word

然后把&quot;\C-h&quot;: backward-delete-char换成&quot;\C-h&quot;: backward-char，然后重新连接即可。
后台异步命令相关快捷键

ctrl + c: 终止当前命令
ctrl + z: 挂起当前命令，后续可以 bg&#x2F;fg 重新支持此命令，或 kill 掉
ctrl + a: 回到行首
ctrl + e: 回到行尾

]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>Arthas诊断工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas诊断工具(五)Arthas（阿尔萨斯）monitor/watch/trace/stack/tt相关命令</title>
    <url>/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E4%BA%94)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89monitor%20watch%20trace%20stack/</url>
    <content><![CDATA[Arthas诊断工具(五)Arthas（阿尔萨斯）monitor&#x2F;watch&#x2F;trace&#x2F;stack&#x2F;tt相关命令1. monitor命令方法执行监控
对匹配 class-pattern／method-pattern／condition-express的类、方法的调用进行监控。
monitor 命令是一个非实时返回命令.
实时返回命令是输入之后立即返回，而非实时返回的命令，则是不断的等待目标 Java 进程返回信息，直到用户输入 Ctrl+C 为止。
服务端是以任务的形式在后台跑任务，植入的代码随着任务的中止而不会被执行，所以任务关闭后，不会对原有性能产生太大影响，而且原则上，任何 Arthas 命令不会引起原有业务逻辑的改变。

参数说明

方法拥有一个命名参数 [c:]，意思是统计周期（cycle of output），拥有一个整型的参数值



参数名称
参数说明



class-pattern
类名表达式匹配


method-pattern
方法名表达式匹配


condition-express
条件表达式


[E]
开启正则表达式匹配，默认为通配符匹配


[c:]
统计周期，默认值为 120 秒


[b]
在方法调用之前计算 condition-express


[m &lt;arg&gt;]
指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch &lt;arg&gt;]



监控的维度说明




监控项
说明



timestamp
时间戳


class
Java 类


method
方法（构造方法、普通方法）


total
调用次数


success
成功次数


fail
失败次数


rt
平均 RT


fail-rate
失败率



监控demo.MathGame primeFactors，每5秒返回一个结果

[arthas@8161]$ monitor demo.MathGame primeFactors -c 5Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 204 ms, listenerId: 1 timestamp                                 class                                                         method                                                        total                success              fail                avg-rt(ms)           fail-rate           ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 2025-06-07 05:32:53.378                   demo.MathGame                                                 primeFactors                                                  5                    1                    4                   3.12                 80.00%               timestamp                                 class                                                         method                                                        total                success              fail                avg-rt(ms)           fail-rate           ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 2025-06-07 05:32:58.441                   demo.MathGame                                                 primeFactors                                                  5                    0                    5                   0.17                 100.00%              timestamp                                 class                                                         method                                                        total                success              fail                avg-rt(ms)           fail-rate           ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 2025-06-07 05:33:02.655                   demo.MathGame                                                 primeFactors                                                  4                    3                    1                   0.16                 25.00%               timestamp                                 class                                                         method                                                        total                success              fail                avg-rt(ms)           fail-rate           ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 2025-06-07 05:33:07.664                   demo.MathGame                                                 primeFactors                                                  5                    2                    3                   0.96                 60.00%              

2. watch命令函数执行数据观测
让你能方便的观察到指定函数的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。

参数说明

watch 的参数比较多，主要是因为它能在 4 个不同的场景观察对象



参数名称
参数说明



class-pattern
类名表达式匹配


method-pattern
函数名表达式匹配


express
观察表达式，默认值：&#123;params, target, returnObj&#125;


condition-express
条件表达式


[b]
在函数调用之前观察


[e]
在函数异常之后观察


[s]
在函数返回之后观察


[f]
在函数结束之后(正常返回和异常返回)观察


[E]
开启正则表达式匹配，默认为通配符匹配


[x:]
指定输出结果的属性遍历深度，默认为 1，最大值是 4


[m &lt;arg&gt;]
指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch &lt;arg&gt;]。


这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写&quot;&#123;params,returnObj&#125;&quot;，只要是一个合法的 ognl 表达式，都能被正常支持。
观察的维度也比较多，主要体现在参数 advice 的数据结构上。Advice 参数最主要是封装了通知节点的所有信息。请参考表达式核心变量中关于该节点的描述。

特殊用法请参考：https://github.com/alibaba/arthas/issues/71
OGNL 表达式官网：https://commons.apache.org/dormant/commons-ognl/language-guide.html

特别说明：

watch 命令定义了 4 个观察事件点，即 b 函数调用前，e 函数异常后，s 函数返回后，f 函数结束后
4 个观察事件点 b、e、s 默认关闭，f 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出
这里要注意函数入参和函数出参的区别，有可能在中间被修改导致前后不一致，除了 b 事件点 params 代表函数入参外，其余事件都代表函数出参
当使用 b 时，由于观察事件点是在函数调用前，此时返回值或异常均不存在
在 watch 命令的结果里，会打印出location信息。location有三种可能值：AtEnter，AtExit，AtExceptionExit。对应函数入口，函数正常 return，函数抛出异常。

2.1 观察函数调用返回时的参数、this 对象和返回值观察表达式，默认值是&#123;params, target, returnObj&#125;
[arthas@8161]$ watch demo.MathGame primeFactors -x 2Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 73 ms, listenerId: 2method=demo.MathGame.primeFactors location=AtExceptionExitts=2025-06-07 05:51:10.663; [cost=1.015159ms] result=@ArrayList[    @Object[][        @Integer[-93162],    ],    @MathGame[        random=@Random[java.util.Random@51efea79],        illegalArgumentCount=@Integer[2327],    ],    null,]method=demo.MathGame.primeFactors location=AtExitts=2025-06-07 05:48:55.377; [cost=0.064295ms] result=@ArrayList[    @Object[][        @Integer[1],    ],    @MathGame[        random=@Random[java.util.Random@51efea79],        illegalArgumentCount=@Integer[2256],    ],    @ArrayList[        @Integer[2],        @Integer[2],        @Integer[2],        @Integer[2],        @Integer[2],        @Integer[2],        @Integer[2],        @Integer[3],        @Integer[13],        @Integer[41],    ],


上面的结果里，说明函数被执行了两次，第一次结果是location=AtExceptionExit，说明函数抛出异常了，因此returnObj是 null
在第二次结果里是location=AtExit，说明函数正常返回，因此可以看到returnObj结果是一个 ArrayList

2.2 调整-x的值，观察具体的函数参数值[arthas@8161]$ watch demo.MathGame primeFactors &quot;&#123;params,target&#125;&quot; -x 3Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 69 ms, listenerId: 4method=demo.MathGame.primeFactors location=AtExceptionExitts=2025-06-07 05:52:36.258; [cost=0.313869ms] result=@ArrayList[    @Object[][        @Integer[-162367],    ],    @MathGame[        random=@Random[            serialVersionUID=@Long[3905348978240129619],            seed=@AtomicLong[175065596875740],            multiplier=@Long[25214903917],            addend=@Long[11],            mask=@Long[281474976710655],            DOUBLE_UNIT=@Double[1.1102230246251565E-16],            BadBound=@String[bound must be positive],            BadRange=@String[bound must be greater than origin],            BadSize=@String[size must be non-negative],            seedUniquifier=@AtomicLong[-2942033378085796212],            nextNextGaussian=@Double[0.0],            haveNextNextGaussian=@Boolean[false],            serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3],            unsafe=@Unsafe[jdk.internal.misc.Unsafe@5419f379],            seedOffset=@Long[24],        ],        illegalArgumentCount=@Integer[2371],    ],]method=demo.MathGame.primeFactors location=AtExitts=2025-06-07 05:52:37.298; [cost=0.214619ms] result=@ArrayList[    @Object[][        @Integer[1],    ],    @MathGame[        random=@Random[            serialVersionUID=@Long[3905348978240129619],            seed=@AtomicLong[102106958650551],            multiplier=@Long[25214903917],            addend=@Long[11],            mask=@Long[281474976710655],            DOUBLE_UNIT=@Double[1.1102230246251565E-16],            BadBound=@String[bound must be positive],            BadRange=@String[bound must be greater than origin],            BadSize=@String[size must be non-negative],            seedUniquifier=@AtomicLong[-2942033378085796212],            nextNextGaussian=@Double[0.0],            haveNextNextGaussian=@Boolean[false],            serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3],            unsafe=@Unsafe[jdk.internal.misc.Unsafe@5419f379],            seedOffset=@Long[24],        ],        illegalArgumentCount=@Integer[2371],    ],]

2.3 条件表达式的例子
只有满足条件的调用，才会有响应。

[arthas@8161]$ watch demo.MathGame primeFactors &quot;&#123;params[0],target&#125;&quot; &quot;params[0]&lt;0&quot;Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 70 ms, listenerId: 5method=demo.MathGame.primeFactors location=AtExceptionExitts=2025-06-07 05:57:45.251; [cost=0.640813ms] result=@ArrayList[    @Integer[-152032],    @MathGame[demo.MathGame@589838eb],]method=demo.MathGame.primeFactors location=AtExceptionExitts=2025-06-07 05:57:49.265; [cost=0.09171ms] result=@ArrayList[    @Integer[-106952],    @MathGame[demo.MathGame@589838eb],]method=demo.MathGame.primeFactors location=AtExceptionExitts=2025-06-07 05:57:50.271; [cost=0.058582ms] result=@ArrayList[    @Integer[-181262],    @MathGame[demo.MathGame@589838eb],]

3. trace命令方法内部调用路径，并输出方法路径上的每个节点上耗时
trace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。

参数说明




参数名称
参数说明



class-pattern
类名表达式匹配


method-pattern
方法名表达式匹配


condition-express
条件表达式


[E]
开启正则表达式匹配，默认为通配符匹配


[n:]
命令执行次数，默认值为 100。


#cost
方法执行耗时，单位毫秒


[m &lt;arg&gt;]
指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch &lt;arg&gt;]。


这里重点要说明的是条件表达式，条件表达式的构成主要由 ognl 表达式组成，所以你可以这样写&quot;params[0]&lt;0&quot;，只要是一个合法的 ognl 表达式，都能被正常支持。
请参考表达式核心变量中关于该节点的描述。

特殊用法请参考：https://github.com/alibaba/arthas/issues/71
OGNL 表达式官网：https://commons.apache.org/dormant/commons-ognl/language-guide.html

很多时候我们只想看到某个方法的 rt 大于某个时间之后的 trace 结果，现在 Arthas 可以按照方法执行的耗时来进行过滤了，例如trace *StringUtils isBlank &#39;#cost&gt;100&#39;表示当执行时间超过 100ms 的时候，才会输出 trace 的结果。
watch&#x2F;stack&#x2F;trace 这个三个命令都支持#cost

💡


注意事项
trace 能方便的帮助你定位和发现因 RT 高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路。
 参考：Trace 命令的实现原理在新窗口打开

3.3.0 版本后，可以使用动态 Trace 功能，不断增加新的匹配类，参考下面的示例。

目前不支持 trace java.lang.Thread getName，参考 issue: #1610在新窗口打开 ，考虑到不是非常必要场景，且修复有一定难度，因此当前暂不修复






3.1 trace不带参数命令[arthas@8161]$ trace demo.MathGame runPress Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 100 ms, listenerId: 6`---ts=2025-06-07 06:02:53.872;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    `---[1.431047ms] demo.MathGame:run()        +---[17.69% 0.25315ms ] demo.MathGame:primeFactors() #24        `---[38.56% 0.551755ms ] demo.MathGame:print() #25`---ts=2025-06-07 06:02:54.895;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    `---[0.421141ms] demo.MathGame:run()        `---[42.03% 0.177003ms ] demo.MathGame:primeFactors() #24 [throws Exception]`---ts=2025-06-07 06:02:55.897;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    `---[0.108631ms] demo.MathGame:run()        +---[21.72% 0.023592ms ] demo.MathGame:primeFactors() #24        `---[49.07% 0.053301ms ] demo.MathGame:print() #25

结果里的 #24，表示在 run 函数里，在源文件的第24行调用了primeFactors()函数。
3.2 trace带参数命令
-skipJDKMethod &lt;value&gt; skip jdk method trace, default value true.

默认情况下，trace 不会包含 jdk 里的函数调用，如果希望 trace jdk 里的函数，需要显式设置--skipJDKMethod false。

如果方法调用的次数很多，那么可以用-n参数指定捕捉结果的次数。比如下面的例子里，捕捉到一次调用就退出命令。

[arthas@8161]$ trace --skipJDKMethod false demo.MathGame run -n 3Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 108 ms, listenerId: 9`---ts=2025-06-07 09:33:22.964;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    +---[0.040626ms] java.util.Random:nextInt() #23    +---[0.152629ms] demo.MathGame:primeFactors() #24    +---[0.032551ms] demo.MathGame:print() #25    `---[3.440639ms] demo.MathGame:run()        +---[9.98% 0.343288ms ] java.util.Random:nextInt() #23        +---[17.64% 0.607089ms ] demo.MathGame:primeFactors() #24 [throws Exception]        +---[0.64% 0.021935ms ] java.lang.StringBuilder:&lt;init&gt;() #28        +---[7.40% 0.254695ms ] java.lang.String:format() #28        +---[1.37% min=0.01411ms,max=0.03298ms,total=0.04709ms,count=2] java.lang.StringBuilder:append() #28        +---[1.20% 0.041169ms ] java.lang.Exception:getMessage() #28        +---[0.64% 0.022185ms ] java.lang.StringBuilder:toString() #28        `---[16.69% 0.574324ms ] java.io.PrintStream:println() #28`---ts=2025-06-07 09:33:25.119;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    `---[1.504503ms] demo.MathGame:run()        +---[1.70% 0.025535ms ] java.util.Random:nextInt() #23        +---[5.34% 0.080385ms ] demo.MathGame:primeFactors() #24 [throws Exception]        +---[0.97% 0.01455ms ] java.lang.StringBuilder:&lt;init&gt;() #28        +---[3.14% 0.04719ms ] java.lang.String:format() #28        +---[1.90% min=0.014215ms,max=0.01436ms,total=0.028575ms,count=2] java.lang.StringBuilder:append() #28        +---[7.98% 0.12012ms ] java.lang.Exception:getMessage() #28        +---[0.88% 0.013255ms ] java.lang.StringBuilder:toString() #28        `---[25.35% 0.381384ms ] java.io.PrintStream:println() #28`---ts=2025-06-07 09:33:26.136;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    `---[0.357443ms] demo.MathGame:run()        +---[2.92% 0.01043ms ] java.util.Random:nextInt() #23        +---[12.37% 0.044215ms ] demo.MathGame:primeFactors() #24 [throws Exception]        +---[1.46% 0.00521ms ] java.lang.StringBuilder:&lt;init&gt;() #28        +---[9.13% 0.032649ms ] java.lang.String:format() #28        +---[2.90% min=0.004825ms,max=0.00555ms,total=0.010375ms,count=2] java.lang.StringBuilder:append() #28        +---[1.49% 0.00532ms ] java.lang.Exception:getMessage() #28        +---[1.34% 0.004785ms ] java.lang.StringBuilder:toString() #28        `---[18.75% 0.067035ms ] java.io.PrintStream:println() #28Command execution times exceed limit: 3, so command will exit. You can set it with -n option.

3.3 根据调用耗时过滤只会展示耗时大于 2ms 的调用路径，有助于在排查问题的时候，只关注异常情况

💡


是不是很眼熟，没错，在 JProfiler 等收费软件中你曾经见识类似的功能，这里你将可以通过命令就能打印出指定调用路径。 友情提醒下，trace 在执行的过程中本身是会有一定的性能开销，在统计的报告中并未像 JProfiler 一样预先减去其自身的统计开销。所以这统计出来有些许的不准，渲染路径上调用的类、方法越多，性能偏差越大。但还是能让你看清一些事情的。
[12.033735ms] 的含义，12.033735 的含义是：当前节点在当前步骤的耗时，单位为毫秒
[0,0,0ms,11]xxx:yyy() [throws Exception]，对该方法中相同的方法调用进行了合并，0,0,0ms,11 表示方法调用耗时，min,max,total,count；throws Exception 表明该方法调用中存在异常返回
这里存在一个统计不准确的问题，就是所有方法耗时加起来可能会小于该监测方法的总耗时，这个是由于 Arthas 本身的逻辑会有一定的耗时

[arthas@8161]$ trace demo.MathGame run &#x27;#cost &gt; 0.5&#x27; -n 3Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 87 ms, listenerId: 12`---ts=2025-06-07 09:36:31.428;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    `---[0.575073ms] demo.MathGame:run()        `---[56.12% 0.322722ms ] demo.MathGame:primeFactors() #24 [throws Exception]`---ts=2025-06-07 09:36:33.467;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    `---[2.125056ms] demo.MathGame:run()        +---[65.45% 1.390877ms ] demo.MathGame:primeFactors() #24        `---[23.98% 0.509524ms ] demo.MathGame:print() #25`---ts=2025-06-07 09:36:37.491;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    `---[7.300126ms] demo.MathGame:run()        +---[99.21% 7.242667ms ] demo.MathGame:primeFactors() #24        `---[0.44% 0.031904ms ] demo.MathGame:print() #25

4. stack命令输出当前方法被调用的调用路径
很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。

参数说明




参数名称
参数说明



class-pattern
类名表达式匹配


method-pattern
方法名表达式匹配


condition-express
条件表达式


[E]
开启正则表达式匹配，默认为通配符匹配


[n:]
执行次数限制


[m &lt;arg&gt;]
指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch &lt;arg&gt;]。



💡

这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写&quot;&#123;params,returnObj&#125;&quot;，只要是一个合法的 ognl 表达式，都能被正常支持。
观察的维度也比较多，主要体现在参数 advice 的数据结构上。Advice 参数最主要是封装了通知节点的所有信息。
请参考表达式核心变量中关于该节点的描述。

特殊用法请参考：https://github.com/alibaba/arthas/issues/71

OGNL 表达式官网：https://commons.apache.org/dormant/commons-ognl/language-guide.html


使用案例


## 使用stack命令跟踪primeFactors方法[arthas@8161]$ stack demo.MathGame primeFactorsPress Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 88 ms, listenerId: 14ts=2025-06-07 09:53:24.073;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    @demo.MathGame.primeFactors()        at demo.MathGame.run(MathGame.java:24)        at demo.MathGame.main(null:16)ts=2025-06-07 09:53:25.077;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    @demo.MathGame.primeFactors()        at demo.MathGame.run(MathGame.java:24)        at demo.MathGame.main(null:16)## 使用OGNL表达式，过滤第一个参数值小于0的方法调用情况，并且只打印两个信息数据[arthas@8161]$ stack demo.MathGame primeFactors &#x27;params[0]&lt;0&#x27; -n 2Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 85 ms, listenerId: 15ts=2025-06-07 09:53:57.220;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    @demo.MathGame.primeFactors()        at demo.MathGame.run(MathGame.java:24)        at demo.MathGame.main(null:16)ts=2025-06-07 09:53:58.223;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    @demo.MathGame.primeFactors()        at demo.MathGame.run(MathGame.java:24)        at demo.MathGame.main(null:16)Command execution times exceed limit: 2, so command will exit. You can set it with -n option.## 使用OGNL表达式，过滤耗时大于2毫秒的信息[arthas@8161]$ stack demo.MathGame primeFactors &#x27;#cost&gt;2&#x27;Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 84 ms, listenerId: 17ts=2025-06-07 09:56:40.903;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    @demo.MathGame.primeFactors()        at demo.MathGame.run(MathGame.java:24)        at demo.MathGame.main(null:16)ts=2025-06-07 09:56:44.919;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c    @demo.MathGame.primeFactors()        at demo.MathGame.run(MathGame.java:24)        at demo.MathGame.main(null:16)

5. tt命令方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测
watch 虽然很方便和灵活，但需要提前想清楚观察表达式的拼写，这对排查问题而言要求太高，因为很多时候我们并不清楚问题出自于何方，只能靠蛛丝马迹进行猜测。
这个时候如果能记录下当时方法调用的所有入参和返回值、抛出的异常会对整个问题的思考与判断非常有帮助。
于是乎，TimeTunnel 命令就诞生了。

💡


tt 命令的实现是：把函数的入参&#x2F;返回值等，保存到一个Map&lt;Integer, TimeFragment&gt;里，默认的大小是 100。
tt 相关功能在使用完之后，需要手动释放内存，否则长时间可能导致OOM。退出 arthas 不会自动清除 tt 的缓存 map


命令参数解析
t
  tt 命令有很多个主参数，-t 就是其中之一。这个参数的表明希望记录下类 *Test 的 print 方法的每次执行情况。

n 3
  当你执行一个调用量不高的方法时可能你还能有足够的时间用 CTRL+C 中断 tt 命令记录的过程，但如果遇到调用量非常大的方法，瞬间就能将你的 JVM 内存撑爆。
  此时你可以通过 -n 参数指定你需要记录的次数，当达到记录次数时 Arthas 会主动中断 tt 命令的记录过程，避免人工操作无法停止的情况。

m 1
  通过 -m 参数指定 Class 匹配的最大数量，防止匹配到的 Class 数量太多导致 JVM 挂起，默认值是 50。




5.1 执行命令：tt -t demo.MathGame primeFactors[arthas@8161]$ tt -t demo.MathGame primeFactorsPress Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 85 ms, listenerId: 18 INDEX            TIMESTAMP                                 COST(ms)             IS-RET          IS-EXP           OBJECT                         CLASS                                                          METHOD                                                        ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 1000             2025-06-07 10:07:44.617                   0.227622             false           true             0x589838eb                     MathGame                                                       primeFactors                                                   1001             2025-06-07 10:07:45.621                   0.07812              false           true             0x589838eb                     MathGame                                                       primeFactors                                                   1002             2025-06-07 10:07:46.623                   0.091644             false           true             0x589838eb                     MathGame                                                       primeFactors                                                   1003             2025-06-07 10:07:47.628                   3.676343             true            false            0x589838eb                     MathGame                                                       primeFactors                                                   1004             2025-06-07 10:07:48.631                   0.05122              false           true             0x589838eb                     MathGame                                                       primeFactors  


表格字段说明




表格字段
字段解释



INDEX
时间片段记录编号，每一个编号代表着一次调用，后续 tt 还有很多命令都是基于此编号指定记录操作，非常重要。


TIMESTAMP
方法执行的本机时间，记录了这个时间片段所发生的本机时间


COST(ms)
方法执行的耗时


IS-RET
方法是否以正常返回的形式结束


IS-EXP
方法是否以抛异常的形式结束


OBJECT
执行对象的hashCode()，注意，曾经有人误认为是对象在 JVM 中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体


CLASS
执行的类名


METHOD
执行的方法名



条件表达式
  不知道大家是否有在使用过程中遇到以下困惑

Arthas 似乎很难区分出重载的方法
我只需要观察特定参数，但是 tt 却全部都给我记录了下来

  条件表达式也是用 OGNL 来编写，核心的判断对象依然是 Advice 对象。除了 tt 命令之外，watch、trace、stack 命令也都支持条件表达式。
  

解决方法重载
  tt -t *Test print params.length==1
  通过制定参数个数的形式解决不同的方法签名，如果参数个数一样，你还可以这样写
  tt -t *Test print &#39;params[1] instanceof Integer&#39;

解决指定参数
  tt -t *Test print params[0].mobile==&quot;13989838402&quot;

构成条件表达式的 Advice 对象
  前边看到了很多条件表达式中，都使用了 params[0]，有关这个变量的介绍，请参考表达式核心变量


5.2 查看调用信息对于具体一个时间片的信息而言，你可以通过 -i 参数后边跟着对应的 INDEX 编号查看到他的详细信息。
[arthas@8161]$ tt -i 1004 INDEX            1004                                                                                                                                                                                                                                                         GMT-CREATE       2025-06-07 10:07:48.631                                                                                                                                                                                                                                      COST(ms)         0.05122                                                                                                                                                                                                                                                      OBJECT           0x589838eb                                                                                                                                                                                                                                                   CLASS            demo.MathGame                                                                                                                                                                                                                                                METHOD           primeFactors                                                                                                                                                                                                                                                 IS-RETURN        false                                                                                                                                                                                                                                                        IS-EXCEPTION     true                                                                                                                                                                                                                                                         PARAMETERS[0]    @Integer[-67793]                                                                                                                                                                                                                                             THROW-EXCEPTION  java.lang.IllegalArgumentException: number is: -67793, need &gt;= 2                                                                                                                                                                                                              	at demo.MathGame.primeFactors(MathGame.java:46)                                                                                                                                                                                                                              	at demo.MathGame.run(MathGame.java:24)                                                                                                                                                                                                                                       	at demo.MathGame.main(Unknown Source)                                                                                                                                                                                                                      Affect(row-cnt:1) cost in 3 ms.

5.3 重做一次调用当你稍稍做了一些调整之后，你可能需要前端系统重新触发一次你的调用，此时得求爷爷告奶奶的需要前端配合联调的同学再次发起一次调用。而有些场景下，这个调用不是这么好触发的。
tt 命令由于保存了当时调用的所有现场信息，所以我们可以自己主动对一个 INDEX 编号的时间片自主发起一次调用，从而解放你的沟通成本。此时你需要 -p 参数。通过 --replay-times 指定 调用次数，通过 --replay-interval 指定多次调用间隔(单位 ms, 默认 1000ms)
[arthas@8161]$ tt -i 1004 -p RE-INDEX         1004                                                                                                                                                                                                                                                         GMT-REPLAY       2025-06-07 10:15:36.439                                                                                                                                                                                                                                      OBJECT           0x589838eb                                                                                                                                                                                                                                                   CLASS            demo.MathGame                                                                                                                                                                                                                                                METHOD           primeFactors                                                                                                                                                                                                                                                 PARAMETERS[0]    @Integer[-67793]                                                                                                                                                                                                                                             IS-RETURN        false                                                                                                                                                                                                                                                        IS-EXCEPTION     true                                                                                                                                                                                                                                                         THROW-EXCEPTION  java.lang.IllegalArgumentException: number is: -67793, need &gt;= 2                                                                                                                                                                                                              	at demo.MathGame.primeFactors(MathGame.java:46)                                                                                                                                                                                                                              	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                                                                                                                                                                                            	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)                                                                                                                                                                          	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)                                                                                                                                                                  	at java.base/java.lang.reflect.Method.invoke(Method.java:566)                                                                                                                                                                                                                	at com.taobao.arthas.core.advisor.ArthasMethod.invoke(ArthasMethod.java:155)                                                                                                                                                                                                 	at com.taobao.arthas.core.command.monitor200.TimeTunnelCommand.processPlay(TimeTunnelCommand.java:517)                                                                                                                                                                       	at com.taobao.arthas.core.command.monitor200.TimeTunnelCommand.process(TimeTunnelCommand.java:278)                                                                                                                                                                           	at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.process(AnnotatedCommandImpl.java:82)                                                                                                                                                                      	at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.access$100(AnnotatedCommandImpl.java:18)                                                                                                                                                                   	at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:111)                                                                                                                                                       	at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:108)                                                                                                                                                       	at com.taobao.arthas.core.shell.system.impl.ProcessImpl$CommandProcessTask.run(ProcessImpl.java:385)                                                                                                                                                                         	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)                                                                                                                                                                                         	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)                                                                                                                                                                                                        	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)                                                                                                                                                  	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)                                                                                                                                                                                 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)                                                                                                                                                                                 	at java.base/java.lang.Thread.run(Thread.java:834)                                                                                                                                                                                                         Time fragment[1004] successfully replayed 1 times.]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>Arthas诊断工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas诊断工具(六)Arthas（阿尔萨斯）options全局开关</title>
    <url>/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E5%85%AD)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89options%E5%85%A8%E5%B1%80%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[Arthas诊断工具(六)Arthas（阿尔萨斯）options全局开关1. options命令全局开关



名称
默认值
描述



unsafe
false
是否支持对系统级别的类进行增强，打开该开关可能导致把 JVM 搞挂，请慎重选择！


dump
false
是否支持被增强了的类 dump 到外部文件中，如果打开开关，class 文件会被 dump 到/$&#123;application working dir&#125;/arthas-class-dump/目录下，具体位置详见控制台输出


batch-re-transform
true
是否支持批量对匹配到的类执行 retransform 操作


json-format
false
是否支持 json 化的输出


disable-sub-class
false
是否禁用子类匹配，默认在匹配目标类的时候会默认匹配到其子类，如果想精确匹配，可以关闭此开关


support-default-method
true
是否支持匹配到 default method， 默认会查找 interface，匹配里面的 default method。参考 #1105在新窗口打开


save-result
false
是否打开执行结果存日志功能，打开之后所有命令的运行结果都将保存到~/logs/arthas-cache/result.log中


job-timeout
1d
异步后台任务的默认超时时间，超过这个时间，任务自动停止；比如设置 1d, 2h, 3m, 25s，分别代表天、小时、分、秒


print-parent-fields
true
是否打印在 parent class 里的 filed


verbose
false
是否打印更多详细信息


strict
true
是否启用 strict 模式



查看所有的 options

[arthas@8161]$ options LEVEL              TYPE                NAME                                  VALUE              SUMMARY                                                   DESCRIPTION                                                                                                        ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 0                  boolean             unsafe                                false              Option to support system-level class                      This option enables to proxy functionality of JVM classes. Due to serious security risk a JVM crash is possibly be                                                                                                                                                             introduced. Do not activate it unless you are able to manage.                                                      1                  boolean             dump                                  false              Option to dump the enhanced classes                       This option enables the enhanced classes to be dumped to external file for further de-compilation and analysis.     1                  boolean             batch-re-transform                    true               Option to support batch reTransform Class                 This options enables to reTransform classes with batch mode.                                                        2                  boolean             json-format                           false              Option to support JSON format of object output            This option enables to format object output with JSON when -x option selected.                                      1                  boolean             disable-sub-class                     false              Option to control include sub class when class matching   This option disable to include sub class when matching class.                                                       1                  boolean             support-default-method                true               Option to control include default method in interface wh  This option disable to include default method in interface when matching class.                                                                                                                                     en class matching                                                                                                                                                             1                  boolean             save-result                           false              Option to print command&#x27;s result to log file              This option enables to save each command&#x27;s result to log file, which path is $&#123;user.home&#125;/logs/arthas-cache/result                                                                                                                                                            .log.                                                                                                               2                  String              job-timeout                           1d                 Option to job timeout                                     This option setting job timeout,The unit can be d, h, m, s for day, hour, minute, second. 1d is one day in default  1                  boolean             print-parent-fields                   true               Option to print all fileds in parent class                This option enables print files in parent class, default value true.                                                1                  boolean             verbose                               false              Option to print verbose information                       This option enables print verbose information, default value false.                                                 1                  boolean             strict                                true               Option to strict mode                                     By default, strict mode is true, not allowed to set object properties. Want to set object properties, execute `opt                                                                                                                                                            ions strict false`  


获取 option 的值

json-format job-timeout [arthas@8161]$ options json-format  LEVEL              TYPE                NAME                                  VALUE              SUMMARY                                                   DESCRIPTION                                                                                                        ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 2                  boolean             json-format                           false              Option to support JSON format of object output            This option enables to format object output with JSON when -x option selected.                                     ]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>Arthas诊断工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas诊断工具(四)Arthas（阿尔萨斯）class/classloader相关命令</title>
    <url>/Arthas%E5%BA%94%E7%94%A8(Java)%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8/Arthas%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7(%E5%9B%9B)Arthas%EF%BC%88%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%EF%BC%89class%20classloader%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[Arthas诊断工具(四)Arthas（阿尔萨斯）class&#x2F;classloader相关命令1. sc命令查看 JVM 已加载的类信息，
“Search-Class” 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息，这个命令支持的参数有 [d]、[E]、[f] 和 [x:]。

参数说明




参数名称
参数说明



class-pattern
类名表达式匹配


method-pattern
方法名表达式匹配


[d]
输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的 ClassLoader 等详细信息。如果一个类被多个 ClassLoader 所加载，则会出现多次


[E]
开启正则表达式匹配，默认为通配符匹配


[f]
输出当前类的成员变量信息（需要配合参数-d 一起使用）


[x:]
指定输出静态变量时属性的遍历深度，默认为 0，即直接使用 toString 输出


[c:]
指定 class 的 ClassLoader 的 hashcode


[classLoaderClass:]
指定执行表达式的 ClassLoader 的 class name


[n:]
具有详细信息的匹配类的最大数量（默认为 100）


[cs &lt;arg&gt;]
指定 class 的 ClassLoader#toString() 返回值。长格式[classLoaderStr &lt;arg&gt;]



提示

class-pattern 支持全限定名，如 com.taobao.test.AAA，也支持 com&#x2F;taobao&#x2F;test&#x2F;AAA 这样的格式，这样，我们从异常堆栈里面把类名拷贝过来的时候，不需要在手动把/替换为.啦。
sc 默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开options disable-sub-class true开关


使用参考

模糊搜索

  [arthas@7339]$ sc demo.*demo.MathGameAffect(row-cnt:1) cost in 17 ms.

打印类的详细信息

  [arthas@7339]$ sc -d demo.MathGame class-info        demo.MathGame                                                                                                                                                                                                                                               code-source       /usr/local/software/arthas/math-game.jar                                                                                                                                                                                                                    name              demo.MathGame                                                                                                                                                                                                                                               isInterface       false                                                                                                                                                                                                                                                       isAnnotation      false                                                                                                                                                                                                                                                       isEnum            false                                                                                                                                                                                                                                                       isAnonymousClass  false                                                                                                                                                                                                                                                       isArray           false                                                                                                                                                                                                                                                       isLocalClass      false                                                                                                                                                                                                                                                       isMemberClass     false                                                                                                                                                                                                                                                       isPrimitive       false                                                                                                                                                                                                                                                       isSynthetic       false                                                                                                                                                                                                                                                       simple-name       MathGame                                                                                                                                                                                                                                                    modifier          public                                                                                                                                                                                                                                                      annotation                                                                                                                                                                                                                                                                    interfaces                                                                                                                                                                                                                                                                    super-class       +-java.lang.Object                                                                                                                                                                                                                                          class-loader      +-jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c                                                                                                                                                                                                                      +-jdk.internal.loader.ClassLoaders$PlatformClassLoader@38755edd                                                                                                                                                                                           classLoaderHash   4b85612c                                                                                                                                                                                                                                                   Affect(row-cnt:1) cost in 21 ms.

打印出类的 Field 信息

  [arthas@7339]$ sc -d -f demo.MathGame class-info        demo.MathGame                                                                                                                                                                                                                                               code-source       /usr/local/software/arthas/math-game.jar                                                                                                                                                                                                                    name              demo.MathGame                                                                                                                                                                                                                                               isInterface       false                                                                                                                                                                                                                                                       isAnnotation      false                                                                                                                                                                                                                                                       isEnum            false                                                                                                                                                                                                                                                       isAnonymousClass  false                                                                                                                                                                                                                                                       isArray           false                                                                                                                                                                                                                                                       isLocalClass      false                                                                                                                                                                                                                                                       isMemberClass     false                                                                                                                                                                                                                                                       isPrimitive       false                                                                                                                                                                                                                                                       isSynthetic       false                                                                                                                                                                                                                                                       simple-name       MathGame                                                                                                                                                                                                                                                    modifier          public                                                                                                                                                                                                                                                      annotation                                                                                                                                                                                                                                                                    interfaces                                                                                                                                                                                                                                                                    super-class       +-java.lang.Object                                                                                                                                                                                                                                          class-loader      +-jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c                                                                                                                                                                                                                      +-jdk.internal.loader.ClassLoaders$PlatformClassLoader@38755edd                                                                                                                                                                                           classLoaderHash   4b85612c                                                                                                                                                                                                                                                    fields            name     random                                                                                                                                                                                                                                                               type     java.util.Random                                                                                                                                                                                                                                                     modifier private,static                                                                                                                                                                                                                                                       value    java.util.Random@464dde8d                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          name     illegalArgumentCount                                                                                                                                                                                                                                                 type     int                                                                                                                                                                                                                                                                  modifier private                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Affect(row-cnt:1) cost in 23 ms.

2. sm 命令查看已加载类的方法信息，“Search-Method” 的简写，这个命令能搜索出所有已经加载了 Class 信息的方法信息。
sm 命令只能看到由当前类所声明 (declaring) 的方法，父类则无法看到。

参数说明




参数名称
参数说明



class-pattern
类名表达式匹配


method-pattern
方法名表达式匹配


[d]
展示每个方法的详细信息


[E]
开启正则表达式匹配，默认为通配符匹配


[c:]
指定 class 的 ClassLoader 的 hashcode


[classLoaderClass:]
指定执行表达式的 ClassLoader 的 class name


[n:]
具有详细信息的匹配类的最大数量（默认为 100）


[arthas@7339]$ sm java.lang.Stringjava.lang.String &lt;init&gt;([B)Vjava.lang.String &lt;init&gt;([BII)Vjava.lang.String &lt;init&gt;([BLjava/nio/charset/Charset;)Vjava.lang.String &lt;init&gt;([BLjava/lang/String;)Vjava.lang.String &lt;init&gt;([BIILjava/nio/charset/Charset;)Vjava.lang.String &lt;init&gt;([CIILjava/lang/Void;)Vjava.lang.String &lt;init&gt;(Ljava/lang/AbstractStringBuilder;Ljava/lang/Void;)Vjava.lang.String &lt;init&gt;(Ljava/lang/StringBuilder;)Vjava.lang.String &lt;init&gt;(Ljava/lang/StringBuffer;)Vjava.lang.String &lt;init&gt;([BB)Vjava.lang.String &lt;init&gt;([CII)Vjava.lang.String &lt;init&gt;([C)Vjava.lang.String &lt;init&gt;(Ljava/lang/String;)Vjava.lang.String &lt;init&gt;()Vjava.lang.String &lt;init&gt;([BIILjava/lang/String;)Vjava.lang.String &lt;init&gt;([BI)Vjava.lang.String &lt;init&gt;([BIII)Vjava.lang.String &lt;init&gt;([III)Vjava.lang.String value()[Bjava.lang.String equals(Ljava/lang/Object;)Zjava.lang.String length()Ijava.lang.String toString()Ljava/lang/String;java.lang.String hashCode()Ijava.lang.String getChars(II[CI)Vjava.lang.String compareTo(Ljava/lang/String;)Ijava.lang.String compareTo(Ljava/lang/Object;)Ijava.lang.String indexOf(Ljava/lang/String;I)Ijava.lang.String indexOf(I)Ijava.lang.String indexOf([BBILjava/lang/String;I)Ijava.lang.String indexOf(II)Ijava.lang.String indexOf(Ljava/lang/String;)Ijava.lang.String checkIndex(II)Vjava.lang.String valueOf(I)Ljava/lang/String;java.lang.String valueOf(F)Ljava/lang/String;java.lang.String valueOf(Z)Ljava/lang/String;java.lang.String valueOf(J)Ljava/lang/String;java.lang.String valueOf(D)Ljava/lang/String;java.lang.String valueOf(Ljava/lang/Object;)Ljava/lang/String;java.lang.String valueOf(C)Ljava/lang/String;java.lang.String valueOf([C)Ljava/lang/String;java.lang.String valueOf([CII)Ljava/lang/String;java.lang.String coder()Bjava.lang.String rangeCheck([CII)Ljava/lang/Void;java.lang.String codePoints()Ljava/util/stream/IntStream;java.lang.String isEmpty()Zjava.lang.String charAt(I)Cjava.lang.String codePointAt(I)Ijava.lang.String codePointBefore(I)Ijava.lang.String codePointCount(II)Ijava.lang.String offsetByCodePoints(II)Ijava.lang.String getBytes(Ljava/nio/charset/Charset;)[Bjava.lang.String getBytes(II[BI)Vjava.lang.String getBytes(Ljava/lang/String;)[Bjava.lang.String getBytes()[Bjava.lang.String getBytes([BIB)Vjava.lang.String contentEquals(Ljava/lang/StringBuffer;)Zjava.lang.String contentEquals(Ljava/lang/CharSequence;)Zjava.lang.String nonSyncContentEquals(Ljava/lang/AbstractStringBuilder;)Zjava.lang.String equalsIgnoreCase(Ljava/lang/String;)Zjava.lang.String compareToIgnoreCase(Ljava/lang/String;)Ijava.lang.String regionMatches(ZILjava/lang/String;II)Zjava.lang.String regionMatches(ILjava/lang/String;II)Zjava.lang.String startsWith(Ljava/lang/String;)Zjava.lang.String startsWith(Ljava/lang/String;I)Zjava.lang.String endsWith(Ljava/lang/String;)Zjava.lang.String lastIndexOf(I)Ijava.lang.String lastIndexOf([BBILjava/lang/String;I)Ijava.lang.String lastIndexOf(Ljava/lang/String;I)Ijava.lang.String lastIndexOf(Ljava/lang/String;)Ijava.lang.String lastIndexOf(II)Ijava.lang.String substring(II)Ljava/lang/String;java.lang.String substring(I)Ljava/lang/String;java.lang.String subSequence(II)Ljava/lang/CharSequence;java.lang.String concat(Ljava/lang/String;)Ljava/lang/String;java.lang.String replace(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/String;java.lang.String replace(CC)Ljava/lang/String;java.lang.String matches(Ljava/lang/String;)Zjava.lang.String contains(Ljava/lang/CharSequence;)Zjava.lang.String replaceFirst(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;java.lang.String replaceAll(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;java.lang.String split(Ljava/lang/String;)[Ljava/lang/String;java.lang.String split(Ljava/lang/String;I)[Ljava/lang/String;java.lang.String join(Ljava/lang/CharSequence;[Ljava/lang/CharSequence;)Ljava/lang/String;java.lang.String join(Ljava/lang/CharSequence;Ljava/lang/Iterable;)Ljava/lang/String;java.lang.String toLowerCase()Ljava/lang/String;java.lang.String toLowerCase(Ljava/util/Locale;)Ljava/lang/String;java.lang.String toUpperCase(Ljava/util/Locale;)Ljava/lang/String;java.lang.String toUpperCase()Ljava/lang/String;java.lang.String trim()Ljava/lang/String;java.lang.String strip()Ljava/lang/String;java.lang.String stripLeading()Ljava/lang/String;java.lang.String stripTrailing()Ljava/lang/String;java.lang.String isBlank()Zjava.lang.String indexOfNonWhitespace()Ijava.lang.String lines()Ljava/util/stream/Stream;java.lang.String chars()Ljava/util/stream/IntStream;java.lang.String toCharArray()[Cjava.lang.String format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;java.lang.String format(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;java.lang.String copyValueOf([CII)Ljava/lang/String;java.lang.String copyValueOf([C)Ljava/lang/String;java.lang.String intern()Ljava/lang/String;java.lang.String repeat(I)Ljava/lang/String;java.lang.String isLatin1()Zjava.lang.String checkOffset(II)Vjava.lang.String checkBoundsOffCount(III)Vjava.lang.String checkBoundsBeginEnd(III)Vjava.lang.String valueOfCodePoint(I)Ljava/lang/String;Affect(row-cnt:108) cost in 29 ms.


展示每个方法的详细信息

[arthas@7339]$ sm -d java.lang.String toString declaring-class  java.lang.String                                                                                                                                                                                                                                             method-name      toString                                                                                                                                                                                                                                                     modifier         public                                                                                                                                                                                                                                                       annotation                                                                                                                                                                                                                                                                    parameters                                                                                                                                                                                                                                                                    return           java.lang.String                                                                                                                                                                                                                                             exceptions                                                                                                                                                                                                                                                                    classLoaderHash  null                                                                                                                                                                                                                                                        Affect(row-cnt:1) cost in 14 ms.

3. jad 命令反编译指定已加载类的源码
jad 命令将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于你理解业务逻辑；如需批量下载指定包的目录的 class 字节码可以参考 dump。

在 Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便
当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解
参数说明




参数名称
参数说明



class-pattern
类名表达式匹配


[c:]
类所属 ClassLoader 的 hashcode


[classLoaderClass:]
指定执行表达式的 ClassLoader 的 class name


[E]
开启正则表达式匹配，默认为通配符匹配



使用参考

[arthas@5167]$ jad demo.MathGame // 使用的类加载器ClassLoader:                                                                                                                                                                                                                                                                  +-jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c                                                                                                                                                                                                                      +-jdk.internal.loader.ClassLoaders$PlatformClassLoader@f98fa20                                                                                                                                                                                                              // Main Class的位置在math-game.jar文件中Location:                                                                                                                                                                                                                                                                     /usr/local/software/arthas/math-game.jar                                                                                                                                                                                                                                             /*        * Decompiled with CFR.        */       package demo;              import java.util.ArrayList;       import java.util.List;       import java.util.Random;       import java.util.concurrent.TimeUnit;              public class MathGame &#123;           private static Random random = new Random();           private int illegalArgumentCount = 0;                  public List&lt;Integer&gt; primeFactors(int number) &#123;/*44*/         if (number &lt; 2) &#123;/*45*/             ++this.illegalArgumentCount;                   throw new IllegalArgumentException(&quot;number is: &quot; + number + &quot;, need &gt;= 2&quot;);               &#125;               ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();/*50*/         int i = 2;/*51*/         while (i &lt;= number) &#123;/*52*/             if (number % i == 0) &#123;/*53*/                 result.add(i);/*54*/                 number /= i;/*55*/                 i = 2;                       continue;                   &#125;/*57*/             ++i;               &#125;/*61*/         return result;           &#125;                  public static void main(String[] args) throws InterruptedException &#123;               MathGame game = new MathGame();               while (true) &#123;/*16*/             game.run();/*17*/             TimeUnit.SECONDS.sleep(1L);               &#125;           &#125;                  public void run() throws InterruptedException &#123;               try &#123;/*23*/             int number = random.nextInt() / 10000;/*24*/             List&lt;Integer&gt; primeFactors = this.primeFactors(number);/*25*/             MathGame.print(number, primeFactors);               &#125;               catch (Exception e) &#123;/*28*/             System.out.println(String.format(&quot;illegalArgumentCount:%3d, &quot;, this.illegalArgumentCount) + e.getMessage());               &#125;           &#125;                  public static void print(int number, List&lt;Integer&gt; primeFactors) &#123;               StringBuffer sb = new StringBuffer(number + &quot;=&quot;);/*34*/         for (int factor : primeFactors) &#123;/*35*/             sb.append(factor).append(&#x27;*&#x27;);               &#125;/*37*/         if (sb.charAt(sb.length() - 1) == &#x27;*&#x27;) &#123;/*38*/             sb.deleteCharAt(sb.length() - 1);               &#125;/*40*/         System.out.println(sb);           &#125;       &#125;// 耗时1238 ms.Affect(row-cnt:1) cost in 1238 ms.

4. mc命令Memory Compiler&#x2F;内存编译器，编译.java文件生成.class。默认位置在arthas位置
可以通过-d命令指定输出目录：
// 查看Hello.java的内容[arthas@7339]$ cat /usr/local/software/arthas/Hello.java public class Hello &#123;	public static void main(String[] args)&#123;		System.out.println(&quot;Hello&quot;);	&#125;&#125;// 使用mc命令编译文件[arthas@7339]$ mc -d /usr/local/software/arthas/output /usr/local/software/arthas/Hello.java Memory compiler output:/usr/local/software/arthas/output/Hello.classAffect(row-cnt:1) cost in 738 ms.

5.redefine命令加载外部的.class文件，redefine jvm 已加载的类。

redefine 的 class 不能修改、添加、删除类的 field 和 method，包括方法参数、方法名称及返回值
如果 mc 失败，可以在本地开发环境编译好 class 文件，上传到目标系统，使用 redefine 热加载 class
目前 redefine 和 watch&#x2F;trace&#x2F;jad&#x2F;tt 等命令冲突，以后重新实现 redefine 功能会解决此问题


💡

注意， redefine 后的原来的类不能恢复，redefine 有可能失败（比如增加了新的 field），参考 jdk 本身的文档。
reset命令对redefine的类无效。如果想重置，需要redefine原始的字节码。
redefine命令和jad&#x2F;watch&#x2F;trace&#x2F;monitor&#x2F;tt等命令会冲突。执行完redefine之后，如果再执行上面提到的命令，则会把redefine的字节码重置。 原因是 jdk 本身 redefine 和 Retransform 是不同的机制，同时使用两种机制来更新字节码，只有最后修改的会生效。



参数说明




参数名称
参数说明



[c:]
ClassLoader 的 hashcode


[classLoaderClass:]
指定执行表达式的 ClassLoader 的 class name


案例：

使用jad反编译demo.MathGame输出到&#x2F;root&#x2F;MathGame.java

## jad 命令反编译[arthas@7339]$ jad demo.MathGame --source-only &gt; /root/MathGame.javaredirect output file will be: /root/MathGame.java


打开新的窗口，使用vim 来修改源码

vim &#x2F;root&#x2F;MathGame.java
       /*        * Decompiled with CFR.        */       package demo;       import java.util.ArrayList;       import java.util.List;       import java.util.Random;       import java.util.concurrent.TimeUnit;       public class MathGame &#123;           private static Random random = new Random();           private int illegalArgumentCount = 0;           public List&lt;Integer&gt; primeFactors(int number) &#123;/*44*/         if (number &lt; 2) &#123;/*45*/             ++this.illegalArgumentCount;                   throw new IllegalArgumentException(&quot;number is: &quot; + number + &quot;, need &gt;= 2&quot;);               &#125;               ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();/*50*/         int i = 2;/*51*/         while (i &lt;= number) &#123;/*52*/             if (number % i == 0) &#123;/*53*/                 result.add(i);/*54*/                 number /= i;/*55*/                 i = 2;                       continue;                   &#125;/*57*/             ++i;               &#125;/*61*/         return result;           &#125;           public static void main(String[] args) throws InterruptedException &#123;               MathGame game = new MathGame();               while (true) &#123;/*16*/             game.run();/*17*/             TimeUnit.SECONDS.sleep(1L);                   System.out.println(&quot;在main方法循环体内执行&quot;);               &#125;           &#125;           public void run() throws InterruptedException &#123;                System.out.println(&quot;在run方法中执行&quot;);               try &#123;/*23*/             int number = random.nextInt() / 10000;/*24*/             List&lt;Integer&gt; primeFactors = this.primeFactors(number);/*25*/             MathGame.print(number, primeFactors);               &#125;               catch (Exception e) &#123;/*28*/             System.out.println(String.format(&quot;illegalArgumentCount:%3d, &quot;, this.illegalArgumentCount) + e.getMessage());               &#125;           &#125;           public static void print(int number, List&lt;Integer&gt; primeFactors) &#123;               StringBuffer sb = new StringBuffer(number + &quot;=&quot;);/*34*/         for (int factor : primeFactors) &#123;/*35*/             sb.append(factor).append(&#x27;*&#x27;);               &#125;/*37*/         if (sb.charAt(sb.length() - 1) == &#x27;*&#x27;) &#123;/*38*/             sb.deleteCharAt(sb.length() - 1);               &#125;/*40*/         System.out.println(sb);           &#125;       &#125;


mc 命令来内存编译修改过的代码

[arthas@7339]$ mc /root/MathGame.java -d /rootMemory compiler output:/root/demo/MathGame.classAffect(row-cnt:1) cost in 253 ms.


使用redefine命令加载新字节码文件

[arthas@7339]$ redefine /root/demo/MathGame.class redefine success, size: 1, classes:demo.MathGame


执行结果

190754=2*127*751160050=2*3*5*5*11*97171397=101*169769692=2*2*7*19*131illegalArgumentCount:8140, number is: -77511, need &gt;= 2illegalArgumentCount:8141, number is: -126748, need &gt;= 275490=2*5*7549illegalArgumentCount:8142, number is: -125543, need &gt;= 2illegalArgumentCount:8143, number is: -125902, need &gt;= 287103=8710373353=3*7*7*499189859=189859在run方法中执行28098=2*3*3*7*223在run方法中执行illegalArgumentCount:8144, number is: -45234, need &gt;= 2在run方法中执行78004=2*2*19501


6. dump命令dump 已加载类的 bytecode 到特定目录，
dump 命令将 JVM 中实际运行的 class 的 byte code dump 到指定目录，适用场景批量下载指定包目录的 class 字节码；如需反编译单一类、实时查看类信息，可参考 jad。

参数说明




参数名称
参数说明



class-pattern
类名表达式匹配


[c:]
类所属 ClassLoader 的 hashcode


[classLoaderClass:]
指定执行表达式的 ClassLoader 的 class name


[d:]
设置类文件的目标目录


[E]
开启正则表达式匹配，默认为通配符匹


dump java.lang.String
[arthas@8161]$ dump java.lang.String HASHCODE  CLASSLOADER  LOCATION                                                                                                                                                                                                                                               null                   /root/logs/arthas/classdump/java/lang/String.class                                                                                                                                                                                                    Affect(row-cnt:1) cost in 45 ms.[arthas@8161]$ dump demo.* HASHCODE  CLASSLOADER                                                       LOCATION                                                                                                                                                                                          4b85612c  +-jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c        /root/logs/arthas/classdump/jdk.internal.loader.ClassLoaders$AppClassLoader-4b85612c/demo/MathGame.class                                                                                                      +-jdk.internal.loader.ClassLoaders$PlatformClassLoader@17bb5c0                                                                                                                                                                                                   Affect(row-cnt:1) cost in 22 ms.

7. classloader命令查看 classloader 的继承树，urls，类加载信息
classloader 命令将 JVM 中所有的 classloader 的信息统计出来，并可以展示继承树，urls 等。
可以让指定的 classloader 去 getResources，打印出所有查找到的 resources 的 url。对于ResourceNotFoundException比较有用。

参数说明




参数名称
参数说明



[l]
按类加载实例进行统计


[t]
打印所有 ClassLoader 的继承树


[a]
列出所有 ClassLoader 加载的类，请谨慎使用


[c:]
ClassLoader 的 hashcode


[classLoaderClass:]
指定执行表达式的 ClassLoader 的 class name


[c: r:]
用 ClassLoader 去查找 resource


[c: load:]
用 ClassLoader 去加载指定的类



使用参考

按类加载类型查看统计信息

  [arthas@8161]$ classloader name                                                  numberOfInstances  loadedCountTotal                                                                                                                                                                                     com.taobao.arthas.agent.ArthasClassloader             2                  4420                                                                                                                                                                                                 BootstrapClassLoader                                  1                  3487                                                                                                                                                                                                 jdk.internal.loader.ClassLoaders$PlatformClassLoader  1                  60                                                                                                                                                                                                   jdk.internal.reflect.DelegatingClassLoader            21                 21                                                                                                                                                                                                   jdk.internal.loader.ClassLoaders$AppClassLoader       1                  4                                                                                                                                                                                                   Affect(row-cnt:5) cost in 10 ms.

按类加载实例查看统计信息

  [arthas@8161]$ classloader -l name                                                          loadedCount  hash      parent                                                                                                                                                                                   BootstrapClassLoader                                          3487         null      null                                                                                                                                                                                     com.taobao.arthas.agent.ArthasClassloader@369500c6            2696         369500c6  jdk.internal.loader.ClassLoaders$PlatformClassLoader@17bb5c0                                                                                                                             com.taobao.arthas.agent.ArthasClassloader@6489d91             1727         6489d91   jdk.internal.loader.ClassLoaders$PlatformClassLoader@17bb5c0                                                                                                                             jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c      4            4b85612c  jdk.internal.loader.ClassLoaders$PlatformClassLoader@17bb5c0                                                                                                                             jdk.internal.loader.ClassLoaders$PlatformClassLoader@17bb5c0  60           17bb5c0   null                                                                                                                                                                                    Affect(row-cnt:5) cost in 10 ms.

查看 ClassLoader 的继承树

  [arthas@8161]$ classloader -t+-BootstrapClassLoader                                                                                                                                                                                                                                                        +-jdk.internal.loader.ClassLoaders$PlatformClassLoader@17bb5c0                                                                                                                                                                                                                  +-com.taobao.arthas.agent.ArthasClassloader@369500c6                                                                                                                                                                                                                          +-com.taobao.arthas.agent.ArthasClassloader@6489d91                                                                                                                                                                                                                           +-jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c                                                                                                                                                                                                                  Affect(row-cnt:5) cost in 13 ms.

查看 URLClassLoader 实际的 urls

  [arthas@8161]$ classloader -c 369500c6file:/root/.arthas/lib/4.0.5/arthas/arthas-core.jar                                                                                                                                                                                                                           Affect(row-cnt:2) cost in 1 ms.

使用 ClassLoader 去查找 resource

  [arthas@8161]$ classloader -c 369500c6  -r META-INF/MANIFEST.MF jar:file:/root/.arthas/lib/4.0.5/arthas/arthas-core.jar!/META-INF/MANIFEST.MF                                                                                                                                                                                                Affect(row-cnt:1) cost in 1 ms.

也可以尝试查找类的 class 文件

  [arthas@8161]$ classloader -c 369500c6   -r java/lang/String.class jrt:/java.base/java/lang/String.class                                                                                                                                                                                                                                        Affect(row-cnt:1) cost in 1 ms.

使用 ClassLoader 去加载类

  [arthas@8161]$ classloader -c 369500c6 --load java.lang.Stringload class success. class-info        java.lang.String                                                                                                                                                                                                                                            code-source                                                                                                                                                                                                                                                                   name              java.lang.String                                                                                                                                                                                                                                            isInterface       false                                                                                                                                                                                                                                                       isAnnotation      false                                                                                                                                                                                                                                                       isEnum            false                                                                                                                                                                                                                                                       isAnonymousClass  false                                                                                                                                                                                                                                                       isArray           false                                                                                                                                                                                                                                                       isLocalClass      false                                                                                                                                                                                                                                                       isMemberClass     false                                                                                                                                                                                                                                                       isPrimitive       false                                                                                                                                                                                                                                                       isSynthetic       false                                                                                                                                                                                                                                                       simple-name       String                                                                                                                                                                                                                                                      modifier          final,public                                                                                                                                                                                                                                                annotation                                                                                                                                                                                                                                                                    interfaces        java.io.Serializable,java.lang.Comparable,java.lang.CharSequence                                                                                                                                                                                            super-class       +-java.lang.Object                                                                                                                                                                                                                                          class-loader                                                                                                                                                                                                                                                                  classLoaderHash   null     [arthas@8161]$ classloader -c 4b85612c --load demo.MathGameload class success. class-info        demo.MathGame                                                                                                                                                                                                                                               code-source       /usr/local/software/arthas/math-game.jar                                                                                                                                                                                                                    name              demo.MathGame                                                                                                                                                                                                                                               isInterface       false                                                                                                                                                                                                                                                       isAnnotation      false                                                                                                                                                                                                                                                       isEnum            false                                                                                                                                                                                                                                                       isAnonymousClass  false                                                                                                                                                                                                                                                       isArray           false                                                                                                                                                                                                                                                       isLocalClass      false                                                                                                                                                                                                                                                       isMemberClass     false                                                                                                                                                                                                                                                       isPrimitive       false                                                                                                                                                                                                                                                       isSynthetic       false                                                                                                                                                                                                                                                       simple-name       MathGame                                                                                                                                                                                                                                                    modifier          public                                                                                                                                                                                                                                                      annotation                                                                                                                                                                                                                                                                    interfaces                                                                                                                                                                                                                                                                    super-class       +-java.lang.Object                                                                                                                                                                                                                                          class-loader      +-jdk.internal.loader.ClassLoaders$AppClassLoader@4b85612c                                                                                                                                                                                                                      +-jdk.internal.loader.ClassLoaders$PlatformClassLoader@17bb5c0                                                                                                                                                                                            classLoaderHash   4b85612c   

]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>Arthas诊断工具</tag>
      </tags>
  </entry>
  <entry>
    <title>VM虚拟机详解(七)**虚拟机栈Virtual Machine Stacks</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%83)%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88Virtual%20Machine%20Stacks/</url>
    <content><![CDATA[JVM虚拟机详解(七)虚拟机栈Virtual Machine Stacks1. 概述每个 Java 虚拟机线程都有一个专用的 Java 虚拟机堆栈，与线程同时创建。Java 虚拟机堆栈存储帧(2.6)。Java 虚拟机堆栈类似于传统语言(如 c)的堆栈: 它保存局部变量和部分结果，并在方法调用和返回中发挥作用。因为 Java 虚拟机堆栈从来不会被直接操作，除了推送和弹出框架，框架可能会被分配到堆中。Java 虚拟机堆栈的内存不需要是连续的。
在 Java 虚拟机规范的第一版中，Java 虚拟机堆栈被称为 Java 堆栈。
该规范允许 Java 虚拟机堆栈具有固定的大小，或者根据计算的需要动态扩展和收缩。如果 Java 虚拟机堆栈的大小是固定的，那么在创建该堆栈时可以独立地选择每个 Java 虚拟机堆栈的大小。
一个 Java 虚拟机实现可以为程序员或用户提供对 Java 虚拟机堆栈初始大小的控制，以及，在动态扩展或收缩 Java 虚拟机堆栈的情况下，对最大和最小大小的控制。

下列异常情况与 Java 虚拟机堆栈相关:
如果线程中的计算需要比允许的更大的 Java 虚拟机堆栈，则 Java 虚拟机抛出 StackOverflowError。
如果 Java 虚拟机堆栈可以动态扩展，并且尝试扩展，但是没有足够的内存来实现扩展，或者如果没有足够的内存来为新线程创建初始的 Java 虚拟机堆栈，Java 虚拟机抛出 OutOfMemoryError。


默认堆大小：
Xms：初始大小内存，默认为物理内存64&#x2F;1，等价于-XX:InitialHeapSize
Xmx：最大分配内存，默认为物理内存的4&#x2F;1，等价于：-XXMaxHeapSize


默认栈大小：
XX:ThreadStackSize设为0，就是使用“系统默认值”。而在Linux x64上HotSpot VM给Java栈定义的“系统默认”大小也是1MB。



官网：Chapter 2. The Structure of the Java Virtual Machine (oracle.com)

首先栈是运行时的单位，而堆是存储的单位
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。

堆解决的是数据存储的问题，即数据怎么放，放哪里
  




Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。


生命周期
  生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了

作用  - 主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。  - 局部变量，它是相比于成员变量来说的（或属性）  - 基本数据类型变量 VS 引用类型变量（类、数组、接口）
虚拟机栈的特点

栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
JVM直接对Java栈的操作只有两个：
每个方法执行，伴随着进栈（入栈、压栈）
执行结束后的出栈工作




对于栈来说不存在垃圾回收问题

栈不需要GC，但是可能存在OOM

  
  

设置栈内存大小

我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。


Sets the thread stack size (in bytes). Append the letter k or K to indicate KB, m or M to indicate MB, and g or G to indicate GB. The default value depends on the platform:

Linux&#x2F;x64 (64-bit): 1024 KB
macOS (64-bit): 1024 KB
Oracle Solaris&#x2F;x64 (64-bit): 1024 KB
Windows: The default value depends on virtual memory


  The following examples set the thread stack size to 1024 KB in different units:
  -Xss1m-Xss1024k-Xss1048576

举例：
  package com.peppa.stack;/** * 演示栈中的异常：StackOverflowError * @author: peppa * @create: 2022-02-10 15:35:20 */public class StackErrorTest &#123;    private static int count = 1;    /**     * 默认参数：当栈深度达到：9826，出现内存空间不足。报错：Exception in thread &quot;main&quot; java.lang.StackOverflowError     * 添加参数：-Xss128k，当栈深度达到：982。报错：Exception in thread &quot;main&quot; java.lang.StackOverflowError     * 	at java.io.PrintStream.write(PrintStream.java:526)     * 	at java.io.PrintStream.print(PrintStream.java:597)     * 	at java.io.PrintStream.println(PrintStream.java:736)     * @param args     */    public static void main(String[] args) &#123;        System.out.println(count++);        main(args);    &#125;&#125;

2.栈的存储单位
栈中存储什么？

每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。
在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。
栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。


栈运行原理

JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出（后进先出）原则
在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）
执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。
不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。
如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
Java方法有两种返回函数的方式。
一种是正常的函数返回，使用return指令。
另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。
但不管使用哪种方式，都会导致栈帧被弹出。



  
  

栈帧的内部结构
  每个栈帧中存储着：

局部变量表（Local Variables）

操作数栈（operand Stack）（或表达式栈）

动态链接（DynamicLinking）（或指向运行时常量池的方法引用）

方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）

一些附加信息
  
  并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的
  




3.局部变量表
概述：

局部变量表也被称之为局部变量数组或本地变量表
定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。
由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。
方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。
对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。
进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。


局部变量表中的变量只在当前方法调用中有效。
在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。
当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。




关于Slot的理解

参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。

局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。

在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。

byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 1ong和double则占据两个slot。


JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上，如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）

如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。
  



Slot的重复利用
  栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。
  public void test4() &#123;        int a = 0;        &#123;            int b = 0;            b = a + 1;        &#125;        // 变量c使用之前已经销毁的变量b占据的slot的位置        int c = a + 1;    &#125;
  局部变量 c 重用了局部变量 b 的 slot 位置
  

静态变量与局部变量的对比

按数据类型分：基本数据类型、引用数据类型

按类中声明的位置分：成员变量（类变量，实例变量）、局部变量

类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块
实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值
局部变量：在使用前必须进行显式赋值，不然编译不通过。


参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。
  我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。
  和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。

补充说明
  在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
  局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。




4.操作数栈操作数栈：Operand Stack

操作数栈的特点

每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）

操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）

某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，
比如：执行复制、交换、求和等操作

 
 


  操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
  操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.

这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的

  每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。
  栈中的任何一个元素都是可以任意的Java数据类型

32bit的类型占用一个栈单位深度
64bit的类型占用两个栈单位深度

  操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问
  如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。
  操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|
  另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。
  

代码追踪
  public void testAddOperation() &#123;    byte i = 15;    int j = 8;    int k = i + j;&#125;
  使用javap 命令反编译class文件： javap -v 类名.class
  
  byte、short、char、boolean 内部都是使用int型来进行保存的
  从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和 8进行入栈操作
  同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作

一步一步看流程

首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。

  
  执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素
  
  为什么局部变量表不是从0开始的呢？
  其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~
  然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中
  
  
  然后从局部变量表中，依次将数据放在操作数栈中
  
  
  然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置
  
  
  最后PC寄存器的位置指向10，也就是return方法，则直接退出方法
  

栈顶缓存技术
  栈顶缓存技术：Top Of Stack Cashing
  前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。
  由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。


5.动态链接动态链接：Dynamic Linking

动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区

每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令
在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。

比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。
源码：
package com.peppa.linking;public class DynamicLinkingTest &#123;    int num = 10;    public void methodA()&#123;        System.out.println(&quot;methodA()....&quot;);    &#125;    public void methodB()&#123;        System.out.println(&quot;methodB()....&quot;);        methodA();        num++;    &#125;&#125;

对应字节码
public class com.peppa.linking.DynamicLinkingTest  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #8.#24         // com/peppa/linking/DynamicLinkingTest.num:I   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;   #4 = String             #27            // methodA()....   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V   #6 = String             #30            // methodB()....   #7 = Methodref          #8.#31         // com/peppa/linking/DynamicLinkingTest.methodA:()V   #8 = Class              #32            // com/peppa/linking/DynamicLinkingTest   #9 = Class              #33            // java/lang/Object  #10 = Utf8               num  #11 = Utf8               I  #12 = Utf8               &lt;init&gt;  #13 = Utf8               ()V  #14 = Utf8               Code  #15 = Utf8               LineNumberTable  #16 = Utf8               LocalVariableTable  #17 = Utf8               this  #18 = Utf8               Lcom/peppa/linking/DynamicLinkingTest;  #19 = Utf8               methodA  #20 = Utf8               methodB  #21 = Utf8               SourceFile  #22 = Utf8               DynamicLinkingTest.java  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V  #24 = NameAndType        #10:#11        // num:I  #25 = Class              #34            // java/lang/System  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;  #27 = Utf8               methodA()....  #28 = Class              #37            // java/io/PrintStream  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V  #30 = Utf8               methodB()....  #31 = NameAndType        #19:#13        // methodA:()V  #32 = Utf8               com/peppa/linking/DynamicLinkingTest  #33 = Utf8               java/lang/Object  #34 = Utf8               java/lang/System  #35 = Utf8               out  #36 = Utf8               Ljava/io/PrintStream;  #37 = Utf8               java/io/PrintStream  #38 = Utf8               println  #39 = Utf8               (Ljava/lang/String;)V&#123;  int num;    descriptor: I    flags:  public com.peppa.linking.DynamicLinkingTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: bipush        10         7: putfield      #2                  // Field num:I        10: return      LineNumberTable:        line 3: 0        line 4: 4      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      11     0  this   Lcom/peppa/linking/DynamicLinkingTest;  public void methodA();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #4                  // String methodA()....         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 7: 0        line 8: 8      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       9     0  this   Lcom/peppa/linking/DynamicLinkingTest;  public void methodB();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=3, locals=1, args_size=1         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #6                  // String methodB()....         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: aload_0         9: invokevirtual #7                  // Method methodA:()V        12: aload_0        13: dup        14: getfield      #2                  // Field num:I        17: iconst_1        18: iadd        19: putfield      #2                  // Field num:I        22: return      LineNumberTable:        line 11: 0        line 13: 8        line 15: 12        line 16: 22      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      23     0  this   Lcom/peppa/linking/DynamicLinkingTest;&#125;

1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？
2、往上面翻，找到常量池的定义：#7 = Methodref #8.#31

先找 #8 ：
#8 = Class #32 ：去找 #32
#32 = Utf8 com/peppa/linking/DynamicLinkingTest
结论：通过 #8 我们找到了 DynamicLinkingTest 这个类


再来找 #31：
#31 = NameAndType #19:#13 ：去找 #19 和 #13
#19 = Utf8 methodA ：方法名为 methodA
#13 = Utf8 ()V ：方法没有形参，返回值为 void



3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用
4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等

为什么需要运行时常量池？
因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间
常量池的作用：就是为了提供一些符号和常量，便于指令的识别

方法调用：解析与分配

静态链接与动态链接
  在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关

**静态链接：**当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。


早期绑定与晚期绑定
  静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。

早期绑定
  早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

晚期绑定
  如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。



早晚期绑定的发展历史
  随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。
  Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。

虚方法和非虚方法

如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。
静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。
其他方法称为虚方法。


子类对象的多态的使用前提：

类的继承关系
方法的重写


虚拟机中提供了以下几条方法调用指令：

普通调用指令：

invokestatic：调用静态方法，解析阶段确定唯一方法版本
invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本
invokevirtual：调用所有虚方法
invokeinterface：调用接口方法


动态调用指令：

invokedynamic：动态解析出需要调用的方法，然后执行
  前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。





invokednamic指令

JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。
但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。
Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。


动态语言和静态语言

动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。
说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。

  Java：String info = &quot;mogu blog&quot;; (Java是静态类型语言的，会先编译就进行类型检查) JS：var name = &quot;shkstart&quot;; var name = 10; （运行时才进行检查）Python: info = 130.5 (运行时才检查)


Java语言中方法重写的本质

什么是动态分派？

找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。
如果通过则返回这个方法的直接引用，查找过程结束
如果不通过，则返回java.lang.IllegalAccessError 异常


否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。


IllegalAccessError介绍
  程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。

方法的调用：虚方法表

在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】
每个类中都有一个虚方法表，表中存放着各个方法的实际入口。
虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。

  
  如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。




6.方法返回地址
方法的结束

存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：
正常执行完成
出现未处理的异常，非正常退出


无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。
正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。


方法退出的两种方式
  当一个方法开始执行后，只有两种方式可以退出这个方法，

正常退出：

执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；
一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。
在字节码指令中，返回指令包含：
ireturn：当返回值是boolean，byte，char，short和int类型时使用
lreturn：Long类型
freturn：Float类型
dreturn：Double类型
areturn：引用类型
return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法




异常退出：

在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。
方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码

  
  异常处理表：

反编译字节码文件，可得到 Exception table
from ：字节码指令起始地址
to ：字节码指令结束地址
target ：出现异常跳转至地址为 11 的指令执行
type ：捕获异常的类型



  本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。
  正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。


7.一些附加信息虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，成为栈帧信息。
]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(一)JVM与JAVA体系统结构</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%80)JVM%E4%B8%8EJAVA%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[1. Java生态圈Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。

作为一个平台，Java虚拟机扮演着举足轻重的作用
Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分


作为灯种文化，Java几乎成为了“开源”的代名词。
第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。
就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。


作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。


随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。
Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。
2. 字节码我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。
不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。
Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。
3. 多语言混合编程Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。
试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby&#x2F;Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。
对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。
4. Java发展的重大事件
1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java
1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。
1996年1月23日sun Microsystems发布了JDK 1.0。
1998年，JDK1.2版本发布。同时，sun发布了JSP&#x2F;Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。
2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。
2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。
2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。
2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。
2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。
2007年，Java平台迎来了新伙伴Clojure。
2008年，oracle收购了BEA，得到了JRockit虚拟机。
2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。
2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit
2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。
2017年，JDK9发布。将G1设置为默认Gc，替代CMS
同年，IBM的J9开源，形成了现在的open J9社区
2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元
同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会
同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可
2019年，JDK12发布，加入RedHat领导开发的shenandoah GC


在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。
5. 虚拟机与Java虚拟机所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。

大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。
程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。

无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。
6. Java虚拟机Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。
JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。
Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。
Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。
特点：

一次编译，到处运行
自动内存管理
自动垃圾回收功能

7. JVM的位置JVM是运行在操作系统之上的，它与硬件没有直接的交互


Java的体系结构


8. JVM整体结构
HotSpot VM是目前市面上高性能虚拟机的代表作之一。
它采用解释器与即时编译器并存的架构。
在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++程序一较高下的地步。


执行引擎包含三部分：解释器，及时编译器，垃圾回收器
9. Java代码执行流程只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了

10. JVM的架构模型
在文件中找到Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：

基于栈式架构的特点
设计和实现更简单，适用于资源受限的系统；
避开了寄存器的分配难题：使用零地址指令方式分配。
指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。
不需要硬件支持，可移植性更好，更好实现跨平台


基于寄存器架构的特点
典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。
指令集架构则完全依赖硬件，可移植性差
性能优秀和执行更高效
花费更少的指令去完成一项操作。
在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主




两种架构的举例
  同样执行2+3这种逻辑操作，其指令分别如下：

基于栈的计算流程（以Java虚拟机为例）：8个指令

  iconst_2 //常量2入栈istore_1 // 将常量2从操作数栈存付到局部变量表 第2个位置iconst_3 // 常量3入栈istore_2 // 将常量3从操作数栈存付到局部变量表 第3个位置 iload_1 // 加载局部变量第1个变量压入操作数栈iload_2 // 加载局部变量第2个变量压入操作数栈iadd // 常量2/3出栈，执行相加istore_0 // 结果5入栈

而基于寄存器的计算流程

  mov eax,2 //将eax寄存器的值设为1add eax,3 //使eax寄存器的值加3

11. 字节码反编译
我们编写一个简单的代码，然后查看一下字节码的反编译后的结果
  package com.peppa;/** * @author peppa * @create 2022-02-08 15:51:45 */public class StackStruTest &#123;    public static void main(String[] args) &#123;        int i = 2 + 3;    &#125;&#125;

然后我们找到编译后的 class文件，使用下列命令进行反编译
  javap -v StackStruTest.class
  反编译结果：
  public class com.peppa.StackStruTest  minor version: 0  major version: 52  flags: (0x0021) ACC_PUBLIC, ACC_SUPER  this_class: #5                          // com/peppa/StackStruTest  super_class: #6                         // java/lang/Object  interfaces: 0, fields: 0, methods: 2, attributes: 1Constant pool:   #1 = Methodref          #6.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #24.#25        // java/lang/System.out:Ljava/io/PrintStream;   #3 = String             #26            // -----------------   #4 = Methodref          #27.#28        // java/io/PrintStream.println:(Ljava/lang/String;)V   #5 = Class              #29            // com/peppa/StackStruTest   #6 = Class              #30            // java/lang/Object   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               LocalVariableTable  #12 = Utf8               this  #13 = Utf8               Lcom/peppa/StackStruTest;  #14 = Utf8               main  #15 = Utf8               ([Ljava/lang/String;)V  #16 = Utf8               args  #17 = Utf8               [Ljava/lang/String;  #18 = Utf8               i  #19 = Utf8               I  #20 = Utf8               MethodParameters  #21 = Utf8               SourceFile  #22 = Utf8               StackStruTest.java  #23 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V  #24 = Class              #31            // java/lang/System  #25 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;  #26 = Utf8               -----------------  #27 = Class              #34            // java/io/PrintStream  #28 = NameAndType        #35:#36        // println:(Ljava/lang/String;)V  #29 = Utf8               com/peppa/StackStruTest  #30 = Utf8               java/lang/Object  #31 = Utf8               java/lang/System  #32 = Utf8               out  #33 = Utf8               Ljava/io/PrintStream;  #34 = Utf8               java/io/PrintStream  #35 = Utf8               println  #36 = Utf8               (Ljava/lang/String;)V&#123;  public com.peppa.StackStruTest();    descriptor: ()V    flags: (0x0001) ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 6: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/peppa/StackStruTest;

12. JVM生命周期
虚拟机的启动
  Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。

虚拟机的执行

一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。
程序开始执行时他才运行，程序结束时他就停止。
执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。


虚拟机的退出

程序正常执行结束
程序在执行过程中遇到了异常或错误而异常终止
由于操作系统用现错误而导致Java虚拟机进程终止
某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。
除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。



13. JVM发展历程
Sun Classic VM

早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。
这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】
如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。
我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。
而解释器就是走到哪，解释到哪。


现在Hotspot内置了此虚拟机。


Exact VM

为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。
Exact Memory Management：准确式内存管理
也可以叫Non-Conservative&#x2F;Accurate Memory Management
虚拟机可以知道内存中某个位置的数据具体是什么类型。


具备现代高性能虚拟机的维形
热点探测（寻找出热点代码进行缓存）
编译器与解释器混合工作模式


只在Solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换


HotSpot VM（重点）

HotSpot历史
最初由一家名为“Longview Technologies”的小公司设计
1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。
JDK1.3时，HotSpot VM成为默认虚拟机


目前Hotspot占有绝对的市场地位，称霸武林。
不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot
Sun&#x2F;oracle JDK和openJDK的默认虚拟机
因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚机都没有方法区的概念）


从服务器、桌面到移动端、嵌入式都有应用。
名称中的HotSpot指的就是它的热点代码探测技术。
通过计数器找到最具编译价值代码，触发即时编译或栈上替换
通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡




JRockit（商用三大虚拟机之一）

专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。
大量的行业基准测试显示，JRockit JVM是世界上最快的JVM：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。
优势：全面的Java运行时解决方案组合
JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要
Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。


2008年，JRockit被Oracle收购。
Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。
高斯林：目前就职于谷歌，研究人工智能和水下机器人


IBM的J9（商用三大虚拟机之一）

全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9
市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。
目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。
2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9
OpenJDK -&gt; 是JDK开源了，包括了虚拟机


KVM和CDC&#x2F;CLDC Hotspot

Oracle在Java ME产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM
KVM（Kilobyte）是CLDC-HI早期产品
目前移动领域地位尴尬，智能机被Android和iOS二分天下。
KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场
智能控制器、传感器
老人手机、经济欠发达地区的功能手机


所有的虚拟机的原则：一次编译，到处运行。


Azul VM

前面三大“高性能Java虚拟机”使用在通用硬件平台上
这里Azul VW和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机：高性能Java虚拟机中的战斗机。
Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。
每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。
2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。


Liquid VM

高性能Java虚拟机中的战斗机。
BEA公司开发的，直接运行在自家Hypervisor系统上
Liquid VM即是现在的JRockit VE（Virtual Edition）。Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。
随着JRockit虚拟机终止开发，Liquid vM项目也停止了。


Apache Marmony

Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。
它是IElf和Intel联合开发的开源JVM，受到同样开源的Open JDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK
虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。


Micorsoft JVM

微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。
只能在window平台下运行。但确是当时Windows下性能最好的Java VM。
1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。


Taobao JVM

由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。
基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。
基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。
创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。
GCIH中的对象还能够在多个Java虚拟机进程中实现共享
使用crc32指令实现JvM intrinsic降低JNI的调用开销
PMU hardware的Java profiling tool和诊断协助功能
针对大数据场景的ZenGC


taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能


目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。


Dalvik VM

谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。
Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范
不能直接执行Java的Class文件
基于寄存器架构，不是jvm的栈架构。
执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。
它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。


Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。


Graal VM（未来虚拟机）

2018年4月，Oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。
GraalVM在HotSpot VM基础上增强而成的**跨语言全栈虚拟机，可以作为“任何语言”**的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等
支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件
工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。
如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。



6. 总结
具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。

]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(三)**类加载器的分类</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B8%89)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[JVM虚拟机详解(三)类加载器的分类1. 类加载器概述
JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）
从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器
无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示


这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。


我们通过一个类，获取它不同的加载器
  package com.peppa.classloader;/** * @author peppa * @create 2022-02-10 11:25:46 */public class ClassLoaderTest &#123;    public static void main(String[] args) &#123;        // 获取系统类加载器        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);        // 获取其上层的：扩展类加载器        ClassLoader extClassLoader = systemClassLoader.getParent();        System.out.println(extClassLoader);        // 试图获取 根加载器        ClassLoader bootstrapClassLoader = extClassLoader.getParent();        System.out.println(bootstrapClassLoader);        // 获取自定义加载器        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();        System.out.println(classLoader);        // 获取String类型的加载器        ClassLoader classLoader1 = String.class.getClassLoader();        System.out.println(classLoader1);    &#125;&#125;// 执行结果：sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@1b6d3586nullsun.misc.Launcher$AppClassLoader@18b4aac2null
  得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。
  我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，因为引导类加载器右 C&#x2F;C++ 语言，我们获取不到
  两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明系统类加载器是全局唯一的


2.虚拟机自带的加载器
启动类加载器（引导类加载器，Bootstrap ClassLoader）

这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。
它用来加载Java的核心库（JAVAHOME&#x2F;jre&#x2F;1ib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
并不继承自ava.lang.ClassLoader，没有父加载器。
加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类


扩展类加载器（Extension ClassLoader）

Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
派生于ClassLoader类
父类加载器为启动类加载器
从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;1ib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。


应用程序类加载器（系统类加载器，AppClassLoader）

javI语言编写，由sun.misc.LaunchersAppClassLoader实现
派生于ClassLoader类
父类加载器为扩展类加载器
它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器


用户自定义类加载器
  在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？

隔离加载类
修改类加载的方式
扩展加载源
防止源码泄漏

  用户自定义类加载器实现步骤：

开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中
在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。



3.查看根加载器所能加载的目录刚刚我们通过概念了解到了，根加载器只能够加载 java &#x2F;lib目录下的class，我们通过下面代码验证一下
package com.peppa.classloader;import java.net.URL;import java.security.Provider;/** * @author peppa * @create 2022-02-10 11:42:4 */public class ClassLoaderPathTest &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;*********启动类加载器************&quot;);        // 获取BootstrapClassLoader 能够加载的API的路径        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();        for (URL url : urls) &#123;            System.out.println(url.toExternalForm());        &#125;        // 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器        ClassLoader classLoader = Provider.class.getClassLoader();        System.out.println(&quot;classLoader ==&gt;&quot;+classLoader);    &#125;&#125;// 得到的结果*********启动类加载器************file:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/resources.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/rt.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/sunrsasign.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/jsse.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/jce.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/charsets.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/lib/jfr.jarfile:/D:/software/Java/jdk1.8/jdk1.8.0_241/jre/classesclassLoader ==&gt;null

4. 关于ClassLoader
ClassLoader 类介绍
  ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）
  

sun.misc.Launcher 它是一个java虚拟机的入口应用




获取ClassLoader的途径
获取当前ClassLoader：clazz.getClassLoader()
获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()
获取系统的ClassLoader：ClassLoader.getSystemClassLoader()
获取调用者的ClassLoader：DriverManager.getCallerClassLoader()



5.双亲委派机制Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；
如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常



双亲委派机制举例
  当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。
  

沙箱安全机制
  自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。

双亲委派机制的优势
  通过上面的例子，我们可以知道，双亲机制可以

避免类的重复加载
保护程序安全，防止核心API被随意篡改
自定义类：java.lang.String
自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）




其他

如何判断两个class对象是否相同？
  在JVM中表示两个class对象是否为同一个类存在两个必要条件：

类的完整类名必须一致，包括包名
加载这个类的ClassLoader（指ClassLoader实例对象）必须相同
换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的


对类加载器的引用

JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的
如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中





]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(九)方法区**Method Area</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%B9%9D)%E6%96%B9%E6%B3%95%E5%8C%BAMethod%20Area/</url>
    <content><![CDATA[JVM虚拟机详解(九)方法区Method Area1. 栈、堆、方法区的交互关系
从线程共享与否的角度来看

ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。

  

从线程共享与否的角度来看
  ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理


  
  

栈、堆、方法区的交互关系

下面就涉及了对象的访问定位

  

Person：存放在元空间，也可以说方法区
person：存放在Java栈的局部变量表中
new Person()：存放在Java堆中


方法区的理解

《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。所以，方法区看作是一块独立于Java堆的内存空间。

  
  方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。
方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。
方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace
加载大量的第三方的jar包
Tomcat部署的工程过多（30~50个）
大量动态的生成反射类


关闭JVM就会释放这个区域的内存。


HotSpot中方法区的演进
  在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。

JDK 1.8后，元空间存放在堆外内存中

  本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。
  现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）
  
  而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替
  
  元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存
  永久代、元空间二者并不只是名字变了，内部结构也调整了
  根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常
  

设置方法区大小与OOM

方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。


jdk7及以前

通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M

XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M

当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。
  

JDK8以后
  元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定
  默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。
  与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace

XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。

  如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。



如何解决这些OOM

要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）
内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题


如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。



2.方法区的内部结构
关系图
  《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。





类型信息
  对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：

这个类型的完整有效名称（全名&#x3D;包名.类名）
这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）
这个类型的修饰符（public，abstract，final的某个子集）
这个类型直接接口的一个有序列表


域信息
  JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
  域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）

方法（Method）信息
  JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

方法名称
方法的返回类型（或void）
方法参数的数量和类型（按顺序）
方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
异常表（abstract和native方法除外）


每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引


non-final的类变量
  静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分
  类变量被类的所有实例共享，即使没有类实例时，你也可以访问它
  package com.peppa.area;/** * non-final的类变量 * * @author: peppa * @create: 2022-02-12 18:42:45 */public class MethodAreaTest &#123;    public static void main(String[] args) &#123;        Order order = new Order();        order.hello();        System.out.println(order.count);    &#125;&#125;class Order &#123;    public static int count = 1;    public static final int number = 2;    public static void hello() &#123;        System.out.println(&quot;hello!&quot;);    &#125;&#125;// 执行结果：// hello!// 1
  如上代码所示，即使我们把order设置为null，也不会出现空指针异常

全局常量：static final

全局常量就是使用 static final 进行修饰
被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。

  查看上面代码，这部分的字节码指令
  class Order &#123;    public static int count = 1;    public static final int number = 2;    ...&#125;
  public static int count;    descriptor: I    flags: ACC_PUBLIC, ACC_STATIC  public static final int number;    descriptor: I    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL    ConstantValue: int 2
  可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。****


3.常量池
常量池概述

官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html
  

方法区，内部包含了运行时常量池
字节码文件，内部包含了常量池
要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。
要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。




常量池
  一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用
  

为什么需要常量池
  一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。
  比如：如下的代码：
  public class SimpleClass &#123;    public void sayHello() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;

虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。
比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过引用的方式，来加载、调用所需的结构
这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。


常量池中有啥？

数量值
字符串值
类引用
字段引用
方法引用

  例如下面这段代码
  package com.peppa.area;public class MethodAreaTest2 &#123;    public static void main(String args[]) &#123;        Object obj = new Object();    &#125;&#125;
  将会被翻译成如下字节码
  0: new           #2                  // class java/lang/Object3: dup4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V7: astore_18: return

常量池总结
  常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。


4.运行时常量池
运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。
常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。（运行时常量池就是常量池在程序运行时的称呼）
运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。


运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。
当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。


方法区的使用举例

代码
  package com.peppa.area;public class MethodAreaDemo &#123;    public static void main(String[] args) &#123;        int x = 500;        int y = 100;        int a = x / y;        int b = 50;        System.out.println(a + b);    &#125;&#125;

字节码
  public class com.peppa.area.MethodAreaDemo  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #5.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;   #3 = Methodref          #28.#29        // java/io/PrintStream.println:(I)V   #4 = Class              #30            // com/peppa/area/MethodAreaDemo   #5 = Class              #31            // java/lang/Object   #6 = Utf8               &lt;init&gt;   #7 = Utf8               ()V   #8 = Utf8               Code   #9 = Utf8               LineNumberTable  #10 = Utf8               LocalVariableTable  #11 = Utf8               this  #12 = Utf8               Lcom/peppa/area/MethodAreaDemo;  #13 = Utf8               main  #14 = Utf8               ([Ljava/lang/String;)V  #15 = Utf8               args  #16 = Utf8               [Ljava/lang/String;  #17 = Utf8               x  #18 = Utf8               I  #19 = Utf8               y  #20 = Utf8               a  #21 = Utf8               b  #22 = Utf8               MethodParameters  #23 = Utf8               SourceFile  #24 = Utf8               MethodAreaDemo.java  #25 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V  #26 = Class              #32            // java/lang/System  #27 = NameAndType        #33:#34        // out:Ljava/io/PrintStream;  #28 = Class              #35            // java/io/PrintStream  #29 = NameAndType        #36:#37        // println:(I)V  #30 = Utf8               com/peppa/area/MethodAreaDemo  #31 = Utf8               java/lang/Object  #32 = Utf8               java/lang/System  #33 = Utf8               out  #34 = Utf8               Ljava/io/PrintStream;  #35 = Utf8               java/io/PrintStream  #36 = Utf8               println  #37 = Utf8               (I)V&#123;  public com.peppa.area.MethodAreaDemo();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 3: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/peppa/area/MethodAreaDemo;  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=3, locals=5, args_size=1         0: sipush        500         3: istore_1         4: bipush        100         6: istore_2         7: iload_1         8: iload_2         9: idiv        10: istore_3        11: bipush        50        13: istore        4        15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;        18: iload_3        19: iload         4        21: iadd        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V        25: return      LineNumberTable:        line 5: 0        line 6: 4        line 7: 7        line 8: 11        line 9: 15        line 10: 25      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      26     0  args   [Ljava/lang/String;            4      22     1     x   I            7      19     2     y   I           11      15     3     a   I           15      11     4     b   I    MethodParameters:      Name                           Flags      args&#125;


图解字节码指令执行流程
  
  首先现将操作数500放入到操作数栈中
  
  然后存储到局部变量表中
  
  然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作
  
  将500 和 100 进行一个除法运算，在把结果入栈
  
  在最后就是输出流，需要调用运行时常量池的常量
  
  最后调用invokevirtual（虚方法调用），然后返回
  
  返回时
  
  程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。
  符号引用 –&gt; 直接引用：

上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载
如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）



5.方法区的演进细节
永久代演进过程

首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。


Hotspot中方法区的变化：
  JDK1.6及以前	  有永久代（permanent generation），静态变量存储在永久代上JDK1.7	       有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中JDK1.8	       无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。

JDK6
  方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）
  

JDK7
  方法区由永久代实现，使用 JVM 虚拟机内存
  

JDK8
  元空间大小只受物理内存影响
  

永久代为什么要被元空间替代？

官方文档：JEP 122: Remove the Permanent Generation (java.net)


随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。
由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
这项改动是很有必要的，原因有：
为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。
对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低Full GC
有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。
一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。






字符串常量池 StringTable 为什么要调整位置？

JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。
这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。


方法区的垃圾回收

有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。

一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。

方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。

先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：

类和接口的全限定名
字段的名称和描述符
方法的名称和描述符


HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。

回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）



类卸载

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用**-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading**查看类加载和卸载信息
在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

  


6.直接内存 Direct Memory
直接内存概述

不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。
直接内存是在Java堆外的、直接向系统申请的内存区间。
来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存
通常，访问直接内存的速度会优于Java堆。即读写性能高。
因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。
Java的NIO库允许Java程序使用直接内存，用于数据缓冲区


使用下列代码，直接分配本地内存空间


int BUFFER = 1024*1024*1024; // 1GBByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);


非直接缓存区和缓存区

NIO的方式使用了缓存区的概念


存在的问题
  也可能导致outofMemoryError异常
  由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 缺点

分配回收成本较高
不受JVM内存回收管理

  直接内存大小可以通过MaxDirectMemorySize设置
  如果不指定，默认与堆的最大值-xmx参数值一致
  


]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(二)**类加载子系统</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%BA%8C)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[JVM虚拟机详解(二)类加载子系统1. 内存结构概述

💡 注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有




2.类加载器子系统
类加载器子系统作用：

类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。
ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。
加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）

  


3. 类加载器ClassLoader角色
class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。
class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。
在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。


4.类加载过程例如下面的一段简单的代码
/** * 类加载子系统 * @author peppa * @create 2022-02-08 16:51:45 */public class HelloLoader &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;我已经被加载啦...&quot;);    &#125;&#125;


它的加载过程是怎么样的呢?

执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader
加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main
加载失败则抛出异常

  
  完整的流程图如下所示
  


5. 加载阶段
加载：

通过一个类的全限定名获取定义此类的二进制字节流
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口


加载class文件的方式

从本地系统中直接加载
通过网络获取，典型场景：Web Applet
从zip压缩包中读取，成为日后jar、war格式的基础
运行时计算生成，使用最多的是：动态代理技术
由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见
从加密文件中获取，典型的防Class文件被反编译的保护措施



6. 链接阶段链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析

验证(Verify)

目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。


举例
  使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。
  工具：Binary Viewer查看，工具下载地址：Binary Viewer Page (proxoft.com)
  
  如果出现不合法的字节码文件，那么将会验证不通过，同时我们可以通过安装IDEA的插件，来查看我们的Class文件

安装Binary Viewer
  同时我们可以通过安装IDEA的插件，来查看我们的Class文件
  

配置插件参数
  点击Help，点击Edit Custom Vm Options…，增加以下配置后重启IDEA。
  -Duser.language=en-Duser.region=CN
  安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了
  



准备(Prepare)

为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值
这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化
注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中


举例

  代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1
  /** * @author peppa * @create 2022-02-08 17:36:28 */public class HelloApp &#123;    private static int a = 1;  // 准备阶段为0，在下个阶段，也就是初始化的时候才是1    public static void main(String[] args) &#123;        System.out.println(a);    &#125;&#125;

解析(Resolve)

将常量池内的符号引用转换为直接引用的过程
事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行
符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等


符号引用

反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用

  




7.初始化阶段
类的初始化时机

创建类的实例
访问某个类或接口的静态变量，或者对该静态变量赋值
调用类的静态方法
反射（比如：Class.forName(“com.atguigu.Test”)）
初始化一个类的子类
Java虚拟机启动时被标明为启动类的类
JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

  除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）
  

构造器方法&lt;clinit&gt;()方法

初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程
此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法
&lt;clinit&gt;()方法中的指令按语句在源文件中出现的顺序执行
&lt;clinit&gt;()不同于类的构造器。（关联：构造器是虚拟机视角下的&lt;init&gt;()）
若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕
虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁


案例1：有static变量
  查看下面这个代码的字节码，可以发现有一个&lt;clinit&gt;()方法。
  package com.peppa;/** * @author peppa * @create 2022-02-09 20:38:46 */public class ClassInitTest &#123;    private static int age = 1;    static &#123;        age = 2;        number = 20;        System.out.println(age);        // System.out.println(number);  //报错：Illegal forward reference 非法的前向引用    &#125;    /**     * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10     * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会     * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）     */    private static int number = 10;    public static void main(String[] args) &#123;        System.out.println(ClassInitTest.age); // 2        System.out.println(ClassInitTest.number); // 10    &#125;&#125;
  

&lt;clint字节码&gt;：当我们代码中包含static变量的时候，就会有clinit方法

  0: iconst_11: putstatic     #3                   // Field age:I4: iconst_25: putstatic     #3                   // Field age:I8: bipush        20                   // 先赋20                    10: putstatic     #5                  // Field number:I13: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;16: getstatic     #3                  // Field age:I19: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V22: bipush        10                  // 再赋10       24: putstatic     #5                  // Field number:I27: return

案例2：无static变量


package com.peppa;/** * @author peppa * @create 2022-02-09 20:38:46 */public class NonStaticClassInitTest &#123;    private int age = 1;    private int number = 10;    public static void main(String[] args) &#123;        System.out.println(&quot;this is NonStaticClassInitTest.class&quot;);    &#125;&#125;



案例3：关于涉及到父类时候的变量赋值过程

若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕

  package com.peppa;/** * @author peppa * @create 2022-02-09 22:32:26 */public class SubClassInitTest &#123;    static class Animal &#123;        public static int A = 1;        static &#123;            A = 2;        &#125;    &#125;    static class Dog extends Animal &#123;        public static int B = A;    &#125;    public static void main(String[] args) &#123;        System.out.println(Dog.B);  // 2    &#125;&#125;
  如上代码，加载流程如下：

首先，执行 main() 方法需要加载 SubClassInitTest 类
获取 Dog .B 静态变量，需要加载 Dog 类
Dog 类的父类是 Animal 类，所以需要先执行 Animal 类的加载，再执行 Dog 类的加载


案例4：虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁
  package com.peppa;public class DeadThreadTest &#123;    public static void main(String[] args) &#123;        Runnable r = () -&gt; &#123;            System.out.println(Thread.currentThread().getName() + &quot;开始&quot;);            DeadThread dead = new DeadThread();            System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);        &#125;;        Thread t1 = new Thread(r,&quot;线程1&quot;);        Thread t2 = new Thread(r,&quot;线程2&quot;);        t1.start();        t2.start();    &#125;&#125;class DeadThread&#123;    static&#123;        if(true)&#123;            System.out.println(Thread.currentThread().getName() + &quot;初始化当前类&quot;);            while(true)&#123;            &#125;        &#125;    &#125;&#125;// 执行结果:	线程2开始	线程1开始	线程2初始化当前类	/**然后程序卡死了**/
  程序卡死，分析原因：

两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环
先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放
所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(五)**程序计数器(PC寄存器)PC Register</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E4%BA%94)%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8(PC%E5%AF%84%E5%AD%98%E5%99%A8)PC%20Register/</url>
    <content><![CDATA[JVM虚拟机详解(五)程序计数器(PC寄存器)PC Register1. 概述Java 虚拟机可以同时支持多个线程的执行(jls17)。每个 Java 虚拟机线程都有自己的 pc (程序计数器)寄存器。在任何时候，每个 Java 虚拟机线程都在执行单个方法的代码，即该线程的当前方法(2.6)。如果这个方法不是本机的，那么 pc 寄存器就会包含当前正在执行的 Java 虚拟指令的地址。如果当前由线程执行的方法是本机的，那么 Java 虚拟机的 pc 寄存器的值是未定义的。Java 虚拟机的 pc 寄存器足够宽，可以在特定平台上保存 returnAddress 或本机指针。
官网：The Java® Virtual Machine Specification (oracle.com)


JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。
这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。
它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。
它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。


作用
  PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。
  
  内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。

代码实现
  package com.peppa.register;/**程序计数器 * @author: peppa * @create: 2022-02-10 13:25:3 */public class PCRegisterTest &#123;    public static void main(String[] args) &#123;        int i = 10;        int j = 20;        int k = i + j;    &#125;&#125;
  然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。
  0: bipush        102: istore_13: bipush        205: istore_26: iload_17: iload_28: iadd9: istore_310: return
  通过PC寄存器，我们就可以知道当前程序执行到哪一步了
  
  

使用PC寄存器存储字节码指令地址有什么用呢？
  因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
  JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
  

PC寄存器为什么被设定为私有的？

我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。
由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。
这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。



2.CPU 时间片
CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。
在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。


]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(八)堆Heap</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%85%AB)%E5%A0%86Heap/</url>
    <content><![CDATA[JVM虚拟机详解(八)堆Heap1. 概述
概述
Java 虚拟机有一个堆，它在所有 Java 虚拟机线程之间共享。堆是运行时数据区域，从中分配所有类实例和数组的内存。
在虚拟机启动时创建堆。对象的堆存储由自动存储管理系统(称为垃圾收集器)回收; 对象永远不会显式释放。Java 虚拟机没有特定类型的自动存储管理系统，可以根据实现者的系统需求选择存储管理技术。堆的大小可以是固定的，也可以根据计算的需要进行扩展，如果不需要更大的堆，还可以进行收缩。堆的内存不需要是连续的。
一个 Java 虚拟机实现可以提供程序员或用户对堆的初始大小的控制，以及，如果堆可以动态扩展或收缩，对堆的最大和最小大小的控制。
所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。
《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）• 从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）
数组和对象可能永远不会存储在栈上（不一定），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
也就是触发了GC的时候，才会进行回收
如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word


堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。


下列异常情况与堆相关联:
如果计算需要比自动存储管理系统所能提供的更多的堆，那么 Java 虚拟机将抛出 OutOfMemoryError 错误。


默认堆大小：
Xms：初始大小内存，默认为物理内存64&#x2F;1，等价于-XX:InitialHeapSize
Xmx：最大分配内存，默认为物理内存的4&#x2F;1，等价于：-XXMaxHeapSize



官网：Chapter 2. The Structure of the Java Virtual Machine (oracle.com)



堆内存细分
  现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：

Java7 及之前堆内存逻辑上分为三部分：新生代+老年代+永久区
Young Generation Space 新生代 Young&#x2F;New
又被划分为Eden区和Survivor区


Old generation space 老年代 Old&#x2F;Tenure
Permanent Space 永久区 Perm


Java 8及之后堆内存逻辑上分为三部分：新生代+老年代+元空间


Young Generation Space 新生代，又被划分为Eden区和Survivor区
Old generation space 老年代
Meta Space 元空间 Meta

  


堆空间内部结构，JDK1.8之前从永久代 替换成 元空间

2.JVisualVM可视化查看堆内存运行代码
package com.peppa.heap;import java.util.concurrent.TimeUnit;public class HeapDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        System.out.println(&quot;start...&quot;);        TimeUnit.MINUTES.sleep(30);        System.out.println(&quot;end...&quot;);    &#125;&#125;

1、双击jdk目录下的这个文件

2、工具 -&gt; 插件 -&gt; 安装Visual GC插件

3、运行上面的代码
3.设置堆内存大小与OOM
设置堆内存

Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。

Xms用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**
Xmx则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**


一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。

通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。

原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。
如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM


默认情况下:

初始内存大小：物理电脑内存大小&#x2F;64
最大内存大小：物理电脑内存大小&#x2F;4

 package com.peppa.heap;/** * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小 *  -X：是jvm运行参数 *  ms：memory start * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小 * @author peppa * @create 2022-02-11 14:33:20 */public class HeapSpaceInitial &#123;    public static void main(String[] args) &#123;        // 返回Java虚拟机中的堆内存总量        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;        // 返回Java虚拟机试图使用的最大堆内存        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;        System.out.println(&quot;-Xms:&quot; + initialMemory + &quot;M&quot;);        System.out.println(&quot;-Xmx:&quot; + maxMemory + &quot;M&quot;);    &#125;&#125;// 输出结果-Xms:303M-Xmx:4482M


如何查看堆内存的内存分配情况

jps  -&gt;  staat -gc  进程id
  参数说明：

SOC: S0区总共容量
S1C: S1区总共容量
S0U: S0区使用的量
S1U: S1区使用的量
EC: 伊甸园区总共容量
EU: 伊甸园区使用的量
OC: 老年代总共容量
OU: 老年代使用的量

  
  -XX:+PrintGCDetails
  



OutOfMemory测试


添加参数：Xms600m -Xmx600m -XX:+PrintGCDetails
package com.peppa.heap;import java.util.ArrayList;import java.util.List;public class OutOfMemoryTest &#123;    public static void main(String[] args) &#123;        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();        while (true)&#123;            list.add(new byte[1024*1024]);        &#125;    &#125;&#125;

 执行结果：
D:\software\Java\jdk1.8\jdk1.8.0_241\bin\java.exe -Xms600m -Xmx600m -XX:+PrintGCDetails &quot;-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2021.3.1\lib\idea_rt.jar=4979:D:\Program Files\JetBrains\IntelliJ IDEA 2021.3.1\bin&quot; -Dfile.encoding=UTF-8 -classpath D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\charsets.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\deploy.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\access-bridge-64.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\cldrdata.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\dnsns.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\jaccess.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\jfxrt.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\localedata.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\nashorn.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\sunec.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\sunjce_provider.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\sunmscapi.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\sunpkcs11.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\ext\zipfs.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\javaws.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\jce.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\jfr.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\jfxswt.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\jsse.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\management-agent.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\plugin.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\resources.jar;D:\software\Java\jdk1.8\jdk1.8.0_241\jre\lib\rt.jar;E:\workspace\IdeaWork\other\peppa-platform\peppa-jvm\target\classes com.peppa.heap.OutOfMemoryTest[GC (Allocation Failure) [PSYoungGen: 152578K-&gt;25384K(179200K)] 152578K-&gt;145202K(588800K), 0.0190912 secs] [Times: user=0.05 sys=0.08, real=0.02 secs] [GC (Allocation Failure) [PSYoungGen: 178893K-&gt;25336K(179200K)] 298711K-&gt;297740K(588800K), 0.0233429 secs] [Times: user=0.05 sys=0.06, real=0.02 secs] [Full GC (Ergonomics) [PSYoungGen: 25336K-&gt;0K(179200K)] [ParOldGen: 272404K-&gt;297589K(409600K)] 297740K-&gt;297589K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0556161 secs] [Times: user=0.28 sys=0.00, real=0.05 secs] [Full GC (Ergonomics) [PSYoungGen: 153530K-&gt;37888K(179200K)] [ParOldGen: 297589K-&gt;409208K(409600K)] 451120K-&gt;447096K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0254560 secs] [Times: user=0.06 sys=0.05, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 153506K-&gt;152578K(179200K)] [ParOldGen: 409208K-&gt;409208K(409600K)] 562714K-&gt;561786K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0175328 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] [Full GC (Allocation Failure) [PSYoungGen: 152578K-&gt;152578K(179200K)] [ParOldGen: 409208K-&gt;409190K(409600K)] 561786K-&gt;561768K(588800K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0235650 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] Heap PSYoungGen      total 179200K, used 153600K [0x00000000f3800000, 0x0000000100000000, 0x0000000100000000)  eden space 153600K, 100% used [0x00000000f3800000,0x00000000fce00000,0x00000000fce00000)  from space 25600K, 0% used [0x00000000fe700000,0x00000000fe700000,0x0000000100000000)  to   space 25600K, 0% used [0x00000000fce00000,0x00000000fce00000,0x00000000fe700000) ParOldGen       total 409600K, used 409194K [0x00000000da800000, 0x00000000f3800000, 0x00000000f3800000)  object space 409600K, 99% used [0x00000000da800000,0x00000000f379abf0,0x00000000f3800000) Metaspace       used 3260K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: **Java heap space**	at com.peppa.heap.OutOfMemoryTest.main(OutOfMemoryTest.java:10)

4.年轻代与老年代
存储对象划分：

存储在JVM中的Java对象可以被划分为两类：
一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速，生命周期短的，及时回收即可。
另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致


Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）
其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）

  
  下面这参数开发中一般不会调：
  

配置新生代与老年代在堆结构的占比
默认**-XX:NewRatio**&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3
可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5




在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，
当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8
几乎所有的Java对象都是在Eden区被new出来的。
绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。

  


5.图解对象分配过程
概念
  为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

new的对象先放伊甸园区。此区有大小限制。
当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
然后将伊甸园中的剩余对象移动到幸存者0区。
如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。
如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
啥时候能去养老区呢？可以设置次数。默认是15次。
在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理
若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。

  可以设置参数：-Xx:MaxTenuringThreshold&#x3D; N进行设置
  

图解过程
  我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC &#x2F; Minor GC操作
  
  当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。
  同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1
  
  我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中
  

幸存区区满了后？
  特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作
  如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代

对象分配的特殊情况

如果来了一个新对象，先看看 Eden 是否放的下？
如果 Eden 放得下，则直接放到 Eden 区
如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？


将对象放到老年区又有两种情况：
如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代
那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM


如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区

  
  

代码演示对象分配过程


我们不断的创建大对象
package com.peppa.heap;import java.util.ArrayList;import java.util.Random;/** * 代码演示对象创建过程 * * @author: peppa * @create: 2022-02-11 17:27:58 */public class HeapInstanceTest &#123;    byte [] buffer = new byte[new Random().nextInt(1024 * 200)];    public static void main(String[] args) throws InterruptedException &#123;        ArrayList&lt;HeapInstanceTest&gt; list = new ArrayList&lt;&gt;();        while (true) &#123;            list.add(new HeapInstanceTest());            Thread.sleep(10);        &#125;    &#125;&#125;

然后设置JVM参数：-Xms600m -Xmx600m
打开VisualVM图形化界面

最终，在老年代和新生代都满了，就出现OOM
D:\software\Java\jdk1.8\jdk1.8.0_241\bin\java.exe -Xms600m -Xmx600mException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space	at com.peppa.heap.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:12)	at com.peppa.heap.HeapInstanceTest.main(HeapInstanceTest.java:16)Process finished with exit code 1


常用调优工具

JDK命令行
Eclipse：Memory Analyzer Tool
Jconsole
Visual VM（实时监控，推荐）
Jprofiler（IDEA插件）
Java Flight Recorder（实时监控）
GCViewer
GCEasy


GC分类

Minor GC，MajorGC、Full GC

Minor GC：新生代的GC
Major GC：老年代的GC
Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集


我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题，而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上


部分收集（Partial GC）&amp;&amp; 整堆收集（FullGC）

新生代收集（MinorGC&#x2F;YoungGC）：只是新生代的垃圾收集
老年代收集（MajorGC&#x2F;o1dGC）：只是老年代的圾收集。
目前，只有CMSGC会有单独收集老年代的行为。
注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。




整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。

Young GC
  当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）
  因为Java对象大多都具备 朝生夕灭 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
  Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行
  

老年代GC（MajorGC）触发机制

指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了
出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）
也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC


Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。
如果Major GC后，内存还不足，就报OOM了


触发Full GC执行的情况有如下五种：

调用System.gc()时，系统建议执行FullGC，但是不必然执行
老年代空间不足
方法区空间不足
通过Minor GC后进入老年代的平均大小大于老年代的可用内存
由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小




GC日志分析
  package com.peppa.gc;import java.util.ArrayList;import java.util.List;/** * 测试MinorGC 、 MajorGC、FullGC * -Xms9m -Xmx9m -XX:+PrintGCDetails * @author shkstart  shkstart@126.com * @create 2020  14:19 */public class GCTest &#123;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            List&lt;String&gt; list = new ArrayList&lt;&gt;();            String a = &quot;this is peppa&quot;;            while (true) &#123;                list.add(a);                a = a + a;                i++;            &#125;        &#125; catch (Throwable t) &#123;            t.printStackTrace();            System.out.println(&quot;遍历次数为：&quot; + i);        &#125;    &#125;&#125;
  输出：
  [GC (Allocation Failure) [PSYoungGen: 1964K-&gt;510K(2560K)] 1964K-&gt;826K(9728K), 0.0008721 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2361K-&gt;496K(2560K)] 2677K-&gt;1489K(9728K), 0.0007112 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1796K-&gt;384K(2560K)] 2790K-&gt;2417K(9728K), 0.0009442 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 2151K-&gt;0K(2560K)] [ParOldGen: 7025K-&gt;5682K(7168K)] 9177K-&gt;5682K(9728K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0029911 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5682K-&gt;5682K(9728K), 0.0004552 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5682K-&gt;5599K(7168K)] 5682K-&gt;5599K(9728K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0058927 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 遍历次数为：16Heap PSYoungGen      total 2560K, used 101K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  eden space 2048K, 4% used [0x00000000ffd00000,0x00000000ffd19568,0x00000000fff00000)  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen       total 7168K, used 5599K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  object space 7168K, 78% used [0x00000000ff600000,0x00000000ffb77d90,0x00000000ffd00000) Metaspace       used 3259K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576Kjava.lang.OutOfMemoryError: Java heap space	at java.util.Arrays.copyOf(Arrays.java:3332)	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)	at java.lang.StringBuilder.append(StringBuilder.java:136)	at com.peppa.gc.GCTest.main(GCTest.java:20)Process finished with exit code 0
  [GC (Allocation Failure) [PSYoungGen: 1964K-&gt;510K(2560K)] 1964K-&gt;826K(9728K), 0.0008721 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[PSYoungGen: 1964K-&gt;510K(2560K)]：年轻代总空间为 2560K ，当前占用 1964K ，经过垃圾回收后剩余510K****
1964K-&gt;826K(9728K)：堆内存总空间为 9728K ，当前占用1964K，经过垃圾回收后剩余826K

  
  
  

堆空间分代思想
  为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。

新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。
老年代：存放新生代中经历多次GC仍然存活的对象。

  
  其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。
  
  

内存分配策略
  如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代
  对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置
  针对不同年龄段的对象分配原则如下所示：

优先分配到Eden
开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢


大对象直接分配到老年代
尽量避免程序中出现过多的大对象


长期存活的对象分配到老年代
动态对象年龄判断
如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。



  空间分配担保： -Xx:HandlePromotionFailure

也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。


为对象分配内存：TLAB

问题：堆空间都是共享的么？
  不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占

为什么有TLAB？
  从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
  多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。
  据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。
  
  尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
  在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。
  默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。
  一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

TLAB分配过程
  对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配
  



小结：堆空间的参数设置

XX：+PrintFlagsInitial：查看所有的参数的默认初始值
XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）
Xms：初始堆空间内存（默认为物理内存的1&#x2F;64）
Xmx：最大堆空间内存（默认为物理内存的1&#x2F;4）
Xmn：设置新生代的大小。（初始值及最大值）
XX:NewRatio：配置新生代与老年代在堆结构的占比
XX:SurvivorRatio：设置新生代中Eden和S0&#x2F;S1空间的比例
XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄
XX：+PrintGCDetails：输出详细的GC处理日志
打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc


XX:HandlePromotionFalilure：是否设置空间分配担保

  在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。

如果大于，则此次Minor GC是安全的
如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。
如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
如果小于，则改为进行一次FullGC。
如果HandlePromotionFailure&#x3D;false，则改为进行一次Full GC



  在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。

堆是分配对象的唯一选择么？
  在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：

随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。
在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。
此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。



6.逃逸分析
逃逸分析

如何将堆上的对象分配到栈，需要使用逃逸分析手段。
这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
逃逸分析的基本行为就是分析对象动态作用域：
当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。




逃逸分析举例

没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）

  public void my_method() &#123;    V v = new V();    // use v    // ....    v = null;&#125;

下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配

  public static StringBuffer createStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb;&#125;

如果想要StringBuffer sb不发生逃逸，可以这样写

  public static String createStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb.toString();&#125;
  /** * 逃逸分析 * *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。 */public class EscapeAnalysis &#123;    public EscapeAnalysis obj;    /*    方法返回EscapeAnalysis对象，发生逃逸     */    public EscapeAnalysis getInstance()&#123;        return obj == null? new EscapeAnalysis() : obj;    &#125;    /*    为成员属性赋值，发生逃逸     */    public void setObj()&#123;        this.obj = new EscapeAnalysis();    &#125;    //思考：如果当前的obj引用声明为static的？仍然会发生逃逸。    /*    对象的作用域仅在当前方法中有效，没有发生逃逸     */    public void useEscapeAnalysis()&#123;        EscapeAnalysis e = new EscapeAnalysis();    &#125;    /*    引用成员变量的值，发生逃逸     */    public void useEscapeAnalysis1()&#123;        EscapeAnalysis e = getInstance();        //getInstance().xxx()同样会发生逃逸    &#125;&#125;

逃逸分析参数设置

在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析
如果使用的是较早的版本，开发人员则可以通过：
选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析
通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果




结论
  开发中能使用局部变量的，就不要使用在方法外定义。
  使用逃逸分析，编译器可以对代码做如下优化：

栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配
同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。



7.栈上分配
栈上分配举例

JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。
常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。


举例

设置JVM参数，表示未开启逃逸分析
  package com.peppa.heap;import java.util.concurrent.TimeUnit;/** * 栈上分配： * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails * 开启逃逸分析： * -Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails */public class StackAllocation &#123;    public static void main(String[] args) throws InterruptedException &#123;        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10000000; i++) &#123;            alloc();        &#125;        // 查看执行时间        long end = System.currentTimeMillis();        System.out.println(&quot;花费的时间为： &quot; + (end - start) + &quot; ms&quot;);        // 为了方便查看堆内存中对象个数，线程sleep        TimeUnit.MINUTES.sleep(1);    &#125;    private static void alloc() &#123;        User user = new User();//未发生逃逸    &#125;    static class User &#123;        private String name;        private String age;        private String gender;        private String phone;    &#125;&#125;

参数：-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails

运行结果，同时还触发了GC操作
  [GC (Allocation Failure) [PSYoungGen: 262144K-&gt;728K(305664K)] 262144K-&gt;736K(1005056K), 0.0007353 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 花费的时间为： 120 ms


我们开启逃逸分析

参数：-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails

运行结果：日志打印：并没有发生 GC ，耗时5ms 。
  花费的时间为： 5 ms



8.同步省略
概述：线程同步的代价是相当高的，同步的后果是降低并发性和性能。
  在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。
  例如下面的代码：
  public void f() &#123;    Object hellis = new Object();    synchronized(hellis) &#123;        System.out.println(hellis);    &#125;&#125;
  代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：
  public void f() &#123;    Object hellis = new Object();	System.out.println(hellis);&#125;
  0 new #2 &lt;java/lang/Object&gt;3 dup4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;7 astore_18 aload_19 dup10 astore_211 monitorenter12 getstatic #3 &lt;java/lang/System.out&gt;15 aload_116 invokevirtual #4 &lt;java/io/PrintStream.println&gt;19 aload_220 monitorexit21 goto 29 (+8)24 astore_325 aload_226 monitorexit27 aload_328 athrow29 return
  注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，同步省略操作是在解释运行时发生的


9.分离对象或标量替换
标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。
相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。


标量替换举例

代码

  public static void main(String args[]) &#123;    alloc();&#125;class Point &#123;    private int x;    private int y;&#125;private static void alloc() &#123;    Point point = new Point(1,2);    System.out.println(&quot;point.x&quot; + point.x + &quot;;point.y&quot; + point.y);&#125;

以上代码，经过标量替换后，就会变成

  private static void alloc() &#123;    int x = 1;    int y = 2;    System.out.println(&quot;point.x = &quot; + x + &quot;; point.y=&quot; + y);&#125;
  可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。
  

标量替换参数设置
  package com.peppa.heap;/** * 不开启标量替换： *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations * * [GC (Allocation Failure)  25600K-&gt;816K(98304K), 0.0007805 secs] * [GC (Allocation Failure)  26416K-&gt;832K(98304K), 0.0005552 secs] * [GC (Allocation Failure)  26432K-&gt;704K(98304K), 0.0010244 secs] * [GC (Allocation Failure)  26304K-&gt;752K(98304K), 0.0006991 secs] * [GC (Allocation Failure)  26352K-&gt;704K(98304K), 0.0006366 secs] * [GC (Allocation Failure)  26304K-&gt;720K(101376K), 0.0008407 secs] * [GC (Allocation Failure)  32464K-&gt;652K(101376K), 0.0010512 secs] * [GC (Allocation Failure)  32396K-&gt;652K(100352K), 0.0003788 secs] * 花费的时间为： 64 ms * * 开启标量替换： *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations *  花费的时间为： 4 ms */public class ScalarReplace &#123;    public static class User &#123;        public int id;        public String name;    &#125;    public static void alloc() &#123;        User u = new User();//未发生逃逸        u.id = 5;        u.name = &quot;peppa&quot;;    &#125;    public static void main(String[] args) &#123;        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10000000; i++) &#123;            alloc();        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;花费的时间为： &quot; + (end - start) + &quot; ms&quot;);    &#125;&#125;

逃逸分析的不足

关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。
其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。
一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。
虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。
注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上。
目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。


小结

年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。
老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。
当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；
如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；
如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。
当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。
当GC发生在老年代时则被称为Major GC或者Full GC。
一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(六)**本地方法栈Native Method Stacks</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%85%AD)%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88Native%20Method%20Stacks/</url>
    <content><![CDATA[JVM虚拟机详解(六)本地方法栈Native Method Stacks1. 概述Java 虚拟机的实现可以使用传统的栈(通常称为“ c 栈”)来支持本机方法(用 Java 编程语言以外的语言编写的方法)。本机方法堆栈也可以用于 Java 虚拟机指令集的解释器的实现，如 c 语言的 Java 虚拟机实现，不能加载本机方法，也不依赖于传统的堆栈，不需要提供本机方法堆栈。如果提供，通常在创建每个线程时为每个线程分配本机方法堆栈。
该规范允许本机方法堆栈具有固定的大小，或者根据计算的需要动态扩展和收缩。如果本机方法堆栈的大小固定，则在创建该堆栈时可以独立选择每个本机方法堆栈的大小。
Java 虚拟机实现可以为程序员或用户提供对本机方法堆栈初始大小的控制，以及对于不同大小的本机方法堆栈，对最大和最小方法堆栈大小的控制。

下面的异常情况与本机方法堆栈相关联:
如果线程中的计算需要比允许的更大的本机方法堆栈，那么 Java 虚拟机抛出一个 StackOverflowError。
如果本机方法堆栈可以动态扩展，本机方法堆栈扩展可以尝试，但是没有足够的内存可用，或者如果没有足够的内存可用来为新线程创建初始的本机方法堆栈，Java 虚拟机将抛出 OutOfMemoryError。



官网：Chapter 2. The Structure of the Java Virtual Machine (oracle.com)

简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。
“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）
在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。
本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。

代码举例说明Native方法是如何编写的
  需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外
  public class IHaveNatives &#123;    public native void Native1(int x);    public native static long Native2();    private native synchronized float Native3(Object o);    native void Native4(int[] ary) throws Exception;    &#125;

为什么使用Native Method？

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。


与Java环境的交互

有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。


与操作系统的交互

JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。


Sun’s Java

Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。
例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十)对象的实例化内存布局与访问定位</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81)%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[JVM虚拟机详解(十)对象的实例化内存布局与访问定位1. 创建对象

对象创建方式

new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法
Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器
Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器
使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口
使用序列化：序列化一般用于Socket的网络传输
第三方库 Objenesis


创建对象的步骤

判断对象对应的类是否加载、链接、初始化
 public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=2, args_size=1         0: new           #2                  // class java/lang/Object         3: dup         4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         7: astore_1         8: return      LineNumberTable:        line 5: 0        line 6: 8      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       9     0  args   [Ljava/lang/String;            8       1     1   obj   Ljava/lang/Object;    MethodParameters:      Name                           Flags      args
 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。

为对象分配内存

首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小
如果内存规整：采用指针碰撞分配内存
如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。
意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。
如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。
标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域


如果内存不规整
如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。
意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”
选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
标记清除算法清理过后的堆内存，就会存在很多内存碎片。




处理并发问题

采用CAS+失败重试保证更新的原子性
每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）
在Eden区给每个线程分配一块区域


初始化分配到的空间

所有属性设置默认值，保证对象实例字段在不赋值可以直接使用
给对象属性赋值的顺序：
属性的默认值初始化
显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）
构造器初始化




置对象的对象头
 将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。


  6.执行init方法进行初始化

在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。

  从字节码角度看 init 方法
  源代码
  package com.peppa.area;public class Customer &#123;    int id = 1001;    String name;    Account acct;    &#123;        name = &quot;匿名客户&quot;;    &#125;    public Customer()&#123;        acct = new Account();    &#125;&#125;class Account&#123;&#125;
  字节码
  0: aload_01: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V4: aload_05: sipush        10018: putfield      #2                  // Field id:I11: aload_012: ldc           #3                  // String 匿名客户14: putfield      #4                  // Field name:Ljava/lang/String;17: aload_018: new           #5                  // class com/peppa/area/Account21: dup22: invokespecial #6                  // Method com/peppa/area/Account.&quot;&lt;init&gt;&quot;:()V25: putfield      #7                  // Field acct:Lcom/peppa/area/Account;28: return

init() 方法的字节码指令：
属性的默认值初始化：id = 1001;
显示初始化&#x2F;代码块初始化：name = &quot;匿名客户&quot;;
构造器初始化：acct = new Account();



2. 对象的内存布局
对象的内存布局思维导图
  

对象头

对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针
如果是数组，还需要记录数组的长度


运行时元数据
哈希值（HashCode）
GC分代年龄
锁状态标志
线程持有的锁
偏向线程ID
翩向时间戳


类型指针
指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息




图解内存布局


  

对象的访问定位
JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？
  定位，通过栈上reference访问
  

对象的两种访问方式：句柄访问和直接指针

句柄访问

缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低
优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改

  



直接指针（HotSpot采用）

优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据

缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值
 








]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十)对象的实例化内存布局与访问定位</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%B8%80)%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8EExecution%20Engine/</url>
    <content><![CDATA[JVM虚拟机详解(十一)执行引擎Execution Engine1. 执行引擎概述
概述

执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器
执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

  
  JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。
  
  那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。
  

执行引擎的工作流程

执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。
每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。
当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。

  
  从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。


2.Java代码编译和执行过程
编译和执行过程

大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤

前面橙色部分是生成字节码文件的过程，和JVM无关

后面蓝色和绿色才是JVM需要考虑的过程
  



Java代码编译是由Java源码编译器来完成，流程图如下所示：


  

Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示

  

我们用一个总的图，来说说 解释器和编译器





什么是解释器（Interpreter）
  当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

什么是JIT编译器

JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。


为什么Java是半编译半解释型语言
  JDK1.e时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。
  翻译成本地代码后，就可以做一个缓存操作，存储在方法区中

机器码、指令、汇编语言

机器码
  各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。
  机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。
  用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。
  机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。

指令
  由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。
  指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好
  由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。

指令集
  不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的

x86指令集，对应的是x86架构的平台
ARM指令集，对应的是ARM架构的平台


汇编语言
  由于指令的可读性还是太差，于是人们又发明了汇编语言。
  在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。

由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。





3.高级语言
高级计算机语言
  为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。
  高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。



高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++

C、C++源程序执行过程
  编译过程又可以分成两个阶段：编译和汇编。
  编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码
  汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。
  

字节码
  字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码
  字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。
  字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。

字节码典型的应用为：Java bytecode


解释器
  JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。
  
  为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的
  解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
  当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。

解释器分类
  在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。
  字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。
  而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。
  在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。

Interpreter模块：实现了解释器的核心功能
Code模块：用于管理HotSpot VM在运行时生成的本地机器指令


现状
  由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。
  为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。
  不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。


4.JIT编译器
Java代码的执行分类

第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行
第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行
HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。
在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。


为啥我们还需要解释器呢？

有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。
JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能


首先明确两点：

当程序启动后，解释器可以马上发挥作用，响应速度快，省去编译的时间，立即执行。
编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间，但编译为本地代码后，执行效率高。

  所以：

尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。
在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。

  案例
  注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。
  在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队
  
  

JIT编译器相关概念

Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。
也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。
还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）

  典型的编译器：

前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。
JIT编译器：HotSpot VM的C1、C2编译器。
AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。


热点代码及探测方式

当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。
关于那些需要被编译为本地代码的字节码，也被称之为**“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化**，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。
一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。
一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。
目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。
采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。
方法调用计数器用于统计方法的调用次数
回边计数器则用于统计循环体执行的循环次数




方法调用计数器

这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。

这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。

当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本

如果存在，则优先使用编译后的本地代码来执行
如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。
如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。
如果未超过阈值，则使用解释器对字节码文件解释执行



 



热度衰减

如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）
进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。
另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。


回边计数器
  它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。
  

HotSpotVM 可以设置程序执行方法
  缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：

Xint：完全采用解释器模式执行程序；
Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
Xmixed：采用解释器+即时编译器的混合模式共同执行程序。

  
  

HotSpotVM JIT 分类
  在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：

client：指定Java虚拟机运行在Client模式下，并使用C1编译器；
C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。


server：指定Java虚拟机运行在server模式下，并使用C2编译器。
C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）




C1和C2编译器不同的优化策略

在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。
方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
去虚拟化：对唯一的实现樊进行内联
冗余消除：在运行期间把一些不会执行的代码折叠掉


C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：
标量替换：用标量值代替聚合对象的属性值
栈上分配：对于未逃逸的对象分配对象在栈而不是堆
同步消除：清除同步操作，通常指synchronized




分层编译策略

分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。
不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。
一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高
C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器


Graal 编译器

自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器
编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）
目前，带着实验状态标签，需要使用开关参数去激活才能使用
XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler




AOT编译器

jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）

Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。

所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。
 .java -&gt; .class -&gt; (使用jaotc) -&gt; .so



AOT编译器编译器的优缺点
  最大的好处：

Java虚拟机加载已经预编译成二进制库，可以直接执行。
不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验

  缺点：

破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包
降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。
还需要继续优化中，最初只支持Linux X64 java base


最后

自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器
编译效果短短几年时间就追评了G2编译器，未来可期
目前，带着实验状态标签，需要使用开关参数去激活才能使用



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十三)垃圾回收算法</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%B8%89)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[JVM虚拟机详解(十三)垃圾回收算法1. 什么是垃圾
从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。
垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 关于垃圾收集有三个经典问题：

哪些内存需要回收？
什么时候回收？
如何回收？

垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。

什么是垃圾？

垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。
外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.
如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。


为什么需要GC？

想要学习GC，首先需要理解为什么需要GC？
对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。
随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。




早期垃圾回收

在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：
 MibBridge *pBridge= new cmBaseGroupBridge（）；  //如果注册失败，使用Delete释放该对象所占内存区域  if（pBridge-&gt;Register（kDestroy）！=NO ERROR）  	delete pBridge；

这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。

有了垃圾回收机制后，上述代码极有可能变成这样
 MibBridge *pBridge=new cmBaseGroupBridge();   pBridge-&gt;Register(kDestroy);




现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。

2.Java 垃圾回收机制
自动内存管理

官网介绍：Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide, Release 8 (oracle.com)


自动内存管理的优点

自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险
没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。
自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发


关于自动内存管理的担忧

对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。
此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。
当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。


GC主要关注的区域
  GC主要关注于 方法区 和堆中的垃圾收集
  
  垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收

其中，Java堆是垃圾收集器的工作重点

  从次数上讲：

频繁收集Young区
较少收集Old区
基本不收集Perm区（元空间）



3.垃圾回收相关算法
引用计数算法

在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。
那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。
判断对象存活一般有两种方式：引用计数算法和可达性分析算法。


引用计数算法-原理
引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
缺点：
它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。




循环引用
当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏****



  

验证Java是否采用的是引用计数算法

  package com.peppa.gc;/** * -XX:+PrintGCDetails * 引用计数算法测试 * * @author: peppa * @create: 2022-03-05 16:44:15 */public class RefCountGC &#123;    // 这个成员属性的唯一作用就是占用一点内存    private byte[] bigSize = new byte[5*1024*1024];    // 引用    Object reference = null;    public static void main(String[] args) &#123;        RefCountGC obj1 = new RefCountGC();        RefCountGC obj2 = new RefCountGC();        obj1.reference = obj2;        obj2.reference = obj1;        obj1 = null;        obj2 = null;        // 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？        System.gc();    &#125;&#125;
  [GC (System.gc()) [PSYoungGen: 15093K-&gt;808K(94208K)] 15093K-&gt;816K(310272K), 0.0010090 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(94208K)] [ParOldGen: 8K-&gt;627K(216064K)] 816K-&gt;627K(310272K), [Metaspace: 3226K-&gt;3226K(1056768K)], 0.0038155 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 94208K, used 809K [0x0000000756f80000, 0x000000075d880000, 0x00000007c0000000)  eden space 80896K, 1% used [0x0000000756f80000,0x000000075704a548,0x000000075be80000)  from space 13312K, 0% used [0x000000075be80000,0x000000075be80000,0x000000075cb80000)  to   space 13312K, 0% used [0x000000075cb80000,0x000000075cb80000,0x000000075d880000) ParOldGen       total 216064K, used 627K [0x0000000684e00000, 0x0000000692100000, 0x0000000756f80000)  object space 216064K, 0% used [0x0000000684e00000,0x0000000684e9cc80,0x0000000692100000) Metaspace       used 3233K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K
  我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了
  [GC (System.gc()) [PSYoungGen: 15093K-&gt;808K(94208K)] 15093K-&gt;816K(310272K), 0.0010090 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
   如果使用引用计数算法，那么这两个对象会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。
  

可达性分析算法

概念：
可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集
相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）




可达性分析实现思路
所谓”GCRoots”根集合就是一组必须活跃的引用

其基本思路如下：

可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）
如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记垃圾对象。
在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

  





标记-清除算法

垃圾清除阶段

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是
标记-清除算法（Mark-Sweep）
复制算法（Copying）
标记-压缩算法（Mark-Compact）


标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。


执行过程

当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除
标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
标记的是引用的对象，不是垃圾！！


清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收

  
  

标记-清除算法的缺点

标记清除算法的效率不算高
在进行GC的时候，需要停止整个应用程序，用户体验较差
这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表


注意：何为清除？

这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。
关于空闲列表是在为对象分配内存的时候提过：
如果内存规整
采用指针碰撞的方式进行内存分配


如果内存不规整
虚拟机需要维护一个空闲列表
采用空闲列表分配内存






GC Roots可以是哪些？

虚拟机栈中引用的对象
比如：各个线程被调用的方法中使用到的参数、局部变量等。


本地方法栈内JNI（通常说的本地方法）引用的对象
方法区中类静态属性引用的对象
比如：Java类的引用类型静态变量


方法区中常量引用的对象
比如：字符串常量池（StringTable）里的引用


所有被同步锁synchronized持有的对象
Java虚拟机内部的引用。
基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。


反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

  

注意
如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。
这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。






清除阶段：复制算法

背景

为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。


核心思想

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

  

把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法

  
  

优点

没有标记和清除过程，实现简单，运行高效
复制过去以后保证空间的连续性，不会出现“碎片”问题。


缺点

此算法的缺点也是很明显的，就是需要两倍的内存空间。
对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小


注意

如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）
在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。

  




4.对象的 finalization 机制
概述

Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。


对象销毁前的回调函数：finalize()

Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。


注意事项：
  永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：

在finalize（）时可能会导致对象复活。
finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。
因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收


一个糟糕的finalize（）会严重影响Gc的性能。


生存还是死亡？

由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。

如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：
可触及的：从根节点开始，可以到达这个对象。
可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。
不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。


以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。


具体过程
  判定一个对象objA是否可回收，至少要经历两次标记过程：

如果对象objA到GC Roots没有引用链，则进行第一次标记。

进行筛选，判断此对象是否有必要执行finalize（）方法

如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。
finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。

  



代码演示 finalize() 方法可复活对象

我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this
在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。

  package com.peppa.gc;/** * 测试Object类中finalize()方法，即对象的finalization机制。 * @author: peppa * @create: 2022-03-05 17:54:15 */public class CanReliveObj &#123;    //类变量，属于 GC Root    public static CanReliveObj obj;    /**     * 此方法只能被调用一次     * @throws Throwable     */    @Override    protected void finalize() throws Throwable &#123;        super.finalize();        System.out.println(&quot;调用当前类重写的finalize()方法&quot;);        //当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系        obj = this;    &#125;    public static void main(String[] args) &#123;        try &#123;            obj = new CanReliveObj();            obj = null;            System.gc();//调用垃圾回收器            System.out.println(&quot;-----------------第一次gc操作------------&quot;);            // 因为Finalizer线程优先级很低，暂停2秒，以等待它            Thread.sleep(2000);            if (obj == null) &#123;                System.out.println(&quot;obj is dead&quot;);            &#125; else &#123;                System.out.println(&quot;obj is still alive&quot;);            &#125;            System.out.println(&quot;-----------------第二次gc操作------------&quot;);            obj = null;            System.gc();            // 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了            // 因为Finalizer线程优先级很低，暂停2秒，以等待它            Thread.sleep(2000);            if (obj == null) &#123;                System.out.println(&quot;obj is dead&quot;);            &#125; else &#123;                System.out.println(&quot;obj is still alive&quot;);            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

最后运行结果

  调用当前类重写的finalize()方法-----------------第一次gc操作------------obj is still alive-----------------第二次gc操作------------obj is dead



5.MAT与JProfiler的GC Roots溯源
MAT

介绍

MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。
MAT是基于Eclipse开发的，是一款免费的性能分析工具。
下载地址：Eclipse Memory Analyzer Open Source Project | The Eclipse Foundation


获取dump文件

命令行使用 jmap

  C:\Users\yuanxw&gt;jps13376 Jps16176 RefCountGC585616824 Launcher16700 MainC:\Users\yuanxw&gt;jmap -dump:format=b,live,file=refcountgc.bin 16176Dumping heap to C:\Users\yuanxw\refcountgc.bin ...Heap dump file created

打开后，我们就可以看到有哪些可以作为GC Roots的对象

  



JProfiler

JProfiler的GC Roots溯源

在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫GC Roots 溯源
下面我们使用使用 JProfiler 进行 GC Roots 溯源演示

  
  - 

如何判断什么原因造成OOM

当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明

  package com.peppa.gc;import java.util.ArrayList;/** * 内存溢出排查 * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError * 这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件 */public class HeapOOM &#123;    byte[] buffer = new byte[1 * 1024 * 1024];//1MB    public static void main(String[] args) &#123;        ArrayList&lt;HeapOOM&gt; list = new ArrayList&lt;&gt;();        int count = 0;        try&#123;            while(true)&#123;                list.add(new HeapOOM());                count++;            &#125;        &#125;catch (Throwable e)&#123;            System.out.println(&quot;count = &quot; + count);            e.printStackTrace();        &#125;    &#125;&#125;
  上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出
  java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid7196.hprof ...Heap dump file created [7705267 bytes in 0.009 secs]count = 6java.lang.OutOfMemoryError: Java heap space	at com.peppa.gc.HeapOOM.&lt;init&gt;(HeapOOM.java:10)	at com.peppa.gc.HeapOOM.main(HeapOOM.java:18)
  我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象
  
  然后我们通过线程，还能够定位到哪里出现OOM
  



清除阶段：标记-整理算法

背景

复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。
标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。


执行过程

第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象

第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。
  



标清和标整的区别

标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。
二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。
标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。


标整的优缺点

优点
消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
消除了复制算法当中，内存减半的高额代价。


缺点
从效率上来说，标记-整理算法要低于复制算法。
移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）
移动过程中，需要全程暂停用户应用程序。即：STW






垃圾回收算法小结

对比三种清除阶段的算法

效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。
而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。





标记清除
标记整理
复制



速率
中等
最慢
最快


空间开销
少（但会堆积碎片）
少（不堆积碎片）
通常需要活对象的2倍空间（不堆积碎片）


移动对象
否
是
是



分代收集算法

前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。
分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。
在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。


目前几乎所有的GC都采用分代手机算法执行垃圾回收的
  在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。

年轻代（Young Gen）
  年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。
  这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。

老年代（Tenured Gen）
  老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
  这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。

Mark阶段的开销与存活对象的数量成正比。
Sweep阶段的开销与所管理区域的大小成正相关。
compact阶段的开销与存活对象的数据成正比。



  以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。
  分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代



增量收集算法

概述

上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。


增量收集算法基本思想

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作


增量收集算法的缺点

使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。


分区算法

概述

一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。
分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

  






]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十四)**垃圾回收相关概念</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E5%9B%9B)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[JVM虚拟机详解(十四)垃圾回收相关概念1. System.gc()
理解

在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)

JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()代码演示是否出发GC操作

代码演示是否出发GC操作
  package com.peppa.gc;/** * System.gc() * * @author: peppa * @create: 2022-03-07 10:41:57 */public class SystemGC &#123;    public static void main(String[] args) &#123;        new SystemGC();        // 提醒JVM进行垃圾回收        System.gc();        // 强制调用 失去引用对象的finalize()        //System.runFinalization();    &#125;    @Override    protected void finalize() throws Throwable &#123;        super.finalize();        System.out.println(&quot;...SystemGC.finalize()方法被执行!!!&quot;);    &#125;&#125;

  输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用
  ...SystemGC.finalize()方法被执行!!!

手动GC来理解不可达对象的回收
  package com.peppa.gc;/** * 加上参数：  -XX:+PrintGCDetails -Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m * @author peppa * @create 2022-03-07 10:53:44 */public class LocalVariablesGC &#123;    /**     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区     */    public void localvarGC1() &#123;        //10MB        byte[] buffer = new byte[10 * 1024 * 1024];        System.gc();    &#125;    /**     *  触发YoungGC的时候，已经被回收了     */    public void localvarGC2() &#123;        byte[] buffer = new byte[10 * 1024 * 1024];        buffer = null;        System.gc();    &#125;    /**     * 不会被回收，因为它还存放在局部变量表索引为1的槽中     */    public void localvarGC3() &#123;        &#123;            byte[] buffer = new byte[10 * 1024 * 1024];        &#125;        System.gc();    &#125;    /**     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了     */    public void localvarGC4() &#123;        &#123;            byte[] buffer = new byte[10 * 1024 * 1024];        &#125;        int value = 10;        System.gc();    &#125;    /**     * localvarGC5中的数组已经被回收     */    public void localvarGC5() &#123;        localvarGC1();        System.gc();    &#125;    public static void main(String[] args) &#123;        LocalVariablesGC local = new LocalVariablesGC();        // 通过在main方法调用这几个方法进行测试        System.out.println(&quot;...LocalVariablesGC.localvarGC-1()&quot;);        local.localvarGC1();//        System.out.println(&quot;...LocalVariablesGC.localvarGC-2()&quot;);//        local.localvarGC2();////        System.out.println(&quot;...LocalVariablesGC.localvarGC-3()&quot;);//        local.localvarGC3();////        System.out.println(&quot;...LocalVariablesGC.localvarGC-4()&quot;);//        local.localvarGC4();////        System.out.println(&quot;...LocalVariablesGC.localvarGC-5()&quot;);//        local.localvarGC5();    &#125;&#125;

执行结果：

执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收

  ...LocalVariablesGC.localvarGC-1()**[GC (System.gc()) [PSYoungGen: 15483K-&gt;10728K(76288K)] 15483K-&gt;10976K(251392K), 0.0052388 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 248K-&gt;10868K(175104K)] 10976K-&gt;10868K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0040694 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]** Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 10868K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 6% used [0x00000000f0000000,0x00000000f0a9d270,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K

由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收

  ...LocalVariablesGC.localvarGC-2()**[GC (System.gc()) [PSYoungGen: 15483K-&gt;840K(76288K)] 15483K-&gt;848K(251392K), 0.0007219 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;628K(175104K)] 848K-&gt;628K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0034734 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]** Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 628K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009d260,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K

虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收

  ...LocalVariablesGC.localvarGC-3()**[GC (System.gc()) [PSYoungGen: 15483K-&gt;10736K(76288K)] 15483K-&gt;10976K(251392K), 0.0051980 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 240K-&gt;10868K(175104K)] 10976K-&gt;10868K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0039932 secs] [Times: user=0.05 sys=0.06, real=0.00 secs]** Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 10868K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 6% used [0x00000000f0000000,0x00000000f0a9d270,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K

1、来看看字节码：实例方法局部变量表第一个变量肯定是 this
  Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？
  A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看，value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向new byte[10 * 1024 * 1024]实例了。

局部变量除了方法范围就是失效了，堆中的字节数组铁定被回收


  ...LocalVariablesGC.localvarGC-5()[GC (System.gc()) [PSYoungGen: 15483K-&gt;10728K(76288K)] 15483K-&gt;10944K(251392K), 0.0050946 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (System.gc()) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 216K-&gt;10868K(175104K)] 10944K-&gt;10868K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0043706 secs] [Times: user=0.13 sys=0.00, real=0.00 secs] [GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10868K-&gt;10868K(251392K), 0.0002125 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10868K-&gt;628K(175104K)] 10868K-&gt;628K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0042302 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000)  to   space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000) ParOldGen       total 175104K, used 628K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009d260,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K
  ...LocalVariablesGC.localvarGC-4()[GC (System.gc()) [PSYoungGen: 15483K-&gt;840K(76288K)] 15483K-&gt;848K(251392K), 0.0007100 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;628K(175104K)] 848K-&gt;628K(251392K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0041518 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 628K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009d260,0x00000000fab00000) Metaspace       used 3235K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K



2.内存溢出和内存泄漏
什么是内存溢出？

内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。
由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。
大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。
Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。


内存溢出（OOM）原因分析

首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：

Java虚拟机的堆内存设置不够。
比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。


代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）
对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space“。
随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace“。直接内存不足，也会导致OOM。




抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。

例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。
在**java.nio.Bits.reserveMemory()**方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。


当然，也不是在任何情况下垃圾收集器都会被触发的

比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。




什么是内存泄漏？

也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。
但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。
尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。
注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。

  
  Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。

举例

单例模式

  单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。

一些提供close的资源未关闭导致内存泄漏

  数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。




3.Stop The World]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(十二)StringTable(字符串常量池)</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%8D%81%E4%BA%8C)StringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/</url>
    <content><![CDATA[JVM虚拟机详解(十二)StringTable(字符串常量池)1. StringTable(字符串常量池)
String的基本特性

String：字符串，使用一对 ”” 引起来表示

  String s1 = &quot;peppa&quot; ;   			// 字面量的定义方式String s2 =  new String(&quot;hello world&quot;);     // new 对象的方式

string声明为final的，不可被继承
String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小
String在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]


为什么JDK9改变了结构
  String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。
  我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1&#x2F;Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。
  结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间
  // 之前private final char value[];// 之后private final byte[] value
  同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改

String的不可变性

String：代表不可变的字符序列。简称：不可变性。
当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。


通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。


当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
  @Testpublic void test1() &#123;    String s1 = &quot;abc&quot;;//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中    String s2 = &quot;abc&quot;;    s1 = &quot;hello&quot;;    System.out.println(s1 == s2);//判断地址：true  --&gt; false    System.out.println(s1);//    System.out.println(s2);//abc&#125;
  字节码指令

取字符串 “abc” 时，使用的是同一个符号引用：#2
取字符串 “hello” 时，使用的是另一个符号引用：#3


当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值
  @Testpublic void test2() &#123;    String s1 = &quot;abc&quot;;    String s2 = &quot;abc&quot;;    s2 += &quot;def&quot;;    System.out.println(s2);//abcdef    System.out.println(s1);//abc&#125;

当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值
  @Testpublic void test3() &#123;    String s1 = &quot;abc&quot;;    String s2 = s1.replace(&#x27;a&#x27;, &#x27;m&#x27;);    System.out.println(s1);//abc    System.out.println(s2);//mbc&#125;

一道笔试题
  public class StringExer &#123;    String str = new String(&quot;good&quot;);    char[] ch = &#123;&#x27;t&#x27;, &#x27;e&#x27;, &#x27;s&#x27;, &#x27;t&#x27;&#125;;    public void change(String str, char ch[]) &#123;        str = &quot;test ok&quot;;        ch[0] = &#x27;b&#x27;;    &#125;    public static void main(String[] args) &#123;        StringExer ex = new StringExer();        ex.change(ex.str, ex.ch);        System.out.println(ex.str);//good        System.out.println(ex.ch);//best    &#125;&#125;
  str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容****


2.String 的底层结构
字符串常量池是不会存储相同内容的字符串的

String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。
使用-XX:StringTablesize可设置StringTable的长度
在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求
在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求
在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009


String 的内存分配

在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。
常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。
直接使用双引号声明出来的String对象会直接存储在常量池中。比如：String info=&quot;atguigu.com&quot;;
如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈


Java 6及以前，字符串常量池存放在永久代
Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内
所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。
字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。


Java8元空间，字符串常量在堆

  
  
  

StringTable 为什么要调整？

为什么要调整位置？
永久代的默认空间大小比较小
永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space
堆中空间足够大，字符串可被及时回收


在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。
此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。

  官方文档:https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes
  代码示例：
  package com.peppa.strings;import java.util.HashSet;import java.util.Set;/** * jdk6中： * -XX:PermSize=10m -XX:MaxPermSize=10m -Xms10m -Xmx10m * * jdk8中： * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=10m -Xms10m -Xmx10m */public class StringTest3 &#123;    public static void main(String[] args) &#123;        //使用Set保持着常量池引用，避免full gc回收常量池行为        Set&lt;String&gt; set = new HashSet&lt;String&gt;();        //在short可以取值的范围内足以让10MB的PermSize或heap产生OOM了。        short i = 0;        while(true)&#123;            set.add(String.valueOf(i++).intern());        &#125;    &#125;&#125;
  输出结果：字符串真的在堆中（JDK8）
  Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space	at java.util.HashMap.resize(HashMap.java:704)	at java.util.HashMap.putVal(HashMap.java:663)	at java.util.HashMap.put(HashMap.java:612)	at java.util.HashSet.add(HashSet.java:220)	at com.peppa.strings.StringTest3.main(StringTest3.java:20)Process finished with exit code 1

String 的基本操作
  Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。
  package com.peppa.strings;public class StringTest4 &#123;    public static void main(String[] args) &#123;        System.out.println();//2051        System.out.println(&quot;1&quot;);//2052        System.out.println(&quot;2&quot;);        System.out.println(&quot;3&quot;);        System.out.println(&quot;4&quot;);        System.out.println(&quot;5&quot;);        System.out.println(&quot;6&quot;);        System.out.println(&quot;7&quot;);        System.out.println(&quot;8&quot;);        System.out.println(&quot;9&quot;);        System.out.println(&quot;10&quot;);//2303        //如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载        System.out.println(&quot;1&quot;);//2304        System.out.println(&quot;2&quot;);//2304        System.out.println(&quot;3&quot;);        System.out.println(&quot;4&quot;);        System.out.println(&quot;5&quot;);        System.out.println(&quot;6&quot;);        System.out.println(&quot;7&quot;);        System.out.println(&quot;8&quot;);        System.out.println(&quot;9&quot;);        System.out.println(&quot;10&quot;);//2304    &#125;&#125;

分析字符串常量池的变化-案例1：
  1、程序启动时已经加载了 *2051*个字符串常量
  
  2、加载了一个换行符（println），所以多了一个
  
  3、之后的字符串”1” 到 “10”不会再次加载
  

分析字符串常量池的变化-案例2：

官方示例代码

  //官方示例代码class Memory &#123;    public static void main(String[] args) &#123;//line 1        int i = 1;//line 2        Object obj = new Object();//line 3        Memory mem = new Memory();//line 4        mem.foo(obj);//line 5    &#125;//line 9    private void foo(Object param) &#123;//line 6        String str = param.toString();//line 7        System.out.println(str);    &#125;//line 8&#125;

分析运行时内存（foo() 方法是实例方法，其实图中少了一个 this 局部变量）

  




3.字符串拼接操作
字符串拼接操作

常量与常量的拼接结果在常量池，原理是编译期优化
常量池中不会存在相同内容的变量
只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder
如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址


常量与常量的拼接结果在常量池，原理是编译期优化
  @Testpublic void test1()&#123;    String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;//编译期优化：等同于&quot;abc&quot;    String s2 = &quot;abc&quot;; //&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2    /*     * 最终.java编译成.class,再执行.class     * String s1 = &quot;abc&quot;;     * String s2 = &quot;abc&quot;     */    System.out.println(s1 == s2); //true    System.out.println(s1.equals(s2)); //true&#125;
  从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”
  0: ldc           #2                  // String abc2: astore_13: ldc           #2                  // String abc5: astore_26: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;9: aload_110: aload_211: if_acmpne     1814: iconst_115: goto          1918: iconst_019: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V22: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;25: aload_126: aload_227: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z30: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V33: return
  IDEA 反编译 class 文件后，来看这个问题
  

拼接前后，只要其中有一个是变量，结果就在堆中
  public void test2()&#123;    String s1 = &quot;javaEE&quot;;    String s2 = &quot;hadoop&quot;;    String s3 = &quot;javaEEhadoop&quot;;    String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;//编译期优化    //如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop    String s5 = s1 + &quot;hadoop&quot;;    String s6 = &quot;javaEE&quot; + s2;    String s7 = s1 + s2;    System.out.println(s3 == s4);//true    System.out.println(s3 == s5);//false    System.out.println(s3 == s6);//false    System.out.println(s3 == s7);//false    System.out.println(s5 == s6);//false    System.out.println(s5 == s7);//false    System.out.println(s6 == s7);//false    //intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；    //如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。    String s8 = s6.intern();    System.out.println(s3 == s8);//true&#125;
  从上述的结果我们可以知道：
  从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类
  如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果
  而调用intern方法，则会判断字符串常量池中是否存在JavaEEhadoop值，如果存在则返回常量池中的值，否者就在常量池中创建

底层原理

拼接操作的底层其实使用了StringBuilder
  public void test3()&#123;    String s1 = &quot;a&quot;;    String s2 = &quot;b&quot;;    String s3 = &quot;ab&quot;;    /*    如下的s1 + s2 的执行细节：(变量s是我临时定义的）    ① StringBuilder s = new StringBuilder();    ② s.append(&quot;a&quot;)    ③ s.append(&quot;b&quot;)    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer     */    String s4 = s1 + s2;//    System.out.println(s3 == s4);//false&#125;
  

字符串拼接操作不一定使用的是StringBuilder


  /*    1. 字符串拼接操作不一定使用的是StringBuilder!       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。     */    @Test    public void test4()&#123;        final String s1 = &quot;a&quot;;        final String s2 = &quot;b&quot;;        String s3 = &quot;ab&quot;;        String s4 = s1 + s2;        System.out.println(s3 == s4);//true    &#125;

从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”
  0 ldc #14 &lt;a&gt;2 astore_13 ldc #15 &lt;b&gt;5 astore_26 ldc #16 &lt;ab&gt;8 astore_39 ldc #16 &lt;ab&gt;11 astore 413 getstatic #3 &lt;java/lang/System.out&gt;16 aload_317 aload 419 if_acmpne 26 (+7)22 iconst_123 goto 27 (+4)26 iconst_027 invokevirtual #4 &lt;java/io/PrintStream.println&gt;30 return


拼接操作和append性能对比
  public static void method1(int highLevel) &#123;    String src = &quot;&quot;;    for (int i = 0; i &lt; highLevel; i++) &#123;        src += &quot;a&quot;; // 每次循环都会创建一个StringBuilder对象    &#125;&#125;public static void method2(int highLevel) &#123;    StringBuilder sb = new StringBuilder();    for (int i = 0; i &lt; highLevel; i++) &#123;        sb.append(&quot;a&quot;);    &#125;&#125;

方法1耗费的时间：4005ms，方法2消耗时间：7ms
  结论：

通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法

  好处

StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象
对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象
内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间

  改进的空间

我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数
因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度




intern()的使用


intern() 方法的说明



  public native String intern();

intern是一个native方法，调用的是底层C的方法

字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）

如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：
 String myInfo = new string(&quot;I love atguigu&quot;).intern();

也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true
 (&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;

通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）



new String() 的说明

new String(“ab”)会创建几个对象？
  /** * 题目： * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。 *     一个对象是：new关键字在堆空间创建的 *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc * */public class StringNewTest &#123;    public static void main(String[] args) &#123;        String str = new String(&quot;ab&quot;);    &#125;&#125;

字节码指令

  0 new #2 &lt;java/lang/String&gt;3 dup4 ldc #3 &lt;ab&gt;6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;9 astore_110 return
  0 new #2 &lt;java/lang/String&gt;：在堆中创建了一个 String 对象
  4 ldc #3 &lt;ab&gt; ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）
  

new String(“a”) + new String(“b”) 会创建几个对象？

代码

  /** * 思考： * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？ *  对象1：new StringBuilder() *  对象2： new String(&quot;a&quot;) *  对象3： 常量池中的&quot;a&quot; *  对象4： new String(&quot;b&quot;) *  对象5： 常量池中的&quot;b&quot; * *  深入剖析： StringBuilder的toString(): *      对象6 ：new String(&quot;ab&quot;) *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot; * */public class StringNewTest &#123;    public static void main(String[] args) &#123;        String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);    &#125;&#125;
  字节码指令
  0: new           #2                  // class java/lang/StringBuilder3: dup4: invokespecial #3                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V7: new           #4                  // class java/lang/String10: dup11: ldc           #5                  // String a13: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V16: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;19: new           #4                  // class java/lang/String22: dup23: ldc           #8                  // String b25: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;31: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;34: astore_135: return
  我们创建了6个对象

对象1：new StringBuilder()
对象2：new String(“a”)
对象3：常量池的 a
对象4：new String(“b”)
对象5：常量池的 b
对象6：toString中会创建一个 new String(“ab”)
调用toString方法，不会在常量池中生成ab






intern的使用：JDK6和JDK7

JDK6中
  String s = new String(&quot;1&quot;);  // 在常量池中已经有了s.intern(); // 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1String s2 = &quot;1&quot;;System.out.println(s == s2); // falseString s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);s3.intern();String s4 = &quot;11&quot;;System.out.println(s3 == s4); // false
  输出结果
  falsefalse

为什么对象会不一样呢？

一个是new创建的对象，一个是常量池中的对象，显然不是同一个




如果是下面这样的，那么就是true
  String s = new String(&quot;1&quot;);s = s.intern();String s2 = &quot;1&quot;;System.out.println(s == s2); // true
  而对于下面的来说，因为 s3变量记录的地址是 new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是JDK6的关系，然后执行 s3.intern()后，就会在常量池中生成 “11”，最后 s4用的就是s3的地址

为什么最后输出的 s3 &#x3D;&#x3D; s4 会为false呢？这是因为在JDK6中创建了一个新的对象 “11”，也就是有了新的地址， s2 &#x3D; 新地址而在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象


JDK7中
  String s = new String(&quot;1&quot;);s.intern();String s2 = &quot;1&quot;;System.out.println(s == s2); // falseString s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);s3.intern();String s4 = &quot;11&quot;;System.out.println(s3 == s4); // true
  



扩展
  /** * StringIntern.java中练习的拓展： * */public class StringIntern1 &#123;    public static void main(String[] args) &#123;        //执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！        String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);//new String(&quot;11&quot;)        //在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象        String s4 = &quot;11&quot;;        String s5 = s3.intern();        // s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;        System.out.println(s3 == s4);//false        // s5 是从字符串常量池中取回来的引用，当然和 s4 相等        System.out.println(s5 == s4);//true    &#125;&#125;

总结string的intern（）的使用：
  JDK1.6中，将这个字符串对象尝试放入串池。

如果串池中有，则并不会放入。返回已有的串池中的对象的地址
如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址

  JDK1.7起，将这个字符串对象尝试放入串池。

如果串池中有，则并不会放入。返回已有的串池中的对象的地址
如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址


练习：
  

在JDK6中，在字符串常量池中创建一个字符串 “ab”
在JDK8中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到 串池中。
所以上述结果，在JDK6中是：

  truefalse

在JDK8中是

  falsetrue
  
  针对下面这题，在JDK6和8中表现的是一样的
  


4.StringTable的垃圾回收package com.peppa.strings;/** * String的垃圾回收: * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails */public class StringGCTest &#123;    public static void main(String[] args) &#123;        for (int j = 0; j &lt; 100000; j++) &#123;            String.valueOf(j).intern();        &#125;    &#125;&#125;

[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;488K(4608K)] 4096K-&gt;664K(15872K), 0.0011215 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 4608K, used 3577K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)  eden space 4096K, 75% used [0x00000000ffb00000,0x00000000ffe04688,0x00000000fff00000)  from space 512K, 95% used [0x00000000fff00000,0x00000000fff7a020,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 11264K, used 176K [0x00000000ff000000, 0x00000000ffb00000, 0x00000000ffb00000)  object space 11264K, 1% used [0x00000000ff000000,0x00000000ff02c000,0x00000000ffb00000) Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576KSymbolTable statistics:Number of buckets       :     20011 =    160088 bytes, avg   8.000Number of entries       :     13304 =    319296 bytes, avg  24.000Number of literals      :     13304 =    568608 bytes, avg  42.740Total footprint         :           =   1047992 bytesAverage bucket size     :     0.665Variance of bucket size :     0.666Std. dev. of bucket size:     0.816Maximum bucket size     :         6StringTable statistics:Number of buckets       :     60013 =    480104 bytes, avg   8.000Number of entries       :     57042 =   1369008 bytes, avg  24.000Number of literals      :     57042 =   3253608 bytes, avg  57.039Total footprint         :           =   5102720 bytesAverage bucket size     :     0.950Variance of bucket size :     0.750Std. dev. of bucket size:     0.866Maximum bucket size     :         5

5.G1 中的 String 去重操作官方：JEP 192: String Deduplication in G1 (java.net)
注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复

描述

背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：
堆存活数据集合里面string对象占了25%
堆存活数据集合里面重复的string对象有13.5%
string对象的平均长度是45


许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）&#x3D; true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。


String 去重的的实现

当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。
如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。
使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。
如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。
如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。


命令行选项

UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。
PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息
stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象



]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机详解(四)**运行时数据区概述及线程</title>
    <url>/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3(%E5%9B%9B)%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[JVM虚拟机详解(四)运行时数据区概述及线程1. 前言本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段

当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区

也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品

内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。

我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁


运行时数据区的完整图
  
  Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。
  灰色的为单独线程私有的，红色的为多个线程共享的。即：

每个线程：独立包括程序计数器、栈、本地栈。
线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

  


2. 线程
JVM 线程
线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行
在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射
当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收


操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法


JVM 系统线程
如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[])的main线程以及所有这个main线程自己创建的线程。
这些主要的后台系统线程在Hotspot JVM里主要是以下几个：
虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销
周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行
GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持
编译线程：这种线程在运行时会将字节码编译成到本地代码
信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理





]]></content>
      <categories>
        <category>JVM虚拟机详解</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM虚拟机详解</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(一)认识JAVA多线程</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)%E8%AE%A4%E8%AF%86JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[1. 什么是线程和进程?&emsp;&emsp;在早期的计算机中不包含操作系统，它们从头到尾只执行一个程序，并肯这个程序能访问计算机中的所有的所有资源。在这种裸机环境中，不仅很难编写和运行程序，而且每次只能运行一个程序，这对于昂贵并且稀有的计算机资源来说也是一种浪费。
&emsp;&emsp;操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为各个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程之间可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。
1.1 什么是进程进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。
如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。
1.2 什么是线程线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
2. Java中创建线程&emsp;&emsp;在Java中创建线程的方式有三种：继承Thread类重写run方法、实现runnable接口重写run方法和实现callable接口重写call方法配合futureTask使用
2.1 继承Thread类继承Thread类的方式创建线程算是最简单的了，但是你的线程类往往要继承项目中的其他类，而Java是单继承机制的，所以使用此方法会有很大的局限性。
package com.yuanxw.chapter1;/** * Java中创建线程一：继承Thread类重写run方法 */public class MyThread extends Thread &#123;    public static void main(String[] args) &#123;        MyThread myThread = new MyThread();        myThread.start();        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, currentThread().getName()));    &#125;    @Override    public void run() &#123;        for (int i = 0; i &lt; 20; i++) &#123;            try &#123;                System.out.println(String.format(&quot;线程：【%s】,打印：%s&quot;, currentThread().getName(),i));                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, currentThread().getName()));    &#125;&#125;
2.2 实现Runnable接口Thread类的构造方法允许传入一个实现Runnable接口的target进去，线程启动将会执行target.run方法。实现Runnable接口的方式可以很好的避免单继承问题。
package com.yuanxw.chapter1;/** * Java中创建线程二：实现Runnable接口重写run方法 */public class MyRunnable implements Runnable&#123;    public static void main(String[] args) &#123;        MyRunnable myRunnable = new MyRunnable();        Thread thread = new Thread(myRunnable);        thread.start();        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, Thread.currentThread().getName()));    &#125;    @Override    public void run() &#123;        for (int i = 0; i &lt; 20; i++) &#123;            try &#123;                System.out.println(String.format(&quot;线程：【%s】,打印：%s&quot;, Thread.currentThread().getName(),i));                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, Thread.currentThread().getName()));    &#125;&#125;
2.3 实现Callable接口call方法与run方法最大的区别在于call方法存在返回值futureTask的get方法可以获取这个返回值。使用此种方法实现线程的好处是当你创建的任务的结果不是立即就要时，你可以提交一个线程在后台执行，而你的程序仍可以正常运行下去，在需要执行结果时使用futureTask去获取即可。这是一种典型的异步任务处理的方法。
package com.yuanxw.chapter1;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;import java.util.concurrent.TimeoutException;public class MyCallable implements Callable &#123;    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException &#123;        FutureTask futureTask1 = new FutureTask(new MyCallable());        new Thread(futureTask1,&quot;子线程-A&quot;).start();        FutureTask futureTask2 = new FutureTask(new MyCallable());        new Thread(futureTask2,&quot;子线程-B&quot;).start();        // futureTask可以在指定时间内获取线程执行的返回值，超时则丢弃任务        //  因此futureTask可以用作异步任务处理        // futureTask.get(1000, TimeUnit.SECONDS);        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, Thread.currentThread().getName()));    &#125;    @Override    public Object call() throws Exception &#123;        int sum = 0;        for (int i = 0; i &lt; 50; i++) &#123;            try &#123;                System.out.println(String.format(&quot;线程：【%s】,打印：%s&quot;, Thread.currentThread().getName(),i));                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            sum += i;        &#125;        System.out.println(String.format(&quot;线程：【%s】,运行结束&quot;, Thread.currentThread().getName()));        System.out.println(&quot;执行结果：&quot; + sum);        return sum;    &#125;&#125;

3. 线程的生命周期和状态Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：由上图可以看出：线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。
学习推荐书籍： [1]: 《Java并发编程实践 》 [2]: 《Java并发编程的艺术 》 [3]: 《Java高并发编程详解：多线程与架构设计 》 [4]: 《Java多线程编程核心技术（第2版） 》
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(七)Java多线程之synchronized(同步锁)</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%83)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bsynchronized(%E5%90%8C%E6%AD%A5%E9%94%81)/</url>
    <content><![CDATA[1.JAVA多线程(七)Java多线程之synchronized(同步锁)1.1 synchronized(同步锁)&emsp;&emsp;synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
synchronized 关键字最主要的三种使用方式：

修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

总结 ： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！
1.1.1.模拟多线程下单减库存，在不锁的情况的结果一个抢购活动某个商品的总数是一个常数，购买者可以有多个，每个购买操作都会使总数减少。我们竟然发现了 余票为-1 -2的情况，这就与实际不符。原因在于 多个线程同时执行同一段代码，导致变量错误。
package com.yuanxw.chapter7;/** * 多线程处理订单 */public class ThreadOrder &#123;    public static void main(String[] args) &#123;        OrderPayService orderPayService = new OrderPayService();        new Thread(orderPayService).start();        new Thread(orderPayService).start();        new Thread(orderPayService).start();        new Thread(orderPayService).start();    &#125;&#125;class OrderPayService implements Runnable &#123;    /** 最大库存 **/    private  int maxQuantityNum = 10;    @Override    public void run() &#123;        while (maxQuantityNum &gt;0)&#123;            try &#123;                Thread.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(String.format(&quot;您抢购商品，库存只剩下【%s】个商品&quot;, maxQuantityNum--));        &#125;    &#125;&#125;
执行结果
您抢购商品，库存只剩下【9】个商品您抢购商品，库存只剩下【8】个商品您抢购商品，库存只剩下【7】个商品您抢购商品，库存只剩下【10】个商品您抢购商品，库存只剩下【6】个商品您抢购商品，库存只剩下【6】个商品您抢购商品，库存只剩下【4】个商品您抢购商品，库存只剩下【5】个商品您抢购商品，库存只剩下【3】个商品您抢购商品，库存只剩下【3】个商品您抢购商品，库存只剩下【2】个商品您抢购商品，库存只剩下【1】个商品您抢购商品，库存只剩下【-1】个商品您抢购商品，库存只剩下【0】个商品
我们应对这段代码进行加锁控制
package com.yuanxw.chapter7;/** * 多线程处理订单 */public class ThreadOrderSynchronized &#123;    public static void main(String[] args) &#123;        OrderPaymentService orderPaymentService = new OrderPaymentService();        new Thread(orderPaymentService).start();        new Thread(orderPaymentService).start();        new Thread(orderPaymentService).start();        new Thread(orderPaymentService).start();    &#125;&#125;class OrderPaymentService implements Runnable &#123;    /** 最大库存 **/    private  int maxQuantityNum = 10;    /** 监控 **/    private final Object MONITOR = new Object();    @Override    public void run() &#123;        // synchronized 关键字加到实例方法上是给对象实例上锁        synchronized (MONITOR) &#123;            while (maxQuantityNum &gt; 0) &#123;                try &#123;                    Thread.sleep(3);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(String.format(&quot;您抢购商品，库存只剩下【%s】个商品&quot;, maxQuantityNum--));            &#125;        &#125;    &#125;&#125;
执行结果
您抢购商品，库存只剩下【10】个商品您抢购商品，库存只剩下【9】个商品您抢购商品，库存只剩下【8】个商品您抢购商品，库存只剩下【7】个商品您抢购商品，库存只剩下【6】个商品您抢购商品，库存只剩下【5】个商品您抢购商品，库存只剩下【4】个商品您抢购商品，库存只剩下【3】个商品您抢购商品，库存只剩下【2】个商品您抢购商品，库存只剩下【1】个商品

通过 JDK 自带的 javap 命令查看 OrderPaymentService.class 类的相关字节码信息：首先切换到类的对应目录执行 javac OrderPaymentService.java 命令生成编译后的 OrderPaymentService.class 文件，然后执行javap -c -s -v -l OrderPaymentService.class从上面我们可以看出：
synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
1.2 单例模式(一)：【双重校验锁实现对象单例（线程安全）】双重检验锁方式实现单例模式的原理：需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。
package com.yuanxw.chapter7;/** * 单例模式：一 */public class Singleton &#123;    // 内存可见性    private volatile static Singleton uniqueInstance;    private Singleton() &#123;    &#125;    public static Singleton getUniqueInstance() &#123;        //先判断对象是否已经实例过，没有实例化过才进入加锁代码        if (uniqueInstance == null) &#123;            //类对象加锁            synchronized (Singleton.class) &#123;                if (uniqueInstance == null) &#123;                    uniqueInstance = new Singleton();                &#125;            &#125;        &#125;        return uniqueInstance;    &#125;&#125;

uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行：
为 uniqueInstance 分配内存空间
初始化 uniqueInstance
将 uniqueInstance 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。
使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。
1.3 单例模式(二)单例模式(二)：JVM类在加载的时候，只会运行一次，静态类可以严格的保证线程执行顺序 
package com.yuanxw.chapter7;/** * 单例模式：二 */public class SingletonHolder &#123;    private SingletonHolder()&#123;    &#125;    /** JVM类在加载的时候，只会运行一次，静态类可以严格的保证线程执行顺序 **/    private static class InstanceHolder&#123;        private final static SingletonHolder instance = new SingletonHolder();    &#125;    public static SingletonHolder getInstance()&#123;        // 只有使用时才会加载。        return  SingletonHolder.getInstance();    &#125;&#125;
1.4 单例模式(三)通过枚举的方式，保证线程安全。枚举构造函数只会被装载一次，因此可以保证对象只会被创建一次。
package com.yuanxw.chapter7;/** * 单例模式：三 * 推荐使用 */public class SingtonEnum &#123;    private SingtonEnum()&#123;    &#125;    /**     * 通过枚举的方式，保证线程安全     */    private enum Sington &#123;        INSTANCE;        private final SingtonEnum instance;        Sington() &#123;            // 只会被创建一次            instance = new SingtonEnum();        &#125;        public SingtonEnum getInstance() &#123;            return instance;        &#125;    &#125;    /**     * 获得单例     * @return     */    public static SingtonEnum getInstance()&#123;        return Sington.INSTANCE.getInstance();    &#125;&#125;


 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(七)Java多线程之synchronized(同步锁)》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(三)Java多线程之守护线程</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[1.JAVA多线程(三)Java多线程之守护线程1.1 daemon(守护线程)&emsp;&emsp;Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)。用户线程即运行在前台的线程，而守护线程是运行在后台的线程。

&emsp;&emsp; 用户线程：运行在前台，执行具体的任务，程序的主线程，连接网络的子线程等都是用户线程。

&emsp;&emsp; 守护线程：运行在后台，为其他前台线程服务。

特点：当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。
应用：数据库连接池中的监测线程JVM启动后的监测线程
最常见的守护线程：垃圾回收线程
如何设置守护线程：可以通过Thread类的setDaemon（true）方法来设置当前的线程为守护线程



package com.yuanxw.chapter3;/** * 守护线程 */public class DaemonThread &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread()&#123;            @Override            public void run() &#123;                while (true)&#123;                    try &#123;                        sleep(500L);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(&quot;connecting to network ...&quot;);                &#125;            &#125;        &#125;;        /**         * 设置为守护线程，必须的调用start()方法之前设置。         * 在start()方法之后设置：Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException         */        thread.setDaemon(true);        thread.start();    &#125;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(三)Java多线程之守护线程》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(九)Java多线程之生产者与消费者</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B9%9D)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[1.JAVA多线程(九)Java多线程之生产者与消费者
需求如下：自定义多线程生产者与消费者
1.如果生产者没有生产消息，就需要去生产消息，消费者就需要等待消费者生产完以后再去消费。
2.如果消费者没有消费消息，那么生产者就需要等待，消费都消费完成后，再去生产消息。

1.1 生产者与消费者【一个生产线程和一个消费者线程】package com.yuanxw.chapter9;/** * 自定义多线程生产者与消费者 * 1.如果生产者没有生产消息，就需要去生产消息，消费者就需要等待消费者生产完以后再去消费。 * 2.如果消费者没有消费消息，那么生产者就需要等待，消费都消费完成后，再去生产消息。 */public class ProduceConsumer &#123;    /** 生产数量 **/    private int num = 0;    /** 锁 **/    protected final Object LOCK = new Object();    /** volatile:内存可见性关键字，默认为没有生产，可以进行生产 **/    private volatile boolean isProducted = false;    /**     * 生产方法     * @return     */    public void produce() throws InterruptedException &#123;        // 同步生产        synchronized (LOCK)&#123;            // 如果消息已经生产，需要等待消费者消费后再去生产            if(isProducted)&#123;                /**                 * 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。                 * 它们都属于 Object 的一部分，而不属于 Thread。                 */                LOCK.wait();            &#125;else &#123;                // 如果已经消费，那么就需要进行生产                num++;                System.out.println(String.format(&quot;生产消息&gt;&gt;【%s】&quot;, num));                /**                 * 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。                 * 它们都属于 Object 的一部分，而不属于 Thread。                 */                // 通知消费者，可以进行消费                LOCK.notify();                // 设置标记：已经生产                isProducted = true;            &#125;        &#125;    &#125;    /**     * 消费方法     */    public void consumer() throws InterruptedException &#123;        // 同步消费        synchronized (LOCK)&#123;            // 如果已经生产，那么消费者消费            if(isProducted)&#123;                System.out.println(String.format(&quot;消费消息&lt;&lt;【%s】&quot;, num));                // 通知生产者已经消费                LOCK.notify();                // 设置标记：未生产                isProducted = false;            &#125;else &#123;                // 如果已经没有生产，即需要消息费进行等待生产者进行生产                LOCK.wait();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        ProduceConsumer produceConsumer = new ProduceConsumer();        // 生产者：生产线程        new Thread(()-&gt;&#123;            try &#123;                while (true) &#123;                    produceConsumer.produce();                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        // 消费者：消费线程        new Thread(()-&gt;&#123;            try &#123;                while (true) &#123;                    produceConsumer.consumer();                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;

执行结果：
生产消息&gt;&gt;【1】消费消息&lt;&lt;【1】生产消息&gt;&gt;【2】消费消息&lt;&lt;【2】生产消息&gt;&gt;【3】消费消息&lt;&lt;【3】生产消息&gt;&gt;【4】消费消息&lt;&lt;【4】生产消息&gt;&gt;【5】消费消息&lt;&lt;【5】生产消息&gt;&gt;【6】消费消息&lt;&lt;【6】生产消息&gt;&gt;【7】消费消息&lt;&lt;【7】生产消息&gt;&gt;【8】消费消息&lt;&lt;【8】生产消息&gt;&gt;【9】消费消息&lt;&lt;【9】生产消息&gt;&gt;【10】消费消息&lt;&lt;【10】

1.2 生产者与消费者【多个生产线程和多个消费者线程】package com.yuanxw.chapter9;import java.util.Arrays;/** * 自定义多线程生产者与消费者【多生產者多消費者】 * 1.如果生产者没有生产消息，就需要去生产消息，消费者就需要等待消费者生产完以后再去消费。 * 2.如果消费者没有消费消息，那么生产者就需要等待，消费都消费完成后，再去生产消息。 */public class MultiProduceConsumer &#123;    /** 生产数量 **/    private int num = 0;    /** 锁 **/    protected final Object LOCK = new Object();    /** volatile:内存可见性关键字，默认为没有生产，可以进行生产 **/    private volatile boolean isProducted = false;    /**     * 生产方法     * @return     */    public void produce() throws InterruptedException &#123;        // 同步生产        synchronized (LOCK)&#123;            // 如果消息已经生产，需要等待消费者消费后再去生产            while (isProducted)&#123;                /**                 * 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。                 * 它们都属于 Object 的一部分，而不属于 Thread。                 */                LOCK.wait();            &#125;            // 如果已经消费，那么就需要进行生产            num++;            System.out.println(String.format(&quot;生产消息&gt;&gt;&gt;&gt;【%s】&quot;, num));            /**             * 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。             * 它们都属于 Object 的一部分，而不属于 Thread。             */            // 通知消费者，可以进行消费            LOCK.notifyAll();            // 设置标记：已经生产            isProducted = true;        &#125;    &#125;    /**     * 消费方法     */    public void consumer() throws InterruptedException &#123;        // 同步消费        synchronized (LOCK)&#123;            // 如果已经生产，那么消费者消费            while (!isProducted)&#123;                // 如果已经没有生产，即需要消息费进行等待生产者进行生产                LOCK.wait();            &#125;            System.out.println(String.format(&quot;消费消息&lt;&lt;&lt;&lt;【%s】&quot;, num));            // 通知生产者已经消费            LOCK.notifyAll();            // 设置标记：未生产            isProducted = false;        &#125;    &#125;    public static void main(String[] args) &#123;        MultiProduceConsumer produceConsumer = new MultiProduceConsumer();        Arrays.asList(&quot;Produce1&quot;,&quot;Produce2&quot;,&quot;Produce3&quot;,&quot;Produce4&quot;,&quot;Produce5&quot;,&quot;Produce6&quot;,&quot;Produce7&quot;,&quot;Produce8&quot;).forEach(p-&gt;&#123;            // 生产者Produce            new Thread(()-&gt;&#123;                try &#123;                    while (true) &#123;                        produceConsumer.produce();                         Thread.sleep(10L);                    &#125;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;,p).start();        &#125;);        Arrays.asList(&quot;Consumer1&quot;,&quot;Consumer2&quot;,&quot;Consumer3&quot;,&quot;Consumer4&quot;,&quot;Consumer5&quot;,&quot;Consumer6&quot;).forEach(c-&gt; &#123;            // 消费者            new Thread(() -&gt; &#123;                try &#123;                    while (true) &#123;                        produceConsumer.consumer();                         Thread.sleep(10L);                    &#125;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;,c).start();        &#125;);    &#125;&#125;
执行结果：
生产消息&gt;&gt;&gt;&gt;【1】消费消息&lt;&lt;&lt;&lt;【1】生产消息&gt;&gt;&gt;&gt;【2】消费消息&lt;&lt;&lt;&lt;【2】生产消息&gt;&gt;&gt;&gt;【3】消费消息&lt;&lt;&lt;&lt;【3】生产消息&gt;&gt;&gt;&gt;【4】消费消息&lt;&lt;&lt;&lt;【4】生产消息&gt;&gt;&gt;&gt;【5】消费消息&lt;&lt;&lt;&lt;【5】生产消息&gt;&gt;&gt;&gt;【6】消费消息&lt;&lt;&lt;&lt;【6】生产消息&gt;&gt;&gt;&gt;【7】消费消息&lt;&lt;&lt;&lt;【7】生产消息&gt;&gt;&gt;&gt;【8】消费消息&lt;&lt;&lt;&lt;【8】生产消息&gt;&gt;&gt;&gt;【9】消费消息&lt;&lt;&lt;&lt;【9】生产消息&gt;&gt;&gt;&gt;【10】消费消息&lt;&lt;&lt;&lt;【10】生产消息&gt;&gt;&gt;&gt;【11】消费消息&lt;&lt;&lt;&lt;【11】生产消息&gt;&gt;&gt;&gt;【12】消费消息&lt;&lt;&lt;&lt;【12】生产消息&gt;&gt;&gt;&gt;【13】消费消息&lt;&lt;&lt;&lt;【13】生产消息&gt;&gt;&gt;&gt;【14】消费消息&lt;&lt;&lt;&lt;【14】生产消息&gt;&gt;&gt;&gt;【15】消费消息&lt;&lt;&lt;&lt;【15】生产消息&gt;&gt;&gt;&gt;【16】消费消息&lt;&lt;&lt;&lt;【16】生产消息&gt;&gt;&gt;&gt;【17】消费消息&lt;&lt;&lt;&lt;【17】生产消息&gt;&gt;&gt;&gt;【18】消费消息&lt;&lt;&lt;&lt;【18】生产消息&gt;&gt;&gt;&gt;【19】消费消息&lt;&lt;&lt;&lt;【19】生产消息&gt;&gt;&gt;&gt;【20】消费消息&lt;&lt;&lt;&lt;【20】

1.3 JAVA中sleep() 方法和 wait() 方法区别
sleep方法是Thread类的方法，而wait方法是Object方法。
sleep方法没有释放锁，而wait方法释放了锁，并且加入到Object的queue。
使用sleep方法不用synchronized监控，而wait方法需要。
使用sleep方法不需要唤醒，而wait需要。

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(九)Java多线程之生产者与消费者》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二)Java多线程之火车票</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%81%AB%E8%BD%A6%E7%A5%A8/</url>
    <content><![CDATA[1. JAVA多线程(二)Java多线程之火车票&emsp;&emsp;需求如下：铁道部发布了一个售票任务，要求销售10张票，要求有4个窗口来进行销售，请编写多线程程序来模拟这个效果

第001窗口，正在售票，票号：1
第004窗口，正在售票，票号：2
第002窗口，正在售票，票号：3
第003窗口，正在售票，票号：4

1.1 继承Thread类多线程进行售票继承Thread类的方式创建多线程进行售票的方式，在不加锁的情况下，每一个窗口都独立个体，数据没有共享。（四个窗口都卖了10张票，这显然不是我们想的结果），代码如下：
package com.yuanxw.chapter2;/** * 火车票售票 */public class RailwayStation &#123;    public static void main(String[] args) &#123;        TicketWindow ticketWindow1 = new TicketWindow(&quot;001窗口&quot;);        TicketWindow ticketWindow2 = new TicketWindow(&quot;002窗口&quot;);        TicketWindow ticketWindow3 = new TicketWindow(&quot;003窗口&quot;);        TicketWindow ticketWindow4 = new TicketWindow(&quot;004窗口&quot;);        ticketWindow1.start();        ticketWindow2.start();        ticketWindow3.start();        ticketWindow4.start();    &#125;&#125;

package com.yuanxw.chapter2;/** * 售票窗口 * @author yuanxw */public class TicketWindow  extends Thread &#123;    /** 最大售数 **/    private final int MAX_NUMBER = 10;    /** 当前售数 **/    private int currentNumber = 1;    /** 窗口名称 **/    private String name;    public TicketWindow(String name) &#123;        this.name = name;    &#125;    @Override    public void run() &#123;        while (currentNumber &lt;= MAX_NUMBER)&#123;            System.out.println(String.format(&quot;第%s，正在售票，票号：%s&quot;, name,currentNumber++));        &#125;    &#125;&#125;
执行结果：
第001窗口，正在售票，票号：1第002窗口，正在售票，票号：1第003窗口，正在售票，票号：1第001窗口，正在售票，票号：2第004窗口，正在售票，票号：1第003窗口，正在售票，票号：2第001窗口，正在售票，票号：3第003窗口，正在售票，票号：3第001窗口，正在售票，票号：4第003窗口，正在售票，票号：4第002窗口，正在售票，票号：2第001窗口，正在售票，票号：5第003窗口，正在售票，票号：5第002窗口，正在售票，票号：3第004窗口，正在售票，票号：2第003窗口，正在售票，票号：6第002窗口，正在售票，票号：4第001窗口，正在售票，票号：6第003窗口，正在售票，票号：7第002窗口，正在售票，票号：5第001窗口，正在售票，票号：7第004窗口，正在售票，票号：3第002窗口，正在售票，票号：6第001窗口，正在售票，票号：8第003窗口，正在售票，票号：8第002窗口，正在售票，票号：7第001窗口，正在售票，票号：9第003窗口，正在售票，票号：9第002窗口，正在售票，票号：8第004窗口，正在售票，票号：4第001窗口，正在售票，票号：10第002窗口，正在售票，票号：9第003窗口，正在售票，票号：10第004窗口，正在售票，票号：5第002窗口，正在售票，票号：10第004窗口，正在售票，票号：6第004窗口，正在售票，票号：7第004窗口，正在售票，票号：8第004窗口，正在售票，票号：9第004窗口，正在售票，票号：10

2.2 实现Runnable接口多线程进行售票实现Runnable接口的方式将我们可执行的逻辑单元和我们的线程控制分离，Runnable接口更加适合多个相同线程处理同一份资源的情况。
package com.yuanxw.chapter2;/** * 高铁站售票 */public class HighSpeedRailStation &#123;    public static void main(String[] args) &#123;        TicketWindowRunnable ticketWindowRunnable = new TicketWindowRunnable();        Thread thread1 = new Thread(ticketWindowRunnable,&quot;001窗口&quot;);        Thread thread2 = new Thread(ticketWindowRunnable,&quot;002窗口&quot;);        Thread thread3 = new Thread(ticketWindowRunnable,&quot;003窗口&quot;);        Thread thread4 = new Thread(ticketWindowRunnable,&quot;004窗口&quot;);        thread1.start();        thread2.start();        thread3.start();        thread4.start();    &#125;&#125;

package com.yuanxw.chapter2;/** * 实现Runnable方式售票 */public class TicketWindowRunnable implements Runnable &#123;    /** 最大售数 **/    private final int MAX_NUMBER = 10;    /** 当前售数 **/    private int currentNumber = 1;    @Override    public void run() &#123;        try &#123;            Thread.sleep(100);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        while (currentNumber &lt;= MAX_NUMBER)&#123;            System.out.println(String.format(&quot;第%s，正在售票，票号：%s&quot;, Thread.currentThread().getName(),currentNumber++));        &#125;    &#125;&#125;

执行结果：
第001窗口，正在售票，票号：2第002窗口，正在售票，票号：3第004窗口，正在售票，票号：1第003窗口，正在售票，票号：4第001窗口，正在售票，票号：5第002窗口，正在售票，票号：6第004窗口，正在售票，票号：7第001窗口，正在售票，票号：9第002窗口，正在售票，票号：10第003窗口，正在售票，票号：8


 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二)Java多线程之火车票》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 多线程(二十)Java 多线程之 FixedThreadPool 可重用固定线程数的线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BFixedThreadPool%E5%8F%AF%E9%87%8D%E7%94%A8%E5%9B%BA%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA 多线程(二十)Java 多线程之 FixedThreadPool 可重用固定线程数的线程池1.1 可重用固定线程数的线程池 FixedThreadPool&emsp;&emsp; 可重用固定线程数的线程池 FixedThreadPool 特点是：只有核心线程，不会被回收、线程数量固定、任务队列无大小限制（超出的线程任务会在队列中等待），通过源代码查看 FixedThreadPool 实现：
/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue.  At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks.  The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */public static ExecutorService newFixedThreadPool(int nThreads) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());&#125;/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue, using the provided * ThreadFactory to create new threads when needed.  At any point, * at most &#123;@code nThreads&#125; threads will be active processing * tasks.  If additional tasks are submitted when all threads are * active, they will wait in the queue until a thread is * available.  If any thread terminates due to a failure during * execution prior to shutdown, a new one will take its place if * needed to execute subsequent tasks.  The threads in the pool will * exist until it is explicitly &#123;@link ExecutorService#shutdown * shutdown&#125;. * * @param nThreads the number of threads in the pool * @param threadFactory the factory to use when creating new threads * @return the newly created thread pool * @throws NullPointerException if threadFactory is null * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;(),                                  threadFactory);&#125;/** * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;. */public LinkedBlockingQueue() &#123;    this(Integer.MAX_VALUE);&#125;

在 FixedThreadPool 实现中：

corePoolSize &amp;&amp; maximumPoolSize，核心线程数和允许最大的线程数一致，可以指定无限大，在资源有限的情况下容易引起 OOM 异常。
keepAliveTime &#x3D;&gt; keepAliveTime 为 0，意味着多余的空闲线程会被立即终止。
workQueue &#x3D;&gt; 采用无界队列 LinkedBlockingQueue 作为线程池的工作队列（队列的容量为 Integer.MAX_VALUE），会在循环中反复从 LinkedBlockingQueue 获取任务来执行。

1.2 FixedThreadPool 使用样例FixedThreadPool 线程池使用 LinkedBlockingQueue 作为线程池的工作队列会对线程池带来如下影响：

当线程池中的线程数达到 corePoolSize 核心线程数后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize 核心线程数。
使用无界队列，运行中的 FixedThreadPool 不会拒绝任务，（未执行方法 shutdown()或 shutdownNow()，不会调用 RejectedExecutionHandler.rejectedExecution 方法），在任务比较多的时候会导致 OOM（内存溢出）。

package com.yuanxw.chapter20;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class FixedThreadPoolExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        ExecutorService executorService = Executors.newFixedThreadPool(5);        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());        for (int i = 0; i &lt; 10; i++) &#123;            executorService.execute(()-&gt;&#123;                try &#123;                    TimeUnit.SECONDS.sleep(1);                    System.out.println(String.format(&quot;线程【%s】正在工作&gt;&gt;&gt;&gt;&quot;, Thread.currentThread().getName()));                    System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;        TimeUnit.SECONDS.sleep(5);        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());        // corePoolSize 等于 maximumPoolSize，因此应用程序不会结束，需要调用executorService.shutdown()方法，关闭线程池。        executorService.shutdown();    &#125;&#125;

执行结果：
获得活动的线程评估数：0线程【pool-1-thread-2】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-3】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5线程【pool-1-thread-1】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：4线程【pool-1-thread-5】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5获得活动的线程评估数：5线程【pool-1-thread-4】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5线程【pool-1-thread-4】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-3】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-2】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-5】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5线程【pool-1-thread-1】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5获得活动的线程评估数：5获得活动的线程评估数：5获得活动的线程评估数：4获得活动的线程评估数：0

FixedThreadPool 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：

如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；
当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；
线程池中的线程执行完当前的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；

&emsp;&emsp;&emsp;&emsp;– 以上为《JAVA 多线程(二十)Java 多线程之 FixedThreadPool 可重用固定线程数的线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。
  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%83)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BLinkedBlockingQueue%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[1.JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器1.1 什么是LinkedBlockingQueue&emsp;&emsp;LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。
下面是 LinkedBlockingQueue继承结构关系图：

1.2 LinkedBlockingQueue单向链表实现的阻塞队列&emsp;&emsp;LinkedBlockingQueue是一个阻塞队列，内部由两个ReentrantLock来实现出入队列的线程安全，由各自的Condition对象的await和signal来实现等待和唤醒功能。它和ArrayBlockingQueue的不同点在于：

队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。
数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。
由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。
两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

通过源代码查看LinkedBlockingQueue实现：
/** * 创建一个 LinkedBlockingQueue ，容量为 Integer.MAX_VALUE 。  * * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;. */public LinkedBlockingQueue() &#123;    this(Integer.MAX_VALUE);&#125;/** * 创建一个具有给定（固定）容量的 LinkedBlockingQueue 。  * Creates a &#123;@code LinkedBlockingQueue&#125; with the given (fixed) capacity. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if &#123;@code capacity&#125; is not greater *         than zero */public LinkedBlockingQueue(int capacity) &#123;    if (capacity &lt;= 0) throw new IllegalArgumentException();    this.capacity = capacity;    last = head = new Node&lt;E&gt;(null);&#125;/** * 创建一个 LinkedBlockingQueue ，容量为 Integer.MAX_VALUE ，最初包含给定集合的元素，以集合的迭代* 器的遍历顺序添加。  * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;, initially containing the elements of the * given collection, * added in traversal order of the collection&#x27;s iterator. * * @param c the collection of elements to initially contain * @throws NullPointerException if the specified collection or any *         of its elements are null */public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) &#123;    this(Integer.MAX_VALUE);    final ReentrantLock putLock = this.putLock;    putLock.lock(); // Never contended, but necessary for visibility    try &#123;        int n = 0;        for (E e : c) &#123;            if (e == null)                throw new NullPointerException();            if (n == capacity)                throw new IllegalStateException(&quot;Queue full&quot;);            enqueue(new Node&lt;E&gt;(e));            ++n;        &#125;        count.set(n);    &#125; finally &#123;        putLock.unlock();    &#125;&#125;

1.3 常用的方法package com.yuanxw.thread.chapter27;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class LinkedBlockingQueueExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        // add();        // offer();        // put();        // poll();        // peek();        // element();         remove();    &#125;    /**     如果可以在不超过队列的容量的情况下立即将其指定的元素插入到该队列，     如果队列已满，则返回 true并抛出 IllegalStateException 。     执行结果：         =====执行add()签名方法-开始=====         linkedBlockingQueue.add()执行返回结果：true         linkedBlockingQueue.add()执行返回结果：true         linkedBlockingQueue.add()执行返回结果：true         Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full         at java.util.AbstractQueue.add(AbstractQueue.java:98)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.add(LinkedBlockingQueueExample.java:38)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.main(LinkedBlockingQueueExample.java:9)     */    public static void add() &#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        System.out.println(&quot;linkedBlockingQueue.add()执行返回结果：&quot;+linkedBlockingQueue.add(&quot;Message 1&quot;));        System.out.println(&quot;linkedBlockingQueue.add()执行返回结果：&quot;+linkedBlockingQueue.add(&quot;Message 2&quot;));        System.out.println(&quot;linkedBlockingQueue.add()执行返回结果：&quot;+linkedBlockingQueue.add(&quot;Message 3&quot;));        System.out.println(&quot;linkedBlockingQueue.add()执行返回结果：&quot;+linkedBlockingQueue.add(&quot;Message 4&quot;));        System.out.println(&quot;=====执行add()签名方法-结束=====&quot;);    &#125;    /**     * 如果可以在不超过队列容量的情况下立即将其指定的元素插入该队列的尾部，     * 则在成功时true如果该队列已满，则返回false 。     执行结果：         =====执行offer()签名方法-开始=====         linkedBlockingQueue.offer()执行返回结果：true         linkedBlockingQueue.offer()执行返回结果：true         linkedBlockingQueue.offer()执行返回结果：true         linkedBlockingQueue.offer()执行返回结果：false         =====执行offer()签名方法-结束=====     */    public static void offer()&#123;        System.out.println(&quot;=====执行offer()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        System.out.println(&quot;linkedBlockingQueue.offer()执行返回结果：&quot;+linkedBlockingQueue.offer(&quot;Message 1&quot;));        System.out.println(&quot;linkedBlockingQueue.offer()执行返回结果：&quot;+linkedBlockingQueue.offer(&quot;Message 2&quot;));        System.out.println(&quot;linkedBlockingQueue.offer()执行返回结果：&quot;+linkedBlockingQueue.offer(&quot;Message 3&quot;));        System.out.println(&quot;linkedBlockingQueue.offer()执行返回结果：&quot;+linkedBlockingQueue.offer(&quot;Message 4&quot;));        System.out.println(&quot;=====执行offer()签名方法-结束=====&quot;);    &#125;    /**     * 在该队列的尾部插入指定的元素，如果队列已满，则等待空间变为可用。     执行结果：     =====执行put()签名方法-开始=====     当前linkedBlockingQueue对象中的个数：3     当前linkedBlockingQueue对象中的容量：0     当前linkedBlockingQueue对象中take()数据值为：Message 1     Message 2     Message 3     Message 4     =====执行put()签名方法-结束=====     */    public static void put() throws InterruptedException &#123;        System.out.println(&quot;=====执行put()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        Executors.newSingleThreadExecutor().execute(()-&gt;&#123;            System.out.println(&quot;当前linkedBlockingQueue对象中的个数：&quot; + linkedBlockingQueue.size());            System.out.println(&quot;当前linkedBlockingQueue对象中的容量：&quot; + linkedBlockingQueue.remainingCapacity());            try &#123;                TimeUnit.SECONDS.sleep(5);                // 检索并删除此队列的头                Object take = linkedBlockingQueue.take();                System.out.println(&quot;当前linkedBlockingQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        linkedBlockingQueue.put(&quot;Message 4&quot;);        linkedBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行put()签名方法-结束=====&quot;);    &#125;    /**     * 检索并删除此队列的头，则等待空间变为可用。     执行结果：     =====执行poll()签名方法-开始=====     当前linkedBlockingQueue对象中的个数：【3】,容量：【0】     当前linkedBlockingQueue对象中poll()数据值为：Message 1     当前linkedBlockingQueue对象中poll()数据值为：Message 2     当前linkedBlockingQueue对象中的个数：【1】,容量：【2】     当前linkedBlockingQueue对象中poll()数据值为：Message 3     当前linkedBlockingQueue对象中poll()数据值为：null     当前linkedBlockingQueue对象中poll()数据值为：null     =====执行poll()签名方法-结束=====     */    public static void poll() throws InterruptedException &#123;        System.out.println(&quot;=====执行poll()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(&quot;当前linkedBlockingQueue对象中poll()数据值为：&quot; + linkedBlockingQueue.poll());        System.out.println(&quot;=====执行poll()签名方法-结束=====&quot;);    &#125;    /**     * 检索但不删除此队列的头，如果此队列为空，则返回 null。     执行结果：         =====执行peek()签名方法-开始=====         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】         当前linkedBlockingQueue对象中peek()数据值为：Message 1         当前linkedBlockingQueue对象中peek()数据值为：Message 1         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】         当前linkedBlockingQueue对象中peek()数据值为：Message 1         当前linkedBlockingQueue对象中peek()数据值为：Message 1         当前linkedBlockingQueue对象中peek()数据值为：Message 1         =====执行peek()签名方法-结束=====     */    public static void peek() throws InterruptedException &#123;        System.out.println(&quot;=====执行peek()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(&quot;当前linkedBlockingQueue对象中peek()数据值为：&quot; + linkedBlockingQueue.peek());        System.out.println(&quot;=====执行peek()签名方法-结束=====&quot;);    &#125;    /**     * 检索，但不删除，这个队列的头。 此方法与peek的不同之处在于，如果此队列为空，它将抛出异常。     执行结果：         =====执行element()签名方法-开始=====         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】         当前linkedBlockingQueue对象中的个数：【0】,容量：【3】         Exception in thread &quot;main&quot; java.util.NoSuchElementException         at java.util.AbstractQueue.element(AbstractQueue.java:136)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.element(LinkedBlockingQueueExample.java:181)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.main(LinkedBlockingQueueExample.java:14)     */    public static void element() throws InterruptedException &#123;        System.out.println(&quot;=====执行element()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        linkedBlockingQueue.clear();        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中element()数据值为：&quot; + linkedBlockingQueue.element());        System.out.println(&quot;=====执行element()签名方法-结束=====&quot;);    &#125;    /**     * 检索并删除此队列的头。 此方法与poll不同之处在于，如果此队列为空，它将抛出异常。     执行结果：         =====执行remove()签名方法-开始=====         当前linkedBlockingQueue对象中的个数：【3】,容量：【0】         当前linkedBlockingQueue对象中remove()数据值为：Message 1         当前linkedBlockingQueue对象中remove()数据值为：Message 2         当前linkedBlockingQueue对象中remove()数据值为：Message 3         Exception in thread &quot;main&quot; java.util.NoSuchElementException         at java.util.AbstractQueue.remove(AbstractQueue.java:117)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.remove(LinkedBlockingQueueExample.java:205)         at com.yuanxw.thread.chapter27.LinkedBlockingQueueExample.main(LinkedBlockingQueueExample.java:15)     */    public static void remove() throws InterruptedException &#123;        System.out.println(&quot;=====执行remove()签名方法-开始=====&quot;);        LinkedBlockingQueue linkedBlockingQueue = new LinkedBlockingQueue(3);        linkedBlockingQueue.put(&quot;Message 1&quot;);        linkedBlockingQueue.put(&quot;Message 2&quot;);        linkedBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot; + linkedBlockingQueue.remove());        System.out.println(&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot; + linkedBlockingQueue.remove());        System.out.println(&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot; + linkedBlockingQueue.remove());        System.out.println(&quot;当前linkedBlockingQueue对象中remove()数据值为：&quot; + linkedBlockingQueue.remove());        System.out.println(String.format(&quot;当前linkedBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, linkedBlockingQueue.size(),linkedBlockingQueue.remainingCapacity()));        System.out.println(&quot;=====执行remove()签名方法-结束=====&quot;);    &#125;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十七)Java多线程之LinkedBlockingQueue容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%89)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BScheduledThreadPool%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池1.1 定时执行任务线程池ScheduledThreadPoolExecutor&emsp;&emsp; ScheduledThreadPoolExecutor是一个使用线程池执行定时任务的类，相较于Java中提供的另一个执行定时任务的类Timer，其主要有如下两个优点：

使用多线程执行任务，不用担心任务执行时间过长而导致任务相互阻塞的情况，Timer是单线程执行的，因而会出现这个问题。
不用担心任务执行过程中，如果线程失活，其会新建线程执行任务，Timer类的单线程挂掉之后是不会重新创建线程执行后续任务的。

时cheduledThreadPoolExecutor定 执行任务线程池继承结构关系图：
通过源代码查看ScheduledThreadPoolExecutor构造函数实现：
/** * 创建一个ScheduledThreadPoolExecutor，需要指定核心线程池大小。 * Creates a new &#123;@code ScheduledThreadPoolExecutor&#125; with the * given core pool size. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */public ScheduledThreadPoolExecutor(int corePoolSize) &#123;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue());&#125;/** * Creates a new ScheduledThreadPoolExecutor with the given * initial parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; * @throws NullPointerException if &#123;@code handler&#125; is null */public ScheduledThreadPoolExecutor(int corePoolSize,                                   RejectedExecutionHandler handler) &#123;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue(), handler);&#125;/** * Creates a new &#123;@code ScheduledThreadPoolExecutor&#125; with the * given initial parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param threadFactory the factory to use when the executor *        creates a new thread * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; * @throws NullPointerException if &#123;@code threadFactory&#125; is null */public ScheduledThreadPoolExecutor(int corePoolSize,                                   ThreadFactory threadFactory) &#123;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue(), threadFactory);&#125;/** * Creates a new ScheduledThreadPoolExecutor with the given * initial parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param threadFactory the factory to use when the executor *        creates a new thread * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; * @throws NullPointerException if &#123;@code threadFactory&#125; or *         &#123;@code handler&#125; is null */public ScheduledThreadPoolExecutor(int corePoolSize,                                   ThreadFactory threadFactory,                                   RejectedExecutionHandler handler) &#123;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue(), threadFactory, handler);&#125;
在ScheduledThreadPoolExecutor实现中：

corePoolSize &#x3D;&gt; 需要自己传递参数，指定核心线程数大小。
maximumPoolSize &#x3D;&gt; 允许最大的线程数默认Integer.MAX_VALUE无限大。
keepAliveTime &#x3D;&gt; keepAliveTime为0，意味着多余的空闲线程会被立即终止。
workQueue &#x3D;&gt; 采用DelayedWorkQueue作为线程池的工作队列。该队列是一个使用数组实现的优先队列，在调用ScheduledFutureTask::cancel()方法时，其会根据removeOnCancel变量的设置来确认是否需要将当前任务真正的从队列中移除，而不只是标识其为已删除状态。

1.2 ScheduledThreadPoolExecutor使用样例package com.yuanxw.chapter23;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ScheduledThreadPoolExample &#123;    public static void main(String[] args) &#123;        // schedule();        // scheduleAtFixedRate();        scheduleWithFixedDelay();    &#125;    /**     * 单次定时任务调用     * schedule(Runnable command, long delay, TimeUnit unit) // 无返回值的延迟任务     * schedule(Callable callable, long delay, TimeUnit unit) // 有返回值的延迟任务     */    private static void schedule() &#123;        // 设置核心线程数        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);        // 创建并执行在给定延迟后启用的单次操作。        ScheduledFuture&lt;?&gt; scheduledFuture = scheduledThreadPoolExecutor.schedule(() -&gt; System.out.println(&quot;定时任务正在被执行&gt;&gt;&gt;&quot;), 2L, TimeUnit.SECONDS);        // 尝试取消执行此任务。        System.out.println(scheduledFuture.cancel(true));    &#125;    /**         执行结果：          true     */          /**     * 固定频率周期任务     * 注意：一次任务超时，会持续的影响后续的任务周期；     */    private static void scheduleAtFixedRate()&#123;        // 设置核心线程数        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(5);        scheduledThreadPoolExecutor.scheduleAtFixedRate(()-&gt;System.out.println(String.format(&quot;===定时任务线程【%s】正在执行，执行时间：【%s】===&quot;, Thread.currentThread().getName(),System.currentTimeMillis())),2,2,TimeUnit.SECONDS);        /**         执行结果：          ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580728645370】===          ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580728647372】===          ===定时任务线程【pool-1-thread-2】正在执行，执行时间：【1580728649372】===          ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580728651374】===          ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580728653371】===         */    &#125;    /**     * 固定延迟周期任务     * 注意：固定延迟周期任务，即每次任务结束后，需要再加上等待固定时间；     */    private static void scheduleWithFixedDelay()&#123;        // 设置核心线程数        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(5);        scheduledThreadPoolExecutor.scheduleWithFixedDelay(() -&gt; &#123;            System.out.println(String.format(&quot;===定时任务线程【%s】正在执行，执行时间：【%s】===&quot;, Thread.currentThread().getName(),System.currentTimeMillis()));            try &#123;                // 睡眠5秒                TimeUnit.SECONDS.sleep(5);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,1,2,TimeUnit.SECONDS);        /**         执行结果：         ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580729087258】===         ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580729094268】===         ===定时任务线程【pool-1-thread-2】正在执行，执行时间：【1580729101272】===         ===定时任务线程【pool-1-thread-1】正在执行，执行时间：【1580729108273】===         ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580729115275】===         ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580729122277】===         ===定时任务线程【pool-1-thread-3】正在执行，执行时间：【1580729129279】===         */    &#125;&#125;

1.3 ScheduledThreadPoolExecutor运行机制&emsp;&emsp; ScheduledThreadPoolExecutor 使用的任务队列 DelayQueue 封装了一个 PriorityQueue，PriorityQueue 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(ScheduledFutureTask 的 time 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(ScheduledFutureTask 的 squenceNumber 变量小的先执行)。

ScheduledThreadPoolExecutor 和 Timer 的比较：

Timer 对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是；
Timer 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 ScheduledThreadPoolExecutor 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程;
在TimerTask 中抛出的运行时异常会杀死一个线程，从而导致 Timer 死机:-( …即计划任务将不再运行。ScheduledThreadExecutor 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 afterExecute 方法ThreadPoolExecutor）。抛出异常的任务将被取消，但其他任务将继续运行。


ScheduledThreadPoolExecutor 的执行主要分为两大部分：

当调用 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate() 方法或者scheduleWirhFixedDelay() 方法时，会向 ScheduledThreadPoolExecutor 的 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduledFutureTask 。  线程池中的线程从 DelayQueue 中获取 ScheduledFutureTask，然后执行任务。


ScheduledThreadPoolExecutor 为了实现周期性的执行任务，对 ThreadPoolExecutor 做了如下修改：

使用 DelayQueue 作为任务队列；
获取任务的方不同
执行周期任务后，增加了额外的处理



1.4 ScheduledThreadPoolExecutor 执行周期任务的步骤

线程 1 从 DelayQueue 中获取已到期的 ScheduledFutureTask（DelayQueue.take()）。到期任务是指 ScheduledFutureTask 的 time 大于等于当前系统的时间；
线程 1 执行这个 ScheduledFutureTask；
线程 1 修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间；
线程 1 把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add())。

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十三)Java多线程之ScheduledThreadPoolExecutor定时执行任务线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十一)Java多线程之SingleThreadExecutor单线程化线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%B8%80)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSingleThreadExecutor%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA多线程(二十一)Java多线程之SingleThreadExecutor单线程化线程池1.1 单线程化线程池SingleThreadExecutor&emsp;&emsp; SingleThreadExecutor 是只有一个线程的线程池。通过源代码查看SingleThreadExecutor实现：
/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.)  Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * &#123;@code newFixedThreadPool(1)&#125; the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */public static ExecutorService newSingleThreadExecutor() &#123;    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue, and uses the provided ThreadFactory to * create a new thread when needed. Unlike the otherwise * equivalent &#123;@code newFixedThreadPool(1, threadFactory)&#125; the * returned executor is guaranteed not to be reconfigurable to use * additional threads. * * @param threadFactory the factory to use when creating new * threads * * @return the newly created single-threaded Executor * @throws NullPointerException if threadFactory is null */public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;(),                                threadFactory));&#125;/** * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;. */public LinkedBlockingQueue() &#123;    this(Integer.MAX_VALUE);&#125;
在SingleThreadExecutor实现中：

corePoolSize &amp;&amp; maximumPoolSize，corePoolSize 和 maximumPoolSize 都被设置为：1。
keepAliveTime &#x3D;&gt; keepAliveTime为0，意味着多余的空闲线程会被立即终止。
workQueue &#x3D;&gt; 采用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE），会在循环中反复从LinkedBlockingQueue获取任务来执行。

1.2 SingleThreadExecutor使用样例
单线程化线程池SingleThreadExecutor特点：
只有一个核心线程（保证所有任务按照指定顺序在一个线程中执行，不需要处理线程同步的问题）。
应用场景：不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作，文件操作等。


SingleThreadExecutor的意义：
缓存线程、进行池化，可实现线程重复利用、避免重复创建和销毁所带来的性能开销。
当线程调度任务出现异常时，会重新创建一个线程替代掉发生异常的线程。
任务执行按照规定的调度规则执行。线程池通过队列形式来接收任务。再通过空闲线程来逐一取出进行任务调度。即线程池可以控制任务调度的执行顺序。
可制定拒绝策略。即任务队列已满时，后来任务的拒绝处理规则。



package com.yuanxw.chapter21;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;public class ScheduledThreadPoolExample &#123;    // 随机数：使用long参数的所有64位作为因子值。    private static Random random = new Random(System.currentTimeMillis());    public static void main(String[] args) &#123;        // 使用Executors创建单个worker线程的Executor        ExecutorService executorService = Executors.newSingleThreadExecutor();        // 始终只有一个线程，执行ScheduledThreadPoolExample#processTask方法        IntStream.range(1, 10).forEach(i -&gt; executorService.execute(ScheduledThreadPoolExample::processTask));        // corePoolSize 和 maximumPoolSize都是：1，因此应用程序不会结束，需要调用executorService.shutdown()方法，关闭线程池。        executorService.shutdown();    &#125;    /**     * 线程休眠的方法     */    private static void processTask() &#123;        try &#123;            long start = System.currentTimeMillis();            TimeUnit.SECONDS.sleep(random.nextInt(5));            long end = System.currentTimeMillis();            System.out.println(String.format(&quot;【%s】线程执行结束，耗时【%s】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, Thread.currentThread().getName(),((end - start)/1000)));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
执行结果：
【pool-1-thread-1】线程执行结束，耗时【1】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【2】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【4】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【2】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【3】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【1】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【1】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【4】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【pool-1-thread-1】线程执行结束，耗时【3】秒&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

SingleThreadExecutor 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：

如果当前运行的线程数少于 corePoolSize，则创建一个新的线程执行任务；
当前线程池中有一个运行的线程后，将任务加入 LinkedBlockingQueue
线程执行完当前的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十一)Java多线程之SingleThreadExecutor单线程化线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%BA%8C)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BWorkStealingPool%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池1.1 工作窃取线程池WorkStealingPool&emsp;&emsp; 在Java 8中，引入了一种新型的线程池，作为newWorkStealingPool()来补充现有的线程池。WorkStealingPool线程池，来维持相应的并行级别，它会通过工作窃取的方式，使得多核的 CPU 不会闲置，总会有活着的线程让 CPU 去运行。
&emsp;&emsp;顾名思义，它基于  工作窃取算法，其中任务可以生成其他较小的任务，这些任务将添加到并行处理线程的队列中。如果一个线程完成了工作并且无事可做，则可以从另一线程的队列中“窃取”工作。通过源代码查看WorkStealingPool实现：
/** * Creates a work-stealing thread pool using all * &#123;@link Runtime#availableProcessors available processors&#125; * as its target parallelism level. * @return the newly created thread pool * @see #newWorkStealingPool(int) * @since 1.8 */public static ExecutorService newWorkStealingPool() &#123;    return new ForkJoinPool        (Runtime.getRuntime().availableProcessors(),         ForkJoinPool.defaultForkJoinWorkerThreadFactory,         null, true);&#125;/** * Creates a thread pool that maintains enough threads to support * the given parallelism level, and may use multiple queues to * reduce contention. The parallelism level corresponds to the * maximum number of threads actively engaged in, or available to * engage in, task processing. The actual number of threads may * grow and shrink dynamically. A work-stealing pool makes no * guarantees about the order in which submitted tasks are * executed. * * @param parallelism the targeted parallelism level * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code parallelism &lt;= 0&#125; * @since 1.8 */public static ExecutorService newWorkStealingPool(int parallelism) &#123;    return new ForkJoinPool        (parallelism,         ForkJoinPool.defaultForkJoinWorkerThreadFactory,         null, true);&#125;
在WorkStealingPool实现中：

parallelism &#x3D;&gt; Runtime.getRuntime().availableProcessors() - 这是JVM可用的处理器数。
handler &#x3D;&gt; ForkJoinPool.defaultForkJoinWorkerThreadFactory - 返回新线程的默认线程工厂。
asyncMode &#x3D;&gt; true – 使其在aysnc模式下工作，并为分叉的任务设置FIFO顺序，这些任务永远不会从其工作队列中加入。


1.2 WorkStealingPool使用样例
单线程化线程池WorkStealingPool特点：
WorkStealingPool是守护线程，使用ForkJoinPool实现的WorkStealingPool根据当前操作系统的CPU有几个核就会创建几个线程。
应用场景：WorkStealingPool能够合理的使用CPU进行对任务操作（并行操作）适合使用在很耗时的操作。



package com.yuanxw.chapter22;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.stream.Collectors;import java.util.stream.IntStream;/** * 使用WorkStealingPool工作窃取线程池，创建Callable类型的多线程，并最终返回结果 * https://blog.csdn.net/yuan_xw/article/details/103730628 */public class WorkStealingPoolExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        System.out.println(&quot;获得JAVA虚拟机可用的最大CPU处理器数量：&quot; + Runtime.getRuntime().availableProcessors());        ExecutorService executorService = Executors.newWorkStealingPool();        /**         * call方法存在返回值futureTask的get方法可以获取这个返回值。         * 使用此种方法实现线程的好处是当你创建的任务的结果不是立即就要时，         * 你可以提交一个线程在后台执行，而你的程序仍可以正常运行下去，         * 在需要执行结果时使用futureTask去获取即可。         */        List&lt;Callable&lt;String&gt;&gt; callableList = IntStream.range(0, 20).boxed().map(i -&gt; (Callable&lt;String&gt;) () -&gt; &#123;            TimeUnit.SECONDS.sleep(3);            System.out.println(String.format(&quot;当前【%s】线程正在执行&gt;&gt;&gt;&quot;, Thread.currentThread().getName()));            return &quot;callable type thread task：&quot; + i;        &#125;).collect(Collectors.toList());        // 执行给定的任务，返回持有他们的状态和结果的所有完成的期待列表。        executorService.invokeAll(callableList).stream().map(futureTask-&gt; &#123;            try &#123;                return futureTask.get();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; catch (ExecutionException e) &#123;                e.printStackTrace();            &#125;            return null;        &#125;).forEach(System.out::println);    &#125;&#125;
执行结果：
获得JAVA虚拟机可用的最大CPU处理器数量：8当前【ForkJoinPool-1-worker-0】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-6】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-1】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-3】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-5】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-7】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-2】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-4】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-1】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-3】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-2】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-5】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-6】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-0】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-7】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-4】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-1】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-2】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-5】线程正在执行&gt;&gt;&gt;当前【ForkJoinPool-1-worker-3】线程正在执行&gt;&gt;&gt;callable type thread task：0callable type thread task：1callable type thread task：2callable type thread task：3callable type thread task：4callable type thread task：5callable type thread task：6callable type thread task：7callable type thread task：8callable type thread task：9callable type thread task：10callable type thread task：11callable type thread task：12callable type thread task：13callable type thread task：14callable type thread task：15callable type thread task：16callable type thread task：17callable type thread task：18callable type thread task：19



 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十二)Java多线程之WorkStealingPool工作窃取线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E4%BA%94)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BArrayBlockingQueue%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[1.JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器1.1 什么是 BlockingQueue&emsp;&emsp;阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。
BlockingQueue 和 ArrayBlockingQueue 之间的关系：&emsp;&emsp;BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 继承结构关系图：
1.2 ArrayBlockingQueue 有界的阻塞队列&emsp;&emsp;ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。
ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。通过源代码查看 ArrayBlockingQueue 实现：
/** * 创建具有给定（固定）容量和默认访问策略的 ArrayBlockingQueue 。 * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed) * capacity and default access policy. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125; */public ArrayBlockingQueue(int capacity) &#123;    this(capacity, false);&#125;/** * 创建一个 ArrayBlockingQueue具有给定（固定）容量和指定访问策略。 * 如果true然后对插入或删除阻塞的线程进行队列访问，则按FIFO顺序处理; 如果false访问顺序未指定。 * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed) * capacity and the specified access policy. * * @param capacity the capacity of this queue * @param fair if &#123;@code true&#125; then queue accesses for threads blocked *        on insertion or removal, are processed in FIFO order; *        if &#123;@code false&#125; the access order is unspecified. * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125; */public ArrayBlockingQueue(int capacity, boolean fair) &#123;    if (capacity &lt;= 0)        throw new IllegalArgumentException();    this.items = new Object[capacity];    lock = new ReentrantLock(fair);    notEmpty = lock.newCondition();    notFull =  lock.newCondition();&#125;/** * 创建一个 ArrayBlockingQueue具有给定（固定）容量，指定访问策略和最初包含给定集合中的元素，添加在收集* 迭代器的遍历顺序。 * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed) * capacity, the specified access policy and initially containing the * elements of the given collection, * added in traversal order of the collection&#x27;s iterator. * * @param capacity the capacity of this queue * @param fair if &#123;@code true&#125; then queue accesses for threads blocked *        on insertion or removal, are processed in FIFO order; *        if &#123;@code false&#125; the access order is unspecified. * @param c the collection of elements to initially contain * @throws IllegalArgumentException if &#123;@code capacity&#125; is less than *         &#123;@code c.size()&#125;, or less than 1. * @throws NullPointerException if the specified collection or any *         of its elements are null */public ArrayBlockingQueue(int capacity, boolean fair,                          Collection&lt;? extends E&gt; c) &#123;    this(capacity, fair);    final ReentrantLock lock = this.lock;    lock.lock(); // Lock only for visibility, not mutual exclusion    try &#123;        int i = 0;        try &#123;            for (E e : c) &#123;                checkNotNull(e);                items[i++] = e;            &#125;        &#125; catch (ArrayIndexOutOfBoundsException ex) &#123;            throw new IllegalArgumentException();        &#125;        count = i;        putIndex = (i == capacity) ? 0 : i;    &#125; finally &#123;        lock.unlock();    &#125;&#125;

1.3 ArrayBlockingQueue 有界的阻塞队列特点
ArrayBlockingQueue 是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。
ArrayBlockingQueue 是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改。

1.4 常用的方法package com.yuanxw.thread.chapter25;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class ArrayBlockingQueueExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        // add();        // offer();        // put();        // poll();        // peek();        // element();        remove();    &#125;    /**     * 如果可以在不超过队列的容量的情况下立即将其指定的元素插入到该队列的尾部，     * 如果队列已满，则返回 true并抛出 IllegalStateException 。     * 执行结果：     *     =====执行add()签名方法-开始=====     *     arrayBlockingQueue.add()执行返回结果：true     *     arrayBlockingQueue.add()执行返回结果：true     *     arrayBlockingQueue.add()执行返回结果：true     *     Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full     *     at java.util.AbstractQueue.add(AbstractQueue.java:98)     *     at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)     *     at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.add(ArrayBlockingQueueExample.java:28)     *     at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.main(ArrayBlockingQueueExample.java:7)     */    public static void add() &#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        System.out.println(&quot;arrayBlockingQueue.add()执行返回结果：&quot;+arrayBlockingQueue.add(&quot;Message 1&quot;));        System.out.println(&quot;arrayBlockingQueue.add()执行返回结果：&quot;+arrayBlockingQueue.add(&quot;Message 2&quot;));        System.out.println(&quot;arrayBlockingQueue.add()执行返回结果：&quot;+arrayBlockingQueue.add(&quot;Message 3&quot;));        System.out.println(&quot;arrayBlockingQueue.add()执行返回结果：&quot;+arrayBlockingQueue.add(&quot;Message 4&quot;));        System.out.println(&quot;=====执行add()签名方法-结束=====&quot;);    &#125;    /**      * 如果可以在不超过队列容量的情况下立即将其指定的元素插入该队列的尾部，      * 则在成功时true如果该队列已满，则返回false 。      * 执行结果：      *  =====执行offer()签名方法-开始=====      *  arrayBlockingQueue.offer()执行返回结果：true      *  arrayBlockingQueue.offer()执行返回结果：true      *  arrayBlockingQueue.offer()执行返回结果：true      *  arrayBlockingQueue.offer()执行返回结果：false      *  =====执行offer()签名方法-结束=====      */    public static void offer()&#123;        System.out.println(&quot;=====执行offer()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        System.out.println(&quot;arrayBlockingQueue.offer()执行返回结果：&quot;+arrayBlockingQueue.offer(&quot;Message 1&quot;));        System.out.println(&quot;arrayBlockingQueue.offer()执行返回结果：&quot;+arrayBlockingQueue.offer(&quot;Message 2&quot;));        System.out.println(&quot;arrayBlockingQueue.offer()执行返回结果：&quot;+arrayBlockingQueue.offer(&quot;Message 3&quot;));        System.out.println(&quot;arrayBlockingQueue.offer()执行返回结果：&quot;+arrayBlockingQueue.offer(&quot;Message 4&quot;));        System.out.println(&quot;=====执行offer()签名方法-结束=====&quot;);    &#125;    /**      * 在该队列的尾部插入指定的元素，如果队列已满，则等待空间变为可用。      *  执行结果：      *   =====执行put()签名方法-开始=====      *   当前arrayBlockingQueue对象中的个数：3      *   当前arrayBlockingQueue对象中的容量：0      *   当前arrayBlockingQueue对象中take()数据值为：Message 1      *   Message 2      *   Message 3      *   Message 4      *   =====执行put()签名方法-结束=====     */    public static void put() throws InterruptedException &#123;        System.out.println(&quot;=====执行put()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        Executors.newSingleThreadExecutor().execute(()-&gt;&#123;            System.out.println(&quot;当前arrayBlockingQueue对象中的个数：&quot; + arrayBlockingQueue.size());            System.out.println(&quot;当前arrayBlockingQueue对象中的容量：&quot; + arrayBlockingQueue.remainingCapacity());            try &#123;                TimeUnit.SECONDS.sleep(5);                // 检索并删除此队列的头                Object take = arrayBlockingQueue.take();                System.out.println(&quot;当前arrayBlockingQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        arrayBlockingQueue.put(&quot;Message 4&quot;);        arrayBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行put()签名方法-结束=====&quot;);    &#125;    /**      * 检索并删除此队列的头，则等待空间变为可用。      *  执行结果：      *   =====执行poll()签名方法-开始=====      *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】      *   当前arrayBlockingQueue对象中poll()数据值为：Message 1      *   当前arrayBlockingQueue对象中poll()数据值为：Message 2      *   当前arrayBlockingQueue对象中的个数：【1】,容量：【2】      *   当前arrayBlockingQueue对象中poll()数据值为：Message 3      *   当前arrayBlockingQueue对象中poll()数据值为：null      *   当前arrayBlockingQueue对象中poll()数据值为：null      *   =====执行poll()签名方法-结束=====     */    public static void poll() throws InterruptedException &#123;        System.out.println(&quot;=====执行poll()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(&quot;当前arrayBlockingQueue对象中poll()数据值为：&quot; + arrayBlockingQueue.poll());        System.out.println(&quot;=====执行poll()签名方法-结束=====&quot;);    &#125;    /**      * 检索但不删除此队列的头，如果此队列为空，则返回 null。      *  执行结果：      *   =====执行peek()签名方法-开始=====      *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   当前arrayBlockingQueue对象中peek()数据值为：Message 1      *   =====执行peek()签名方法-结束=====     */    public static void peek() throws InterruptedException &#123;        System.out.println(&quot;=====执行peek()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(&quot;当前arrayBlockingQueue对象中peek()数据值为：&quot; + arrayBlockingQueue.peek());        System.out.println(&quot;=====执行peek()签名方法-结束=====&quot;);    &#125;    /**     * 检索，但不删除，这个队列的头。 此方法与peek的不同之处在于，如果此队列为空，它将抛出异常。     *  执行结果：     *   =====执行element()签名方法-开始=====     *   当前arrayBlockingQueue对象中的个数：【3】,容量：【0】     *   当前arrayBlockingQueue对象中take()数据值为：Message 1     *   当前arrayBlockingQueue对象中take()数据值为：Message 2     *   当前arrayBlockingQueue对象中take()数据值为：Message 3     *   当前arrayBlockingQueue对象中的个数：【0】,容量：【3】     *   Exception in thread &quot;main&quot; java.util.NoSuchElementException     *   at java.util.AbstractQueue.element(AbstractQueue.java:136)     *   at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.element(ArrayBlockingQueueExample.java:182)     *   at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.main(ArrayBlockingQueueExample.java:14)     */    public static void element() throws InterruptedException &#123;        System.out.println(&quot;=====执行element()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中take()数据值为：&quot; + arrayBlockingQueue.take());        System.out.println(&quot;当前arrayBlockingQueue对象中take()数据值为：&quot; + arrayBlockingQueue.take());        System.out.println(&quot;当前arrayBlockingQueue对象中take()数据值为：&quot; + arrayBlockingQueue.take());        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中element()数据值为：&quot; + arrayBlockingQueue.element());        System.out.println(&quot;=====执行element()签名方法-结束=====&quot;);    &#125;    /**      * 检索并删除此队列的头。 此方法与poll不同之处在于，如果此队列为空，它将抛出异常。      * 执行结果：      * =====执行remove()签名方法-开始=====      * 当前arrayBlockingQueue对象中的个数：【3】,容量：【0】      * 当前arrayBlockingQueue对象中remove()数据值为：Message 1      * 当前arrayBlockingQueue对象中remove()数据值为：Message 2      * 当前arrayBlockingQueue对象中remove()数据值为：Message 3      * Exception in thread &quot;main&quot; java.util.NoSuchElementException      * at java.util.AbstractQueue.remove(AbstractQueue.java:117)      * at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.remove(ArrayBlockingQueueExample.java:212)      * at com.yuanxw.thread.chapter25.ArrayBlockingQueueExample.main(ArrayBlockingQueueExample.java:15)     */    public static void remove() throws InterruptedException &#123;        System.out.println(&quot;=====执行remove()签名方法-开始=====&quot;);        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(3);        arrayBlockingQueue.put(&quot;Message 1&quot;);        arrayBlockingQueue.put(&quot;Message 2&quot;);        arrayBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot; + arrayBlockingQueue.remove());        System.out.println(&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot; + arrayBlockingQueue.remove());        System.out.println(&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot; + arrayBlockingQueue.remove());        System.out.println(&quot;当前arrayBlockingQueue对象中remove()数据值为：&quot; + arrayBlockingQueue.remove());        System.out.println(String.format(&quot;当前arrayBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, arrayBlockingQueue.size(),arrayBlockingQueue.remainingCapacity()));        System.out.println(&quot;=====执行remove()签名方法-结束=====&quot;);    &#125;&#125;

&emsp;&emsp;&emsp;&emsp;– 以上为《JAVA 多线程(二十五)Java 多线程之 ArrayBlockingQueue 容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。
  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十八)Java多线程之SynchronousQueue容器</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%85%AB)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSynchronousQue/</url>
    <content><![CDATA[1.JAVA多线程(二十八)Java多线程之SynchronousQueue容器1.1 什么是SynchronousQueue&emsp;&emsp;Java 6的并发编程包中的SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。
不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的线程，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。
SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。
下面是 SynchronousQueue继承结构关系图：

通过源代码查看SynchronousQueue实现：
/** * 创建一个 SynchronousQueue非公平策略。  * Creates a &#123;@code SynchronousQueue&#125; with nonfair access policy. */public SynchronousQueue() &#123;    this(false);&#125;/** * 创建一个 SynchronousQueue非公平策略。 如果fair参数：true，等待线程在FIFO顺序中进行访问;  * Creates a &#123;@code SynchronousQueue&#125; with the specified fairness policy. * * @param fair if true, waiting threads contend in FIFO order for *        access; otherwise the order is unspecified. */public SynchronousQueue(boolean fair) &#123;    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();&#125;
1.2 SynchronousQueue队列特点
SynchronousQueue没有容量。与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。

因为没有容量，所以对应的peek、contains、clear、isEmpty…..等方法其实是无效的。例如clear是不执行任何操作的，contains始终返回false，peek始终返回null。

SynchronousQueue分为公平和非公平，默认情况下采用非公平性访问策略，当然也可以通过构造函数来设置为公平性访问策略（为true即可）。

SynchronousQueue内部采用了无锁实现（CAS）。


1.3 常用的方法package com.yuanxw.thread.chapter28;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;public class SynchronousQueueExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        // add();        // addAndTake();        // offer();        put();    &#125;    /**     如果可以在不超过队列的容量的情况下立即将其指定的元素插入到该队列中，     如果队列已满，则返回 true并抛出 IllegalStateException 。     执行结果：         =====执行add()签名方法-开始=====         Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full         at java.util.AbstractQueue.add(AbstractQueue.java:98)         at com.yuanxw.thread.chapter28.SynchronousQueueExample.add(SynchronousQueueExample.java:16)         at com.yuanxw.thread.chapter28.SynchronousQueueExample.main(SynchronousQueueExample.java:10)     */    public static void add() throws InterruptedException &#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        SynchronousQueue synchronousQueue = new SynchronousQueue();        synchronousQueue.add(&quot;Message 1&quot;);        System.out.println(&quot;=====执行add()签名方法-结束=====&quot;);    &#125;    public static void addAndTake() throws InterruptedException &#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        SynchronousQueue synchronousQueue = new SynchronousQueue();        ExecutorService executorService = Executors.newSingleThreadExecutor();        executorService.execute(()-&gt;&#123;            try &#123;                System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, synchronousQueue.size(),synchronousQueue.remainingCapacity()));                Object take = synchronousQueue.take();                System.out.println(&quot;当前synchronousQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        TimeUnit.SECONDS.sleep(3);        System.out.println(&quot;synchronousQueue.add()执行返回结果：&quot;+synchronousQueue.add(&quot;Message 1&quot;));        executorService.shutdown();        System.out.println(&quot;=====执行add()签名方法-结束=====&quot;);    &#125;    /**     如果另一个线程正在等待接收，则将指定的元素插入到此队列中。     true如果元素被添加到这个队列，否则 false     执行结果：         =====执行offer()签名方法-开始=====         synchronousQueue.offer()执行返回结果：false         ------------------------------------         synchronousQueue.offer()执行返回结果：true         当前synchronousQueue对象中take()数据值为：Message 2         =====执行offer()签名方法-结束=====     */    public static void offer() throws InterruptedException &#123;        System.out.println(&quot;=====执行offer()签名方法-开始=====&quot;);        SynchronousQueue synchronousQueue = new SynchronousQueue();        System.out.println(&quot;synchronousQueue.offer()执行返回结果：&quot;+synchronousQueue.offer(&quot;Message 1&quot;));        System.out.println(&quot;------------------------------------&quot;);        ExecutorService executorService = Executors.newSingleThreadExecutor();        executorService.execute(()-&gt;&#123;            try &#123;                Object take = synchronousQueue.take();                System.out.println(&quot;当前synchronousQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        TimeUnit.SECONDS.sleep(3);        System.out.println(&quot;synchronousQueue.offer()执行返回结果：&quot;+synchronousQueue.offer(&quot;Message 2&quot;));        executorService.shutdown();        System.out.println(&quot;=====执行offer()签名方法-结束=====&quot;);    &#125;    /**     * 将指定的元素添加到此队列，等待另一个线程接收它。     执行结果：         =====执行put()签名方法-开始=====         当前synchronousQueue对象中take()数据值为：Message 1         =====执行put()签名方法-结束=====     */    public static void put() throws InterruptedException &#123;        System.out.println(&quot;=====执行put()签名方法-开始=====&quot;);        SynchronousQueue synchronousQueue = new SynchronousQueue();        ExecutorService executorService = Executors.newSingleThreadExecutor();        executorService.execute(()-&gt;&#123;            try &#123;                TimeUnit.SECONDS.sleep(2);                // 检索并删除此队列的头                Object take = synchronousQueue.take();                System.out.println(&quot;当前synchronousQueue对象中take()数据值为：&quot; + take);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        // put方法会阻塞，直到有一个线程获取。        synchronousQueue.put(&quot;Message 1&quot;);        executorService.shutdown();        System.out.println(&quot;=====执行put()签名方法-结束=====&quot;);    &#125;&#125;
1.4 应用场景 &emsp;&emsp;可缓存线程池CachedThreadPool的源码实现，使用SynchronousQueue作为工作队列，工作队列本身并不限制待执行的任务的数量。但此时需要限定线程池的最大大小为一个合理的有限值，而不是Integer.MAX_VALUE，否则可能导致线程池中的工作者线程的数量一直增加到系统资源所无法承受为止。如果应用程序确实需要比较大的工作队列容量，而又想避免无界工作队列可能导致的问题，不妨考虑SynchronousQueue。SynchronousQueue实现上并不使用缓存空间。使用SynchronousQueue的目的就是保证“对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务”。JAVA多线程(十九)Java多线程之CachedThreadPool可缓存线程池。
&emsp;&emsp;可缓存线程池CachedThreadPool源代码实现：
/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available.  These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */public static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());&#125;



 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十八)Java多线程之SynchronousQueue容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%85%AD)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BPriorityBlockingQueue%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[1.JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器1.1 什么是PriorityBlockingQueue&emsp;&emsp;PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。
PriorityBlockingQueue 并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。
下面是 PriorityBlockingQueue继承结构关系图：
1.2 PriorityBlockingQueue无界阻塞队列&emsp;&emsp;简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。通过源代码查看PriorityBlockingQueue实现：
/** * 创建一个PriorityBlockingQueue ，具有默认的初始容量（11），根据它们的Comparable对其元素进行排序 。  * * Creates a &#123;@code PriorityBlockingQueue&#125; with the default * initial capacity (11) that orders its elements according to * their &#123;@linkplain Comparable natural ordering&#125;. */public PriorityBlockingQueue() &#123;    this(DEFAULT_INITIAL_CAPACITY, null);&#125;/** * 创建一个PriorityBlockingQueue ，指定容量大小，根据它们的Comparable对其元素进行排序 。  * * Creates a &#123;@code PriorityBlockingQueue&#125; with the specified * initial capacity that orders its elements according to their * &#123;@linkplain Comparable natural ordering&#125;. * * @param initialCapacity the initial capacity for this priority queue * @throws IllegalArgumentException if &#123;@code initialCapacity&#125; is less *         than 1 */public PriorityBlockingQueue(int initialCapacity) &#123;    this(initialCapacity, null);&#125;/** * 创建具有 PriorityBlockingQueue初始容量的PriorityBlockingQueue，根据指定的比较器对其元素进行排序。  * * Creates a &#123;@code PriorityBlockingQueue&#125; with the specified initial * capacity that orders its elements according to the specified * comparator. * * @param initialCapacity the initial capacity for this priority queue * @param  comparator the comparator that will be used to order this *         priority queue.  If &#123;@code null&#125;, the &#123;@linkplain Comparable *         natural ordering&#125; of the elements will be used. * @throws IllegalArgumentException if &#123;@code initialCapacity&#125; is less *         than 1 */public PriorityBlockingQueue(int initialCapacity,                             Comparator&lt;? super E&gt; comparator) &#123;    if (initialCapacity &lt; 1)        throw new IllegalArgumentException();    this.lock = new ReentrantLock();    this.notEmpty = lock.newCondition();    this.comparator = comparator;    this.queue = new Object[initialCapacity];&#125;/** * 创建一个 PriorityBlockingQueue集合中的元素的PriorityBlockingQueue。  * 在指定的集合中。如果指定的集合是 &#123;@link SortedSet&#125;或&#123;@link PriorityQueue&#125;， * 这个优先队列将按照相同的顺序排序。否则，此优先队列将根据&#123;@linkplain可比较的自然排序&#125;。 * * Creates a &#123;@code PriorityBlockingQueue&#125; containing the elements * in the specified collection.  If the specified collection is a * &#123;@link SortedSet&#125; or a &#123;@link PriorityQueue&#125;, this * priority queue will be ordered according to the same ordering. * Otherwise, this priority queue will be ordered according to the * &#123;@linkplain Comparable natural ordering&#125; of its elements. * * @param  c the collection whose elements are to be placed *         into this priority queue * @throws ClassCastException if elements of the specified collection *         cannot be compared to one another according to the priority *         queue&#x27;s ordering * @throws NullPointerException if the specified collection or any *         of its elements are null */public PriorityBlockingQueue(Collection&lt;? extends E&gt; c) &#123;    this.lock = new ReentrantLock();    this.notEmpty = lock.newCondition();    boolean heapify = true; // true if not known to be in heap order    boolean screen = true;  // true if must screen for nulls    if (c instanceof SortedSet&lt;?&gt;) &#123;        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;        this.comparator = (Comparator&lt;? super E&gt;) ss.comparator();        heapify = false;    &#125;    else if (c instanceof PriorityBlockingQueue&lt;?&gt;) &#123;        PriorityBlockingQueue&lt;? extends E&gt; pq =            (PriorityBlockingQueue&lt;? extends E&gt;) c;        this.comparator = (Comparator&lt;? super E&gt;) pq.comparator();        screen = false;        if (pq.getClass() == PriorityBlockingQueue.class) // exact match            heapify = false;    &#125;    Object[] a = c.toArray();    int n = a.length;    // If c.toArray incorrectly doesn&#x27;t return Object[], copy it.    if (a.getClass() != Object[].class)        a = Arrays.copyOf(a, n, Object[].class);    if (screen &amp;&amp; (n == 1 || this.comparator != null)) &#123;        for (int i = 0; i &lt; n; ++i)            if (a[i] == null)                throw new NullPointerException();    &#125;    this.queue = a;    this.size = n;    if (heapify)        heapify();&#125;
1.3 PriorityBlockingQueue无界阻塞队列特点
PriorityBlockingQueue无界队列，只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容。
PriorityBlockingQueue不可以插入 null 值。
插入队列的对象必须是可比较大小的（comparable）。

1.4 常用的方法package com.yuanxw.thread.chapter26;import java.util.concurrent.PriorityBlockingQueue;public class PriorityBlockingQueueExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        // add();        // poll();        // peek();        // element();        // remove();        // addNoComparable();        addWithNull();            &#125;    /**     * PriorityBlockingQueue     * 将指定的元素插入到此优先级队列中。 由于队列无限制，此方法将永远不会返回false 。     * add()方法、put()方法，都调用用offer()方法。     执行结果：         =====执行add()签名方法-开始=====         Message 1         Message 2         Message 3         =====执行add()签名方法-开始=====     */    public static void add()&#123;        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);        // 创建一个PriorityBlockingQueue ，具有指定的初始容量，根据它们的natural ordering对其元素进行排序 。        // 超过容量之后会自动扩容        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(2);        priorityBlockingQueue.add(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.offer(&quot;Message 3&quot;);        priorityBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行add()签名方法-开始=====&quot;);    &#125;    /**     * 检索并删除此队列的头，则等待空间变为可用。     =====执行poll()签名方法-开始=====     执行结果：         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中poll()数据值为：Message 1         当前priorityBlockingQueue对象中poll()数据值为：Message 2         当前priorityBlockingQueue对象中的个数：【1】,容量：【2147483647】         当前priorityBlockingQueue对象中poll()数据值为：Message 3         当前priorityBlockingQueue对象中poll()数据值为：null         当前priorityBlockingQueue对象中poll()数据值为：null     =====执行poll()签名方法-结束=====     */    public static void poll() &#123;        System.out.println(&quot;=====执行poll()签名方法-开始=====&quot;);        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(2);        priorityBlockingQueue.put(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(&quot;当前priorityBlockingQueue对象中poll()数据值为：&quot; + priorityBlockingQueue.poll());        System.out.println(&quot;=====执行poll()签名方法-结束=====&quot;);    &#125;    /**     * 检索但不删除此队列的头，如果此队列为空，则返回 null。     执行结果：         =====执行peek()签名方法-开始=====         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中peek()数据值为：Message 1         当前priorityBlockingQueue对象中peek()数据值为：Message 1         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中peek()数据值为：Message 1         当前priorityBlockingQueue对象中peek()数据值为：Message 1         当前priorityBlockingQueue对象中peek()数据值为：Message 1         =====执行peek()签名方法-结束=====     */    public static void peek()  &#123;        System.out.println(&quot;=====执行peek()签名方法-开始=====&quot;);        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(2);        priorityBlockingQueue.put(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(&quot;当前priorityBlockingQueue对象中peek()数据值为：&quot; + priorityBlockingQueue.peek());        System.out.println(&quot;=====执行peek()签名方法-结束=====&quot;);    &#125;    /**     * 检索，但不删除，这个队列的头。 此方法与peek的不同之处在于，如果此队列为空，它将抛出异常。     执行结果：         =====执行element()签名方法-开始=====         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中take()数据值为：Message 1         当前priorityBlockingQueue对象中take()数据值为：Message 2         当前priorityBlockingQueue对象中take()数据值为：Message 3         当前priorityBlockingQueue对象中的个数：【0】,容量：【2147483647】         Exception in thread &quot;main&quot; java.util.NoSuchElementException         at java.util.AbstractQueue.element(AbstractQueue.java:136)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.element(PriorityBlockingQueueExample.java:123)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:11)     */    public static void element() throws InterruptedException &#123;        System.out.println(&quot;=====执行element()签名方法-开始=====&quot;);        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(3);        priorityBlockingQueue.put(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中take()数据值为：&quot; + priorityBlockingQueue.take());        System.out.println(&quot;当前priorityBlockingQueue对象中take()数据值为：&quot; + priorityBlockingQueue.take());        System.out.println(&quot;当前priorityBlockingQueue对象中take()数据值为：&quot; + priorityBlockingQueue.take());        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中element()数据值为：&quot; + priorityBlockingQueue.element());        System.out.println(&quot;=====执行element()签名方法-结束=====&quot;);    &#125;    /**     * 检索并删除此队列的头。 此方法与poll不同之处在于，如果此队列为空，它将抛出异常。     执行结果：         =====执行remove()签名方法-开始=====         当前priorityBlockingQueue对象中的个数：【3】,容量：【2147483647】         当前priorityBlockingQueue对象中remove()数据值为：Message 1         当前priorityBlockingQueue对象中remove()数据值为：Message 2         当前priorityBlockingQueue对象中remove()数据值为：Message 3         Exception in thread &quot;main&quot; java.util.NoSuchElementException         at java.util.AbstractQueue.remove(AbstractQueue.java:117)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.remove(PriorityBlockingQueueExample.java:151)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:12)     */    public static void remove() &#123;        System.out.println(&quot;=====执行remove()签名方法-开始=====&quot;);        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue(3);        priorityBlockingQueue.put(&quot;Message 1&quot;);        priorityBlockingQueue.put(&quot;Message 2&quot;);        priorityBlockingQueue.put(&quot;Message 3&quot;);        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot; + priorityBlockingQueue.remove());        System.out.println(&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot; + priorityBlockingQueue.remove());        System.out.println(&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot; + priorityBlockingQueue.remove());        System.out.println(&quot;当前priorityBlockingQueue对象中remove()数据值为：&quot; + priorityBlockingQueue.remove());        System.out.println(String.format(&quot;当前priorityBlockingQueue对象中的个数：【%s】,容量：【%s】&quot;, priorityBlockingQueue.size(),priorityBlockingQueue.remainingCapacity()));        System.out.println(&quot;=====执行remove()签名方法-结束=====&quot;);    &#125;    /**     * 验证：     * 添加元素时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。     执行结果：         =====执行addNoComparable()签名方法-开始=====         Exception in thread &quot;main&quot; java.lang.ClassCastException: com.yuanxw.thread.chapter26.PriorityBlockingQueueExample$Order cannot be cast to java.lang.Comparable         at java.util.concurrent.PriorityBlockingQueue.siftUpComparable(PriorityBlockingQueue.java:358)         at java.util.concurrent.PriorityBlockingQueue.offer(PriorityBlockingQueue.java:490)         at java.util.concurrent.PriorityBlockingQueue.add(PriorityBlockingQueue.java:464)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.addNoComparable(PriorityBlockingQueueExample.java:166)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:12)     */    public static void addNoComparable()&#123;        System.out.println(&quot;=====执行addNoComparable()签名方法-开始=====&quot;);        // 默认长度为：11        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue();        priorityBlockingQueue.add(new Order());        priorityBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行addNoComparable()签名方法-结束=====&quot;);    &#125;    /**     * 验证：     * 添加元素时，插入队列的对象是null，报 NullPointerException 异常。     执行结果：         =====执行addWithNull()签名方法-开始=====         Exception in thread &quot;main&quot; java.lang.NullPointerException         at java.util.concurrent.PriorityBlockingQueue.offer(PriorityBlockingQueue.java:480)         at java.util.concurrent.PriorityBlockingQueue.add(PriorityBlockingQueue.java:464)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.addWithNull(PriorityBlockingQueueExample.java:194)         at com.yuanxw.thread.chapter26.PriorityBlockingQueueExample.main(PriorityBlockingQueueExample.java:13)     */    public static void addWithNull()&#123;        System.out.println(&quot;=====执行addWithNull()签名方法-开始=====&quot;);        // 默认长度为：11        PriorityBlockingQueue priorityBlockingQueue = new PriorityBlockingQueue();        priorityBlockingQueue.add(null);        priorityBlockingQueue.forEach(System.out::println);        System.out.println(&quot;=====执行addWithNull()签名方法-结束=====&quot;);    &#125;    private static class Order&#123;&#125;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十六)Java多线程之PriorityBlockingQueue容器》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(二十四)Java多线程之CompletableFuture类</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C%E5%8D%81%E5%9B%9B)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCompletableFuture%E7%B1%BB/</url>
    <content><![CDATA[1.JAVA多线程(二十四)Java多线程之CompletableFuture类1.1 什么是Future&emsp;&emsp;Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。
package com.yuanxw.chapter24;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.ThreadLocalRandom;import java.util.concurrent.TimeUnit;public class FutureExample &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        // 构造一个线程池        ExecutorService executorService = Executors.newCachedThreadPool();        // 提交线程任务        Future&lt;Integer&gt; future = executorService.submit(() -&gt; &#123;            try &#123;                System.out.println(String.format(&quot;当前【%s】线程工作-开始...&quot;, Thread.currentThread().getName()));                TimeUnit.SECONDS.sleep(10);                System.out.println(String.format(&quot;当前【%s】线程工作-结束...&quot;, Thread.currentThread().getName()));                return ThreadLocalRandom.current().nextInt(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();                return -1;            &#125;        &#125;);        System.out.println(String.format(&quot;【%s】在等待线程执行结果...&quot;, Thread.currentThread().getName()));        System.out.println(&quot;是否执行结束：&quot;+future.isDone());        System.out.println(future.get());        System.out.println(&quot;是否执行结束：&quot;+future.isDone());    &#125;&#125;
执行结果：
当前【pool-1-thread-1】线程工作-开始...【main】在等待线程执行结果...是否执行结束：false当前【pool-1-thread-1】线程工作-结束...76是否执行结束：true
1.2 Future的局限性&emsp;&emsp;虽然Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果。CompletableFuture的出现解决了Future模式的缺点。

不能手动完成：
当你写了一个函数，用于通过一个远程API获取一个电子商务产品最新价格。因为这个 API 太耗时，你把它允许在一个独立的线程中，并且从你的函数中返回一个 Future。现在假设这个API服务宕机了，这时你想通过该产品的最新缓存价格手工完成这个Future 。你会发现无法这样做。


Future的结果在非阻塞的情况下，不能执行更进一步的操作：
Future 不会通知你它已经完成了，它提供了一个阻塞的 get() 方法通知你结果。你无法给 Future 植入一个回调函数，当 Future 结果可用的时候，用该回调函数自动的调用 Future 的结果。


多个Future不能串联在一起组成链式调用：
有时候你需要执行一个长时间运行的计算任务，并且当计算任务完成的时候，你需要把它的计算结果发送给另外一个长时间运行的计算任务等等。你会发现你无法使用 Future 创建这样的一个工作流。  不能组合多个 Future 的结果  假设你有10个不同的Future，你想并行的运行，然后在它们运行未完成后运行一些函数。你会发现你也无法使用 Future 这样做。


没有异常处理：
Future API 没有任务的异常处理结构居然有如此多的限制，幸好我们有CompletableFuture，你可以使用 CompletableFuture 达到以上所有目的。



1.3 什么是CompletableFuture&emsp;&emsp; 在Java中CompletableFuture用于异步编程，异步编程是编写非阻塞的代码，运行的任务在一个单独的线程，与主线程隔离，并且会通知主线程它的进度，成功或者失败。在这种方式中，主线程不会被阻塞，不需要一直等到子线程完成。主线程可以并行的执行其他任务。使用这种并行方式，可以极大的提高程序的性能。&emsp;&emsp; CompletableFuture 实现了 Future 和 CompletionStage接口，并且提供了许多关于创建，链式调用和组合多个 Future 的便利方法集，而且有广泛的异常处理支持。&emsp;&emsp; CompletableFuture和Java8的Stream搭配使用，使用对于一些并行访问的耗时操作有很大的操作。
CompletableFuture继承结构关系图：
CompletableFuture类实现了CompletionStage和Future接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。
1.4 CompletableFuture方法分类1.4.1. 创建CompletableFuture对象&emsp;&emsp;以Async结尾并且没有指定Executor的方法会使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。runAsync方法也好理解，它以Runnable函数式接口类型为参数，所以CompletableFuture的计算结果为空。supplyAsync方法以Supplier&lt;U&gt;函数式接口类型为参数,CompletableFuture的计算结果类型为U。CompletableFuture的静态工厂方法：



方法名
描述



runAsync(Runnable runnable)
使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。


runAsync(Runnable runnable, Executor executor)
使用指定的thread pool执行异步代码。


supplyAsync(Supplier supplier)
使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值。


supplyAsync(Supplier supplier, Executor executor)
使用指定的thread pool执行异步代码，异步操作有返回值。



CompletableFuture.completedFuture是一个静态辅助方法，用来返回一个已经计算好的CompletableFuture。

/** * Returns a new CompletableFuture that is already completed with * the given value. * * @param value the value * @param &lt;U&gt; the type of the value * @return the completed CompletableFuture */public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value) &#123;    return new CompletableFuture&lt;U&gt;((value == null) ? NIL : value);&#125;


而以下四个静态方法用来为一段异步执行的代码创建CompletableFuture对象：

/** * Returns a new CompletableFuture that is asynchronously completed * by a task running in the &#123;@link ForkJoinPool#commonPool()&#125; with * the value obtained by calling the given Supplier. * * @param supplier a function returning the value to be used * to complete the returned CompletableFuture * @param &lt;U&gt; the function&#x27;s return type * @return the new CompletableFuture */public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) &#123;    return asyncSupplyStage(asyncPool, supplier);&#125;/** * Returns a new CompletableFuture that is asynchronously completed * by a task running in the given executor with the value obtained * by calling the given Supplier. * * @param supplier a function returning the value to be used * to complete the returned CompletableFuture * @param executor the executor to use for asynchronous execution * @param &lt;U&gt; the function&#x27;s return type * @return the new CompletableFuture */public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,Executor executor) &#123;    return asyncSupplyStage(screenExecutor(executor), supplier);&#125;/** * Returns a new CompletableFuture that is asynchronously completed * by a task running in the &#123;@link ForkJoinPool#commonPool()&#125; after * it runs the given action. * * @param runnable the action to run before completing the * returned CompletableFuture * @return the new CompletableFuture */public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) &#123;    return asyncRunStage(asyncPool, runnable);&#125;/** * Returns a new CompletableFuture that is asynchronously completed * by a task running in the given executor after it runs the given * action. * * @param runnable the action to run before completing the * returned CompletableFuture * @param executor the executor to use for asynchronous execution * @return the new CompletableFuture */public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,Executor executor) &#123;    return asyncRunStage(screenExecutor(executor), runnable);&#125;

1.4.2. 主动完成计算


方法名
描述



get()
方法同步等待结果。


get(timeout,unit)
get(timeout,unit)签名方法，给定时间，然后返回其结果，如果超时，抛出异常


join()
完成后返回结果值，如果完成异常，则返回（未检查）异常。


getNow()
如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.ThreadLocalRandom;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;public class CompletableFutureExample1 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        runAsync();        // get() 方法同步等待结果。        get();        // get(timeout,unit)签名方法，给定时间，然后返回其结果，如果超时，抛出异常        get(3,TimeUnit.SECONDS);        // join() 完成后返回结果值，如果完成异常，则返回（未检查）异常。        join();        // getNow() 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。        getNow();    &#125;    /**     * runAsync()异步执行runAsync返回的CompletableFuture是没有返回值的。     * supplyAsync()异步执行runAsync返回的CompletableFuture是有返回值的。     执行结果：     =====【main】执行runAsync()签名方法-开始=====     Hello world！！！     =====【main】执行runAsync()签名方法-结束=====     * @throws ExecutionException     * @throws InterruptedException     */    private static void runAsync() throws ExecutionException, InterruptedException &#123;        System.out.println(String.format(&quot;=====【%s】执行runAsync()签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Hello world！！！&quot;)).get();        System.out.println(String.format(&quot;=====【%s】执行runAsync()签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**     get() 方法同步等待结果。     执行结果：          =====【main】执行get()签名方法-开始=====          get()签名方法，执行结果：4          =====【main】执行get()签名方法-结束=====     * @throws ExecutionException     * @throws InterruptedException     */    private static void get() throws ExecutionException, InterruptedException &#123;        System.out.println(String.format(&quot;=====【%s】执行get()签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            return ThreadLocalRandom.current().nextInt(10) * 2;        &#125;);        /** get() 方法同步等待结果。 **/        System.out.println(&quot;get()签名方法，执行结果：&quot;+completableFuture.get());        System.out.println(String.format(&quot;=====【%s】执行get()签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**     get(timeout,unit)签名方法，给定时间，然后返回其结果，如果超时，抛出异常     执行结果：     =====【main】执行get(timeout,unit)签名方法-开始=====     java.util.concurrent.TimeoutException     	at java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1771)     	at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1915)     	at com.yuanxw.chapter24.CompletableFutureExample.get(CompletableFutureExample.java:53)     	at com.yuanxw.chapter24.CompletableFutureExample.main(CompletableFutureExample.java:11)     =====【main】执行get(timeout,unit)签名方法-结束=====     *     * @param timeout     * @param unit     * @throws ExecutionException     * @throws InterruptedException     */    private static void get(long timeout, TimeUnit unit) throws ExecutionException, InterruptedException &#123;        System.out.println(String.format(&quot;=====【%s】执行get(timeout,unit)签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            return ThreadLocalRandom.current().nextInt(10) * 2;        &#125;);        try &#123;            System.out.println(&quot;get(timeout,unit)签名方法，执行结果：&quot;+completableFuture.get(timeout,unit));        &#125; catch (TimeoutException e) &#123;            e.printStackTrace();        &#125;        System.out.println(String.format(&quot;=====【%s】执行get(timeout,unit)签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**      join() 完成后返回结果值，如果完成异常，则返回（未检查）异常。     执行结果：         =====【main】执行join()签名方法-开始=====         join()签名方法，执行结果：40         =====【main】执行join()签名方法-结束=====     * @throws ExecutionException     * @throws InterruptedException     */    private static void join() throws ExecutionException, InterruptedException &#123;        System.out.println(String.format(&quot;=====【%s】执行join()签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            return ThreadLocalRandom.current().nextInt(10) * 5;        &#125;);        /** join() 完成后返回结果值，如果完成异常，则返回（未检查）异常。 **/        System.out.println(&quot;join()签名方法，执行结果：&quot;+ completableFuture.join());        System.out.println(String.format(&quot;=====【%s】执行join()签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**     getNow() 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。     执行结果：      =====【main】执行getNow()签名方法-开始=====      getNow()签名方法，执行结果：===unknown===      getNow()签名方法，执行结果：N      =====【main】getNow()签名方法-结束=====     */    private static void getNow() &#123;        System.out.println(String.format(&quot;=====【%s】执行getNow()签名方法-开始=====&quot;, Thread.currentThread().getName()));        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            // 生成随机字符            char c = (char) (ThreadLocalRandom.current().nextInt(25 )+ 65);            return String.valueOf(c);        &#125;);        /** getNow() 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的值IfAbsent。 **/        System.out.println(&quot;getNow()签名方法，执行结果：&quot;+ completableFuture.getNow(&quot;===unknown===&quot;));        processSleep(6);        System.out.println(&quot;getNow()签名方法，执行结果：&quot;+ completableFuture.getNow(&quot;===unknown===&quot;));        System.out.println(String.format(&quot;=====【%s】getNow()签名方法-结束=====&quot;, Thread.currentThread().getName()));    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

1.4.3. 计算结果完成时的处理 &emsp;&emsp; 当CompletableFuture计算结果完成时,我们需要对结果进行处理，或者当CompletableFuture产生异常的时候需要对异常进行处理。有如下几种方法:



方法名
描述



whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action)
当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。


whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action)
当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用ForkJoinPool。


BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor)
当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用指定的线程池。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.TimeUnit;public class CompletableFutureExample2 &#123;    public static void main(String[] args) throws InterruptedException &#123;        whenComplete();        Thread.currentThread().join();    &#125;    /**     * runAsync()异步执行runAsync返回的CompletableFuture是没有返回值的。     * supplyAsync()异步执行runAsync返回的CompletableFuture是有返回值的。     执行结果：     =====【main】执行runAsync()签名方法-开始=====     Hello world！！！     =====【main】执行runAsync()签名方法-结束=====     */    /**     * whenComplete()：当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。     执行结果：         =====执行whenComplete()签名方法-开始=====         执行supplyAsync()签名方法-结束&gt;&gt;&gt;&gt;&gt;         统计字符串长度：14         =====执行whenComplete()签名方法-结束=====     */    private static void whenComplete()  &#123;        System.out.println(&quot;=====执行whenComplete()签名方法-开始=====&quot;);        CompletableFuture.supplyAsync(() -&gt;&#123;            // 睡眠5秒            processSleep(5);            System.out.println(&quot;执行supplyAsync()签名方法-结束&gt;&gt;&gt;&gt;&gt;&quot;);            return &quot;Hello world！！！&quot;;        &#125;).whenComplete((s, throwable) -&gt; &#123;            System.out.println(&quot;统计字符串长度：&quot;+s.length());            System.out.println(&quot;=====执行whenComplete()签名方法-结束=====&quot;);        &#125;);    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;


1.4.4. 计算结果完成时的转换 &emsp;&emsp; 这里同样也是返回CompletableFuture，但是这个结果会由我们自定义返回去转换他，同样的不以Async结尾的方法由原来的线程计算，以Async结尾的方法由默认的线程池ForkJoinPool.commonPool()或者指定的线程池executor运行。



方法名
描述



public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)
接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture。


public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)
接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用ForkJoinPool。


public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)
接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用指定的线程池。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.ThreadLocalRandom;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;public class CompletableFutureExample3 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        thenApply();    &#125;    /**     thenApply() 当原来的CompletableFuture计算完后，将结果传递给函数fn，将fn的结果作为新的CompletableFuture计算结果。     因此它的功能相当于将CompletableFuture&lt;T&gt;转换成CompletableFuture&lt;U&gt;。。     执行结果：         =====执行thenApply()签名方法-开始=====         thenApply()签名方法，在supplyAsync阶段，执行结果：DFRHHQ         thenApply()签名方法，执行结果：###【dfrhhq】###         =====thenApply()签名方法-结束=====     */    private static void thenApply() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====执行thenApply()签名方法-开始=====&quot;);        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            // 睡眠5秒            processSleep(5);            StringBuffer buffer = new StringBuffer();            IntStream.range(0,6).boxed().forEach(integer -&gt; &#123;                // 生成随机字符                char c = (char) (ThreadLocalRandom.current().nextInt(25 )+ 65);                buffer.append(c);            &#125;);            System.out.println(&quot;thenApply()签名方法，在supplyAsync阶段，执行结果：&quot; + buffer.toString());            return buffer.toString();        &#125;).thenApply(str -&gt; String.format(&quot;###【%s】###&quot;, str.toLowerCase()));        System.out.println(&quot;thenApply()签名方法，执行结果：&quot;+ completableFuture.get());        System.out.println(&quot;=====thenApply()签名方法-结束=====&quot;);    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

1.4.5. 计算结果完成时的消费 &emsp;&emsp; 这里还会有一个只会对计算结果消费不会返回任何结果的方法。同样的不以Async结尾的方法由原来的线程计算，以Async结尾的方法由默认的线程池ForkJoinPool.commonPool()或者指定的线程池executor运行。



方法名
描述



public CompletableFuture thenAccept(Consumer&lt;? super T&gt; action)
当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值。


public CompletableFuture thenAcceptAsync(Consumer&lt;? super T&gt; action)
当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值，使用ForkJoinPool。


public CompletableFuture thenAcceptAsync(Consumer&lt;? super T&gt; action,Executor executor)
当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.ThreadLocalRandom;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;public class CompletableFutureExample4 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        thenAccept();    &#125;    /**     thenAccept() CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值。     执行结果：     =====执行thenAccept()签名方法-开始=====     系统自动生成的6位验证码：EHSRHT，该验证码5分钟有效，请勿泄露给他人。     =====thenAccept()签名方法-结束=====     */    private static void thenAccept() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====执行thenAccept()签名方法-开始=====&quot;);        CompletableFuture                .supplyAsync(() -&gt; &quot;系统自动生成的6位验证码：&quot;)                .thenApply((str) -&gt; str + verifiCode())                .thenApply((str) -&gt; str + &quot;，该验证码5分钟有效，请勿泄露给他人。&quot;)                .thenAccept(System.out::println);        System.out.println(&quot;=====thenAccept()签名方法-结束=====&quot;);    &#125;    /**     * 生成6位数验证码     * @return     */    private static String verifiCode()&#123;        StringBuffer buffer = new StringBuffer();        IntStream.range(0,6).boxed().forEach(integer -&gt; &#123;            // 生成随机字符            char c = (char) (ThreadLocalRandom.current().nextInt(25 )+ 65);            buffer.append(c);        &#125;);        return buffer.toString();    &#125;&#125;
1.4.6. 计算结果完成时的消费合并结果 &emsp;&emsp; thenAcceptBoth以及相关方法提供了类似的功能，当两个CompletionStage都正常完成计算的时候，就会执行提供的action，它用来组合另外一个异步的结果。
&emsp;&emsp; runAfterBoth是当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。



方法名
描述



public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action)
当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。


public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action)
当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。


public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action, Executor executor)
当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。


public CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other,Runnable action)
当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。


public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action)
当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。使用ForkJoinPool。


public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)
当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。使用指定的线程池。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.TimeUnit;public class CompletableFutureExample5 &#123;    public static void main(String[] args) throws InterruptedException &#123;        thenAcceptBoth();        runAfterBoth();        Thread.currentThread().join();    &#125;    /**     thenAcceptBoth() 当你想要使用两个Future结果时，但不需要将任何结果值进行返回时，     可以用 thenAcceptBoth ，它表示后续的处理不需要返回值。     执行结果：         =====执行thenAcceptBoth()签名方法-开始=====         Hello World         =====thenAcceptBoth()签名方法-结束=====     */    private static void thenAcceptBoth() &#123;        System.out.println(&quot;=====执行thenAcceptBoth()签名方法-开始=====&quot;);        CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;)                .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &quot; World&quot;),                        (s1, s2) -&gt; System.out.println(s1 + s2));        System.out.println(&quot;=====thenAcceptBoth()签名方法-结束=====&quot;);    &#125;    /**     * runAfterBoth是当两个CompletionStage都正常完成计算的时候,     执行一个Runnable，这个Runnable并不使用计算的结果。     执行结果：          =====执行runAfterBoth()签名方法-开始=====          ForkJoinPool.commonPool-worker-1线程，工作-开始&gt;&gt;          ForkJoinPool.commonPool-worker-2线程，工作-开始&gt;&gt;          =====runAfterBoth()签名方法-结束=====          ForkJoinPool.commonPool-worker-2线程，工作-结束&lt;&lt;          ForkJoinPool.commonPool-worker-1线程，工作-结束&lt;&lt;          ===执行任务结束===     */    private static void runAfterBoth() &#123;        System.out.println(&quot;=====执行runAfterBoth()签名方法-开始=====&quot;);        CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-开始&gt;&gt;&quot;);            // 睡眠5秒            processSleep(5);            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-结束&lt;&lt;&quot;);            return 1;        &#125;).runAfterBoth(CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-开始&gt;&gt;&quot;);            // 睡眠1秒            processSleep(1);            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-结束&lt;&lt;&quot;);            return 2;        &#125;), () -&gt; System.out.println(&quot;===执行任务结束===&quot;));        System.out.println(&quot;=====runAfterBoth()签名方法-结束=====&quot;);    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;


1.4.7. 对计算结果的组合 &emsp;&emsp; 对于Compose可以连接两个CompletableFuture，其内部处理逻辑是当第一个CompletableFuture处理没有完成时会合并成一个CompletableFuture,如果处理完成，第二个future会紧接上一个CompletableFuture进行处理。



方法名
描述



public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn)
当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。


public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn)
当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。


public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)
当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;public class CompletableFutureExample6 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        thenCombine();    &#125;    /**     * 执行thenCombine()对于Compose可以连接两个CompletableFuture，     * 其内部处理逻辑是当第一个CompletableFuture处理没有完成时会合并成一个CompletableFuture,     * 如果处理完成，第二个future会紧接上一个CompletableFuture进行处理。      执行结果：         =====执行thenCombine()签名方法-开始=====         thenCombine()签名方法，执行结果：计算结果：30         =====thenCombine()签名方法-结束=====     */    private static void thenCombine() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====执行thenCombine()签名方法-开始=====&quot;);        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; 10);        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; 20);        CompletableFuture&lt;String&gt; completableFuture = future1.thenCombine(future2, (x, y) -&gt; &quot;计算结果：&quot; + (x + y));        System.out.println(&quot;thenCombine()签名方法，执行结果：&quot;+ completableFuture.get());        System.out.println(&quot;=====thenCombine()签名方法-结束=====&quot;);    &#125;&#125;

1.4.8. 对计算结果的异常处理 &emsp;&emsp; 当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。&emsp;&emsp; exceptionally() 方法将导致CompletableFuture 内发生问题的异常抛出。



方法名
描述



public  CompletableFuture handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)
当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。


public  CompletableFuture handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)
当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。使用ForkJoinPool。


public  CompletableFuture handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)
当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。使用指定的线程池。


public CompletableFuture exceptionally(Function&lt;Throwable, ? extends T&gt; fn)
exceptionally() 方法将导致CompletableFuture 内发生问题的异常抛出。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;public class CompletableFutureExample7 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        handle();        exceptionally();    &#125;    /**     handle() 当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理。     执行结果：         =====handle()签名方法-开始=====         handle()签名方法，在supplyAsync阶段，执行1/0结果。         handle()签名方法，执行结果：-1         =====handle()签名方法-结束=====         java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero         at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273)         at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280)         at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1592)         at java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1582)         at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)         at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)         at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)         at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)         Caused by: java.lang.ArithmeticException: / by zero         at com.yuanxw.chapter24.CompletableFutureExample7.lambda$handle$0(CompletableFutureExample3.java:26)         at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1590)         ... 5 more     */    private static void handle() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====handle()签名方法-开始=====&quot;);        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(&quot;handle()签名方法，在supplyAsync阶段，执行1/0结果。&quot;);            return 1/0;        &#125;).handle((integer, throwable) -&gt; &#123;            if(throwable != null)&#123;                throwable.printStackTrace();                return -1;            &#125;           return integer;        &#125;);        System.out.println(&quot;handle()签名方法，执行结果：&quot;+ completableFuture.get());        System.out.println(&quot;=====handle()签名方法-结束=====&quot;);    &#125;    /**     * exceptionally() 方法将导致CompletableFuture 内发生问题的异常抛出。     * 这样，当执行任务发生异常时，调用get()方法的线程将会收到一个 ExecutionException 异常，     * 该异常接收了一个包含失败原因的Exception 参数。     * 执行结果：         =====exceptionally()签名方法-开始=====         exceptionally()签名方法，在supplyAsync阶段，执行1/0结果。         exceptionally()签名方法，执行结果：java.lang.ArrayIndexOutOfBoundsException: 1         =====exceptionally()签名方法-结束=====     * @throws ExecutionException     * @throws InterruptedException     */    private static void exceptionally() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====exceptionally()签名方法-开始=====&quot;);        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(&quot;exceptionally()签名方法，在supplyAsync阶段，执行1/0结果。&quot;);            String [] array = new String[]&#123;&#125;;            // 此处异常：java.lang.ArrayIndexOutOfBoundsException: 1            return array[1];        &#125;).exceptionally(ex -&gt; ex.getMessage());        System.out.println(&quot;exceptionally()签名方法，执行结果：&quot;+ completableFuture.get());        System.out.println(&quot;=====exceptionally()签名方法-结束=====&quot;);    &#125;&#125;
1.4.9. 其它方法 &emsp;&emsp;allOf方法是当所有的CompletableFuture都执行完后执行计算。anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。



方法名
描述



public static CompletableFuture allOf(CompletableFuture&lt;?&gt;… cfs)
allOf方法是当所有的CompletableFuture都执行完后执行计算。


public static CompletableFuture anyOf(CompletableFuture&lt;?&gt;… cfs)
anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。


package com.yuanxw.chapter24;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeUnit;public class CompletableFutureExample8 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        anyAndAllOfCompletableFuture();    &#125;    /**     allOf方法是当所有的CompletableFuture都执行完后执行计算。     anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。     执行结果：         =====anyAndAllOfCompletableFuture()签名方法-开始=====         ForkJoinPool.commonPool-worker-1线程，工作-开始&gt;&gt;         ForkJoinPool.commonPool-worker-2线程，工作-开始&gt;&gt;         ForkJoinPool.commonPool-worker-2线程，工作-结束&lt;&lt;         anyOf()签名方法，执行结果：result-2         ForkJoinPool.commonPool-worker-1线程，工作-结束&lt;&lt;         =====anyAndAllOfCompletableFuture()签名方法-结束=====     */    private static void anyAndAllOfCompletableFuture() throws ExecutionException, InterruptedException &#123;        System.out.println(&quot;=====anyAndAllOfCompletableFuture()签名方法-开始=====&quot;);        CompletableFuture&lt;String&gt; completableFuture1=CompletableFuture.supplyAsync(()-&gt;&#123;            //模拟执行耗时任务            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-开始&gt;&gt;&quot;);            // 睡眠5秒            processSleep(5);            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-结束&lt;&lt;&quot;);            //返回结果            return &quot;result-1&quot;;        &#125;);        CompletableFuture&lt;String&gt; completableFuture2=CompletableFuture.supplyAsync(()-&gt;&#123;            //模拟执行耗时任务            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-开始&gt;&gt;&quot;);            // 睡眠5秒            processSleep(1);            System.out.println(Thread.currentThread().getName() + &quot;线程，工作-结束&lt;&lt;&quot;);            //返回结果            return &quot;result-2&quot;;        &#125;);        CompletableFuture&lt;Object&gt; anyOfCompletableFuture = CompletableFuture.anyOf(completableFuture1,completableFuture2);        System.out.println(&quot;anyOf()签名方法，执行结果：&quot;+ anyOfCompletableFuture.get());        CompletableFuture&lt;Void&gt; allOfCompletableFuture = CompletableFuture.allOf(completableFuture1,completableFuture2);        // 阻塞等待所有任务执行完成        allOfCompletableFuture.join();        System.out.println(&quot;=====anyAndAllOfCompletableFuture()签名方法-结束=====&quot;);    &#125;    /**     * 线程休眠的方法     * @param seconds     */    private static void processSleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(二十四)Java多线程之CompletableFuture类》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(五)Java多线程之interrupted线程中断</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%94)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Binterrupted%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[1.JAVA多线程(五)Java多线程之interrupted线程中断1.1 interrupted(线程中断)&emsp;&emsp;一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。
package com.yuanxw.chapter5;/** * 中断线程 */public class InterruptThread &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread() &#123;            @Override            public void run() &#123;                try &#123;                    while (true) &#123;                        sleep(500);                        System.out.println(Thread.currentThread().getName() + &quot;正在运行...&quot;);                    &#125;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                    System.out.println(Thread.currentThread().getName() + &quot;线程被打断了...&quot;);                &#125;            &#125;        &#125;;        thread.start();        /** main线程休息2秒 **/        Thread.sleep(2000);        System.out.println(String.format(&quot;【%s】线程是否中断：%s&quot;, thread.getName(),thread.isInterrupted()));        /** 中断线程操作 **/        thread.interrupt();        System.out.println(String.format(&quot;【%s】线程是否中断：%s&quot;, thread.getName(),thread.isInterrupted()));    &#125;&#125;
执行结果：
Thread-0正在运行...Thread-0正在运行...Thread-0正在运行...Thread-0正在运行...【Thread-0】线程是否中断：false【Thread-0】线程是否中断：trueThread-0线程被打断了...java.lang.InterruptedException: sleep interrupted	at java.lang.Thread.sleep(Native Method)	at com.yuanxw.chapter3.InterruptThread$1.run(InterruptThread.java:13) 

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(五)Java多线程之interrupted线程中断》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(八)Java多线程之死锁</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%85%AB)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[1.JAVA多线程(八)Java多线程之死锁1.1什么是线程死锁?如何避免死锁?&emsp;&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。
如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。
![在这里插入图片描述](&#x2F;images&#x2F;java_multithreading&#x2F;chapter8&#x2F;20191230105715913.png
下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：
package com.yuanxw.chapter8;/** * 死锁 */public class DeadLockDemo &#123;    private static Object resource1 = new Object();//资源 1    private static Object resource2 = new Object();//资源 2    public static void main(String[] args) &#123;        new Thread(() -&gt; &#123;            synchronized (resource1) &#123;                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);                synchronized (resource2) &#123;                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                &#125;            &#125;        &#125;, &quot;线程A&quot;).start();        new Thread(() -&gt; &#123;            synchronized (resource2) &#123;                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);                synchronized (resource1) &#123;                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                &#125;            &#125;        &#125;, &quot;线程B&quot;).start();    &#125;&#125;
执行结果
Thread[线程A,5,main]get resource1Thread[线程B,5,main]get resource2Thread[线程B,5,main]waiting get resource1Thread[线程A,5,main]waiting get resource2

线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。
学过操作系统的朋友都知道产生死锁必须具备以下四个条件：

互斥条件：该资源任意一个时刻只由一个线程占用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

1.2通过命令检查死锁
 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(八)Java多线程之死锁》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(六)Java多线程之ThreadGroup</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%85%AD)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadGroup/</url>
    <content><![CDATA[1.JAVA多线程(六)Java多线程之ThreadGroup1.1 ThreadGroup&emsp;&emsp;ThreadGroup是Java提供的一种对线程进行分组管理的手段，可以对所有线程以组为单位进行操作，如设置优先级、守护线程等。
&emsp;&emsp;在Java程序中，默认情况下，新的线程都会加入到 main 线程所在的 group 中， main 线程的 group 和线程同名。和线程存在父子关系一样， ThreadGroup 也存在父子关系

package com.yuanxw.chapter6;import java.util.Arrays;public class ThreadGroupService &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread(&quot;thread-0&quot;)&#123;            @Override            public void run() &#123;                try &#123;                    // 睡眠100L                    sleep(100L);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;;        thread.start();        // 获得当前线程的名称        System.out.println(&quot;获得当前线程的名称：&quot;+Thread.currentThread().getName());        // 获得当前线程的线程线名称        System.out.println(&quot;获得当前线程的线程线名称：&quot;+Thread.currentThread().getThreadGroup().getName());        // 获得thread-0线程的线程线名称        System.out.println(&quot;获得&quot;+thread.getName()+&quot;线程的线程线名称：&quot;+thread.getThreadGroup().getName());        // 創建线程组        ThreadGroup syncDbGroup = new ThreadGroup(&quot;SYNC_DB_GROUP&quot;);        Arrays.asList(&quot;thread-A&quot;,&quot;thread-B&quot;,&quot;thread-C&quot;,&quot;thread-D&quot;).forEach(name -&gt;&#123;            Thread t = new Thread(syncDbGroup, () -&gt; &#123;                while (true) &#123;&#125;            &#125;, name);            t.setDaemon(true);            t.start();        &#125;);        ThreadGroup syncErpDbGroup = new ThreadGroup(syncDbGroup,&quot;SYNC_ERP_DB_GROUP&quot;);        ThreadGroup syncOADbGroup = new ThreadGroup(syncDbGroup,&quot;SYNC_OA_DB_GROUP&quot;);        Arrays.asList(&quot;thread-1&quot;,&quot;thread-2&quot;).forEach(name -&gt;&#123;            Thread t = new Thread(syncErpDbGroup, () -&gt; &#123;                while (true) &#123;&#125;            &#125;, name);            t.setDaemon(true);            t.start();        &#125;);        System.out.println(&quot;返回此线程组及其子组中活动线程数的估计：&quot;+syncDbGroup.activeCount());        System.out.println(&quot;返回此线程组及其子组中活动组数的估计：&quot;+syncDbGroup.activeGroupCount());        // 设置线程组为后台线程组----最后一个线程执行结束或者被销毁后,该后台线程组自动销毁        syncDbGroup.setDaemon(true);        // interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。        syncErpDbGroup.interrupt();    &#125;&#125;
执行结果：
获得当前线程的名称：main获得当前线程的线程线名称：main获得thread-0线程的线程线名称：main返回此线程组及其子组中活动线程数的估计：6返回此线程组及其子组中活动组数的估计：2


 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(六)Java多线程之ThreadGroup》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十)Java多线程之ThreadLocal</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/</url>
    <content><![CDATA[1.JAVA多线程(十)Java多线程之ThreadLocal1.1 ThreadLocal类&emsp;&emsp;  ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get()和 set())方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。
每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的，由于不需要共享信息，自然就不存在竞争问题了，从而保证了某些情况下线程的安全，以及避免了某些情况需要考虑线程安全必须同步带来的性能损失！
1.2 ThreadLocal示例package com.yuanxw.chapter10;import java.util.Random;/** * ThreadLocal * 线程局部变量 */public class ThreadLocalExample &#123;    private static ThreadLocal&lt;String&gt; defaultThreadLocal = new ThreadLocal()&#123;        @Override        protected Object initialValue() &#123;            return &quot;==initialValue==&quot;;        &#125;    &#125;;    private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal();    public static void main(String[] args) throws InterruptedException &#123;        System.out.println(&quot;获得defaultThreadLocal默认值：&quot;+defaultThreadLocal.get());        // 线程-A        Thread thread1 = new Thread(() -&gt; &#123;            // 设置【threadLocal】对象值为：张三            threadLocal.set(&quot;张三&quot;);            try &#123;                Thread.sleep(new Random().nextInt(1000));            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(String.format(&quot;【%s】线程-执行threadLocal值：【%s】&quot;, Thread.currentThread().getName(),threadLocal.get()));        &#125;, &quot;Thread-A&quot;);        // 线程-B        Thread thread2 = new Thread(() -&gt; &#123;            // 设置【threadLocal】对象值为：李四            threadLocal.set(&quot;李四&quot;);            try &#123;                Thread.sleep(new Random().nextInt(1000));            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(String.format(&quot;【%s】线程-执行threadLocal值：【%s】&quot;, Thread.currentThread().getName(),threadLocal.get()));        &#125;, &quot;Thread-B&quot;);        thread1.join();        thread2.join();        thread1.start();        thread2.start();        Thread.sleep(new Random().nextInt(1000));        System.out.println(String.format(&quot;【%s】线程-执行threadLocal值：【%s】&quot;, Thread.currentThread().getName(),threadLocal.get()));    &#125;&#125;
执行结果：
获得defaultThreadLocal默认值：==initialValue==【Thread-B】线程-执行threadLocal值：【李四】【Thread-A】线程-执行threadLocal值：【张三】【main】线程-执行threadLocal值：【null】
1.3 ThreadLocal对应的底层结构图
每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中，get() 方法类似。
/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;/** * Returns the value in the current thread&#x27;s copy of this * thread-local variable.  If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread&#x27;s value of this thread-local */public T get() &#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) &#123;        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) &#123;            @SuppressWarnings(&quot;unchecked&quot;)            T result = (T)e.value;            return result;        &#125;    &#125;    return setInitialValue();&#125;/** * Sets the current thread&#x27;s copy of this thread-local variable * to the specified value.  Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread&#x27;s copy of *        this thread-local. */public void set(T value) &#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);&#125;

1.3 ThreadLocal 内存泄露问题在一些场景 (尤其是使用线程池) 下，ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法。
 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十)Java多线程之ThreadLocal》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十一)Java多线程之自定义线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B8%80)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[1.JAVA多线程(十一)Java多线程之自定义线程池1.1 什么是用线程池&emsp;&emsp; 线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。
1.2 为什么要用线程池&emsp;&emsp;池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。
这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处：

降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

1.3 如何自定义线程池&emsp;&emsp;自定义简单的线程池，线程池大小，任务队列大小，拒绝策略等，下面的代码简单实现线程池。

定义任务状态

package com.yuanxw.chapter11;/** * 任务状态 */public enum TaskState &#123;        /**         * 空闲         **/        FREE,        /**         * 运行中         **/        RUNNING,        /**         * 阻塞         **/        BLOCKED,        /**         * 死亡         **/        DEAD;&#125;


自定义异常

package com.yuanxw.chapter11;/** * 自定义异常 */public class DiscardException extends RuntimeException&#123;    public DiscardException(String message) &#123;        super(message);    &#125;&#125;


定义拒绝策略接口

package com.yuanxw.chapter11;/** * 拒绝策略 */public interface DiscardPolicy &#123;    /** 定义拒绝策略 **/    void discard() throws DiscardException;&#125;


定义拒绝策略接口实现

package com.yuanxw.chapter11;/** * 默认：拒绝策略 */public class DefaultDiscardPolicyImpl implements DiscardPolicy&#123;    @Override    public void discard() throws DiscardException &#123;        throw new DiscardException(&quot;该任务已经被拒绝！&quot;);    &#125;&#125;


线程池实现方法

package com.yuanxw.chapter11;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;/** * 自定义简单的线程池 */public class SimpleThreadPool &#123;    /**     * 线程池大小     **/    private final int size;    /**     * 任务队列大小     **/    private final int taskQueueSize;    /**     * 默认线程池大小为：5     **/    private final static int DEFAULT_SIZE = 5;    /**     * 默认任务队列大小：2000     **/    private final static int DEFAULT_TASK_QUEUE_SIZE = 2000;    /**     * 线程序号     */    private static volatile int seq = 0;    /**     * 线程前缀     **/    private final static String THREAD_PREFIX = &quot;SIMPLE-THREAD-POOL-&quot;;    /**     * 定义线程程     **/    private final static ThreadGroup GROUP = new ThreadGroup(&quot;POOL_GROUP&quot;);    /**     * 定线程队列     **/    private final static List&lt;WorkerTask&gt; THREAD_QUEUE = new ArrayList&lt;&gt;();    /**     * 任务队列     */    private static LinkedList&lt;Runnable&gt; TASK_QUEUE = new LinkedList&lt;&gt;();    /**     * 默认策略     **/    public static final DiscardPolicy DEFAULT_DISCARD_POLICY = new DefaultDiscardPolicyImpl();    /** 定义策略变量 **/    private final DiscardPolicy discardPolicy;    /** 是否已经销毁 **/    private volatile boolean destroy = false;    public SimpleThreadPool() &#123;        this(DEFAULT_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);    &#125;    public SimpleThreadPool(int size, int taskQueueSize, DiscardPolicy discardPolicy) &#123;        this.size = size;        this.taskQueueSize = taskQueueSize;        this.discardPolicy = discardPolicy;        init();    &#125;    /**     * 初始化方法     */    private void init() &#123;        // 创建size线程        for (int i = 0; i &lt; size; i++) &#123;            createWorkTask();        &#125;    &#125;    /**     * 创建线程函数     */    private void createWorkTask() &#123;        /** 创建线程 **/        WorkerTask task = new WorkerTask(GROUP, THREAD_PREFIX + (seq++));        /** 启动线程 **/        task.start();        /** 线程添加到组中 **/        THREAD_QUEUE.add(task);    &#125;    /**     * 任务提交     * @param runnable     */    public void submit(Runnable runnable) &#123;        if(destroy)&#123;            throw new IllegalStateException(&quot;线程池已经销毁不能再提交新的任务...&quot;);        &#125;        synchronized (TASK_QUEUE) &#123;            // 队列长度大于指定队列长度，执行策略            if (TASK_QUEUE.size() &gt; taskQueueSize) &#123;                discardPolicy.discard();            &#125;            // 从后面添加新任务            TASK_QUEUE.addLast(runnable);            // 通知唤醒线程            TASK_QUEUE.notifyAll();        &#125;    &#125;    /**     * 停止线程池运行     */    public void shutdonw() throws InterruptedException &#123;        // 如果线程队列中还有在执行的结程，那执行停止的方法需要等待。等待到所有线程都执行完成。        while (!TASK_QUEUE.isEmpty()) &#123;            Thread.sleep(50);        &#125;        int initVal = THREAD_QUEUE.size();        while (initVal &gt; 0) &#123;            for (WorkerTask workerTask : THREAD_QUEUE) &#123;                if (workerTask.getTaskState() == TaskState.BLOCKED) &#123;                    // 打断线程                    workerTask.interrupt();                    // 修改线程状态为结束状态                    workerTask.close();                    initVal--;                &#125; else &#123;                    Thread.sleep(10);                &#125;            &#125;        &#125;        this.destroy = true;        System.out.println(&quot;线程已经运行结束...&quot;);    &#125;    private static class WorkerTask extends Thread &#123;        /**         * 默认线程的状态是空闲的         **/        private volatile TaskState taskState = TaskState.FREE;        /**         * 设置线程组         **/        public WorkerTask(ThreadGroup group, String name) &#123;            super(group, name);        &#125;        @Override        public void run() &#123;            OUTTER:            // 状态不是DEAD状态，一直处理线程            while (this.taskState != TaskState.DEAD) &#123;                Runnable runnable;                synchronized (TASK_QUEUE) &#123;                    // 程线池中一直是空的，一直等待                    while (TASK_QUEUE.isEmpty()) &#123;                        try &#123;                            this.taskState = TaskState.BLOCKED;                            TASK_QUEUE.wait();                        &#125; catch (InterruptedException e) &#123;                            // e.printStackTrace();                            break OUTTER;                        &#125;                    &#125;                    // 从此列表中删除并返回第一个元素。                    runnable = TASK_QUEUE.removeFirst();                &#125;                if (runnable != null) &#123;                    // 设置线程状态，运行中                    taskState = TaskState.RUNNING;                    // run函数                    runnable.run();                    // 设置线程状态，空闲                    taskState = TaskState.FREE;                &#125;            &#125;        &#125;        /**         * 获得线程状态         *         * @return         */        public TaskState getTaskState() &#123;            return this.taskState;        &#125;        /**         * 结束线程状态         */        public void close() &#123;            this.taskState = TaskState.DEAD;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        SimpleThreadPool simpleThreadPool = new SimpleThreadPool();        // 拒绝策略        // SimpleThreadPool simpleThreadPool = new SimpleThreadPool(6, 10, DEFAULT_DISCARD_POLICY);        for (int i = 0; i &lt; 50; i++) &#123;            simpleThreadPool.submit(new Runnable() &#123;                @Override                public void run() &#123;                    System.out.println(String.format(&quot;线程【%s】，已经开始&gt;&gt;运行&quot;, Thread.currentThread()));                    try &#123;                        Thread.sleep(1000L);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(String.format(&quot;线程【%s】，已经&lt;&lt;结束&quot;, Thread.currentThread()));                &#125;            &#125;);        &#125;        Thread.sleep(1000L);        simpleThreadPool.shutdonw();    &#125;&#125;
执行结果：
线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经开始&gt;&gt;运行线程【Thread[SIMPLE-THREAD-POOL-0,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-1,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-2,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-3,5,POOL_GROUP]】，已经&lt;&lt;结束线程【Thread[SIMPLE-THREAD-POOL-4,5,POOL_GROUP]】，已经&lt;&lt;结束线程已经运行结束...



 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十一)Java多线程之自定义线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十七)Java多线程之ForkJoin框架</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B8%83)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BForkJoin%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[1.JAVA多线程(十七)Java多线程之ForkJoin框架1.1 什么是ForkJoin框架？&emsp;&emsp; Fork&#x2F;Join 框架，可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。通过这种方式，Fork&#x2F;Join 能试着去使用所有可用的处理器，以达到加速处理多线程的目的。本文中对Fork&#x2F;Join框架的讲解，基于JDK1.8+中的Fork&#x2F;Join框架实现。

Fork&#x2F;Join框架要完成两件事情：

任务分割：&emsp;&emsp; 首先Fork&#x2F;Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割。

执行任务并合并结果：&emsp;&emsp; 分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。

ForkJoinTask类：&emsp;&emsp;使用Fork&#x2F;Join框架，首先需要创建一个ForkJoin任务。该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集成ForkJoinTask类，只需要继承它的子类，Fork&#x2F;Join框架提供了两个子类:&emsp;&emsp;RecursiveTask： 用于有返回结果的任务&emsp;&emsp;RecursiveAction：用于没有返回结果的任务



1.2 RecursiveTask使用样例使用CalculatorRecursiveTask extends RecursiveTask完成1到10000累加的需求，代码如下：
package com.yuanxw.chapter17;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;import java.util.stream.IntStream;/** * 使用CalculatorRecursiveTask extends RecursiveTask完成1到10000累加的需求 */public class ForkJoinRecursiveTask &#123;    // 阈值    private final static int THRESHOLD = 200;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        // 计算1-50累加值        CalculatorRecursiveTask calculatorRecursiveTask = new CalculatorRecursiveTask(1,10000);        ForkJoinPool forkJoinPool = new ForkJoinPool();        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(calculatorRecursiveTask);        System.out.println(&quot;计算结果：&quot;+forkJoinTask.get());    &#125;    /**     * 有返回值ForkJoin任务     */    private static class CalculatorRecursiveTask extends RecursiveTask&lt;Integer&gt; &#123;        // 开始计算机位置        public int first;        // 结束计算机位置        private int last;        /**         * 构造函数         *         * @param first         * @param last         */        public CalculatorRecursiveTask(int first, int last) &#123;            this.first = first;            this.last = last;        &#125;        @Override        protected Integer compute() &#123;            if (last - first &lt;= THRESHOLD) &#123;                /**                 * 任务足够小则直接计算                 * 使用lambda表达式简化如下代码                 * &lt;pre&gt;                 * for (int i = first; i &lt;= last; i++) &#123;                 *     result += i;                 * &#125;                 * &lt;/pre&gt;                 */                return IntStream.rangeClosed(first, last).sum();            &#125; else &#123;                // 获得中间值，向上取整                int middle = (first + last) / 2;                CalculatorRecursiveTask leftTask = new CalculatorRecursiveTask(first, middle);                CalculatorRecursiveTask rightTask = new CalculatorRecursiveTask(middle + 1, last);                leftTask.fork();                rightTask.fork();                return leftTask.join() + rightTask.join();            &#125;        &#125;    &#125;&#125;
执行结果：
计算结果：50005000

1.3 ForkJoinPool线程池&emsp;&emsp;ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。
public class ForkJoinPool extends AbstractExecutorService &#123;    /**     * Creates a &#123;@code ForkJoinPool&#125; with parallelism equal to &#123;@link     * java.lang.Runtime#availableProcessors&#125;, using the &#123;@linkplain     * #defaultForkJoinWorkerThreadFactory default thread factory&#125;,     * no UncaughtExceptionHandler, and non-async LIFO processing mode.     *     * @throws SecurityException if a security manager exists and     *         the caller is not permitted to modify threads     *         because it does not hold &#123;@link     *         java.lang.RuntimePermission&#125;&#123;@code (&quot;modifyThread&quot;)&#125;     */    public ForkJoinPool() &#123;        this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),             defaultForkJoinWorkerThreadFactory, null, false);    &#125;
ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。

1.4 RecursiveAction使用样例
用于没有返回结果的任务，利用RecursiveAction，拆分大文件。代码如下：

package com.yuanxw.chapter17;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.nio.channels.FileChannel;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveAction;import java.util.concurrent.TimeUnit;/** * 利用RecursiveAction，拆分大文件 */public class ForkJoinRecursiveAction &#123;    // 阈值    private final static int SPLIT_THRESHOLD = 100_000_000;    public static void main(String[] args) throws IOException, InterruptedException &#123;        String fileFullPath = &quot;G:\\当幸福来敲门BD中英双字1280高清.rmvb&quot;;        File bigFile = new File(fileFullPath);        FileInputStream fileInputStream = new FileInputStream(bigFile);        ForkJoinPool forkJoinPool = new ForkJoinPool();        ForkJoinTask&lt;Void&gt; submit = forkJoinPool.submit(new SplitFileRecursiveAction(fileInputStream, fileFullPath, 0, (int) bigFile.length()));        // 等待任务执行结束        forkJoinPool.awaitTermination(1, TimeUnit.SECONDS);    &#125;    /**     * 无返回值ForkJoin任务     */    private static class SplitFileRecursiveAction extends RecursiveAction &#123;        // 文件输出流        private FileInputStream fileInputStream;        // 文件全路径        private String fileFullPath;        // 开始位置        private int start;        // 结束位置        private int end;        public SplitFileRecursiveAction(FileInputStream fileInputStream, String fileFullPath, int start, int end) &#123;            this.fileInputStream = fileInputStream;            this.fileFullPath = fileFullPath;            this.start = start;            this.end = end;        &#125;        @Override        protected void compute() &#123;            // 如果任务计算小于阈值，则开始拆分文件            int length = end - start;            System.out.println(start +&quot;-&quot;+end);            if(length &lt;= SPLIT_THRESHOLD)&#123;                try &#123;                    // 每次切割大小                    byte[] buffer = new byte[length];                    File currentTempFile = new File(fileFullPath);                    String[] split = currentTempFile.getName().split(&quot;\\.&quot;);                    File fileName = new File(String.format(&quot;%s_%s_%s.%s&quot;, currentTempFile.getParent()+split[0], start, end, split[1]));                    FileOutputStream fileOutputStream = new FileOutputStream(fileName);                    FileChannel outputChannel = fileOutputStream.getChannel();                    // 通道传输文件数据                    fileInputStream.getChannel().transferTo(start, end, outputChannel);                    fileOutputStream.write(buffer);                    fileOutputStream.flush();                    outputChannel.close();                &#125; catch (FileNotFoundException e) &#123;                    e.printStackTrace();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125; else &#123;                // 获得中间值，向上取整                int middle = (end + start) / 2;                SplitFileRecursiveAction leftAction = new SplitFileRecursiveAction(fileInputStream,fileFullPath,start,middle);                SplitFileRecursiveAction rightAction = new SplitFileRecursiveAction(fileInputStream,fileFullPath,middle+1,end);                leftAction.fork();                rightAction.fork();                leftAction.join();                rightAction.join();            &#125;        &#125;    &#125;&#125;
执行结果：

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十七)Java多线程之ForkJoin框架》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十三)Java多线程之CyclicBarrier</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B8%89)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCyclicBarrier/</url>
    <content><![CDATA[1.JAVA多线程(十三)Java多线程之CyclicBarrier&emsp;&emsp; CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。
1.1 CyclicBarrier类&emsp;&emsp;  CyclicBarrier是java.util.concurrent包下面的一个工具类，字面意思是可循环使用（Cyclic）的屏障（Barrier），通过它可以实现让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，所有被屏障拦截的线程才会继续执行。

CyclicBarrier是一种同步机制,它可以使得一组线程在同一个障碍点进行等待。
CyclicBarriers 可以通过重置计数器从而重新使用。
CyclicBarrier支持一个可选的Runnable命令(实例化构造函数中的参数)，该命令在最后一个线程到达后，但在任何线程被释放之前被执行。这一命令在barrier处只会被执行一次,且由最后到达的线程完成。这种屏障行为对于在任何一方继续之前更新共享状态都很有用。
all-or-none破损模型：如果一个线程因为中断(or执行过程的失败,超时等)过早的离开了barrier点,那么等待在barrier点的其他所有线程也会在同一时间因为BrokenBarrierException或者InterruptedException异常而离开barrier。内存一致性影响：

线程在调用await()方法之前的行为要优先于barrier action中的任何行为。



barrier action成功返回这一行为要优先于所有其他等待线程await()后的行为。



1.2 CyclicBarrier示例package com.yuanxw.chapter13;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;/** * CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。 * 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 * CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。 */public class CyclicBarrierExample &#123;    private static volatile boolean isRunning = true;    public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123;        final CyclicBarrier cyclicBarrier = new CyclicBarrier(2, new Runnable() &#123;            @Override            public void run() &#123;                isRunning = false;                System.out.println(&quot;任务执行结束后，回调函数！！！&quot;);            &#125;        &#125;);        /** 线程-A **/        new Thread(()-&gt;&#123;            try &#123;                TimeUnit.SECONDS.sleep(20);                System.out.println(String.format(&quot;线程【%s】执行完成&quot;, Thread.currentThread().getName()));                cyclicBarrier.await();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; catch (BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;Thread-A&quot;).start();        /** 线程-A **/        new Thread(()-&gt;&#123;            try &#123;                TimeUnit.SECONDS.sleep(10);                System.out.println(String.format(&quot;线程【%s】执行完成&quot;, Thread.currentThread().getName()));                cyclicBarrier.await();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; catch (BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;Thread-B&quot;).start();        while (isRunning) &#123;            System.out.println(String.format(&quot;当前正在等待数量：【%s】&quot;, cyclicBarrier.getNumberWaiting()));            System.out.println(String.format(&quot;正在等待所需数量：【%s】 &quot;, cyclicBarrier.getParties()));            System.out.println(String.format(&quot;中断或超时：【%s】&quot;, cyclicBarrier.isBroken()));            TimeUnit.SECONDS.sleep(5);        &#125;    &#125;&#125;
执行结果：
当前正在等待数量：【0】正在等待所需数量：【2】 中断或超时：【false】当前正在等待数量：【0】正在等待所需数量：【2】 中断或超时：【false】线程【Thread-B】执行完成当前正在等待数量：【1】正在等待所需数量：【2】 中断或超时：【false】当前正在等待数量：【1】正在等待所需数量：【2】 中断或超时：【false】线程【Thread-A】执行完成任务执行结束后，回调函数！！！

1.3 CyclicBarrier 和 CountDownLatch 的区别
CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。
对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。
CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十三)Java多线程之CyclicBarrier》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 多线程(十九)Java 多线程之 CachedThreadPool 可缓存线程池</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B9%9D)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BnewCachedThreadPool%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB/</url>
    <content><![CDATA[1.JAVA 多线程(十九)Java 多线程之 CachedThreadPool 可缓存线程池1.1 可缓存线程池 CachedThreadPool&emsp;&emsp; 可缓存线程池 CachedThreadPool 是一个根据需要创建新线程的线程池。通过源代码查看 CachedThreadPool 实现：
/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available.  These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */public static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());&#125;/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available, and uses the provided * ThreadFactory to create new threads when needed. * @param threadFactory the factory to use when creating new threads * @return the newly created thread pool * @throws NullPointerException if threadFactory is null */public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;(),                                  threadFactory);&#125;

在 CachedThreadPool 实现中：

corePoolSize &#x3D;&gt; 0，核心线程池的数量为：0
maximumPoolSize &#x3D;&gt; Integer.MAX_VALUE，线程池最大数量为 Integer.MAX_VALUE，可以认为可以无限创建线程。在资源有限的情况下容易引起 OOM 异常。
keepAliveTime &#x3D;&gt; keepAliveTime 为 60 少，意味着线程空闲时间超过 60S 就会被杀死；
workQueue &#x3D;&gt; 采用 SynchronousQueue 装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。

1.2 CachedThreadPool 使用样例CachedThreadPool 线程池特点：

工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
keepAliveTime 时长为 60 秒，超过 60 秒的空闲线程就会被回收，当线程池都处于闲置状态时，线程池中的线程都会因为超时而被回收，所以几乎不会占用什么系统资源。任务队列采用的是 SynchronousQueue，这个队列是无法插入任务的，一有任务立即执行，所以 CachedThreadPool 比较适合任务量大但耗时少的任务。

package com.yuanxw.chapter19;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class CachedThreadPoolExample &#123;    public static void main(String[] args) throws InterruptedException &#123;        ExecutorService executorService = Executors.newCachedThreadPool();        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());        executorService.execute(()-&gt;System.out.println(String.format(&quot;线程【%s】正在工作......&quot;, Thread.currentThread().getName())));        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());        for (int i = 0; i &lt; 20; i++) &#123;            executorService.execute(()-&gt;&#123;                    try &#123;                        TimeUnit.SECONDS.sleep(1);                        System.out.println(String.format(&quot;线程【%s】正在工作&gt;&gt;&gt;&gt;&quot;, Thread.currentThread().getName()));                        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;            &#125;);        &#125;        TimeUnit.SECONDS.sleep(5);        System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());    &#125;&#125;

执行结果：
获得活动的线程评估数：0获得活动的线程评估数：1线程【pool-1-thread-1】正在工作......线程【pool-1-thread-3】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-7】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-5】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：20线程【pool-1-thread-4】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-6】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-2】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：19获得活动的线程评估数：19获得活动的线程评估数：20获得活动的线程评估数：20获得活动的线程评估数：19线程【pool-1-thread-19】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-15】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-21】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-16】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-20】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-14】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14线程【pool-1-thread-8】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14获得活动的线程评估数：14线程【pool-1-thread-11】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-12】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-18】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14获得活动的线程评估数：11获得活动的线程评估数：11获得活动的线程评估数：11获得活动的线程评估数：13线程【pool-1-thread-9】正在工作&gt;&gt;&gt;&gt;线程【pool-1-thread-13】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14线程【pool-1-thread-10】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：14线程【pool-1-thread-17】正在工作&gt;&gt;&gt;&gt;获得活动的线程评估数：5获得活动的线程评估数：6获得活动的线程评估数：6获得活动的线程评估数：4获得活动的线程评估数：0

CachedThreadPool 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：

首先执行 SynchronousQueue.offer(Runnable task) 提交任务到任务队列。如果当前 maximumPool 中有闲线程正在执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)，那么主线程执行 offer 操作与空闲线程执行的 poll 操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成，否则执行下面的步骤

当初始 maximumPool 为空，或者 maximumPool 中没有空闲线程时，将没有线程执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)。这种情况下，步骤 1 将失败，此时 CachedThreadPool 会创建新线程执行任务，execute 方法执行完成；


&emsp;&emsp;&emsp;&emsp;– 以上为《JAVA 多线程(十九)Java 多线程之 CachedThreadPool 可缓存线程池》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。
  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十二)Java多线程之CountDownLatch</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%BA%8C)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCountDownLatch/</url>
    <content><![CDATA[1.JAVA多线程(十二)Java多线程之CountDownLatch1.1 CountDownLatch是什么?&emsp;&emsp; CountDownLatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。

某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减 1 countdownlatch.countDown()，当计数器的值变为 0 时，在CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。

实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 ：new CountDownLatch(1)，多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。

CountDownLatch维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。



1.2 CountdownLatch使用例子package com.yuanxw.chapter12;import java.util.Random;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.stream.IntStream;public class CountdownLatchExample &#123;    /** 随机数：使用long参数的所有64位作为因子值。 **/    private static Random random = new Random(System.currentTimeMillis());    /** 总线程数 **/    private static final int TOTAL_THREAD_NUMBER = 5;    /** 通过线程池，创建5个线程 **/    private static ExecutorService executorService = Executors.newFixedThreadPool(TOTAL_THREAD_NUMBER);    /** 创建CountDownLatch对象 **/    private static CountDownLatch countDownLatch = new CountDownLatch(TOTAL_THREAD_NUMBER);    public static void main(String[] args) throws InterruptedException &#123;        IntStream.range(0,5).forEach(i-&gt;&#123;            executorService.execute(()-&gt;&#123;                doWorking();                /** 将count值减1 **/                countDownLatch.countDown();            &#125;);        &#125;);        /** 当前线程等到锁存器计数到零  **/        countDownLatch.await();        executorService.shutdown();        System.out.println(&quot;所有线程工作已经执行完成！！！&quot;);    &#125;    /**     * 模拟工作方法     */    private static void doWorking()&#123;        try &#123;            System.out.println(String.format(&quot;线程【%s】工作&gt;&gt;开始&quot;, Thread.currentThread().getName()));            Thread.sleep(random.nextInt(1000));            System.out.println(String.format(&quot;线程【%s】工作&lt;&lt;结束&quot;, Thread.currentThread().getName()));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
执行结果：
线程【pool-1-thread-2】工作&gt;&gt;开始线程【pool-1-thread-5】工作&gt;&gt;开始线程【pool-1-thread-3】工作&gt;&gt;开始线程【pool-1-thread-4】工作&gt;&gt;开始线程【pool-1-thread-1】工作&gt;&gt;开始线程【pool-1-thread-4】工作&lt;&lt;结束线程【pool-1-thread-2】工作&lt;&lt;结束线程【pool-1-thread-3】工作&lt;&lt;结束线程【pool-1-thread-1】工作&lt;&lt;结束线程【pool-1-thread-5】工作&lt;&lt;结束所有线程工作已经执行完成！！！


 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十一)Java多线程之CountDownLatch》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十五)Java多线程之ReentrantLock重入锁</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%BA%94)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BReentrantLock%E9%87%8D%E5%85%A5%E9%94%81/</url>
    <content><![CDATA[1.JAVA多线程(十五)Java多线程之ReentrantLock重入锁1.1 什么是ReentrantLock重入锁？&emsp;&emsp; 重入锁：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。
1.2 synchronized和ReentrantLock 的区别
两者都是可重入锁。
synchronized 依赖于 JVM 而 ReentrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。
ReentrantLock 比 synchronized 增加了一些高级功能:


等待可中断：&emsp;&emsp; ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。

可实现公平锁：ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的

可实现选择性通知（锁可以绑定多个条件）synchronized关键字与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。



两者都是可重入锁&emsp;&emsp;JDK5中，synchronized是性能低效的，因为这是一个重量级操作，对性能的最大影响是阻塞的实现，挂起线程和恢复线程的操作，都需要转入内核态中完成，给并发带来了很大压力。JDK6中synchronized加入了自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等一系列优化，官方也支持synchronized，提倡在synchronized能实现需求的前提下，优先考虑synchronized来进行同步。

1.3 ReentrantLock使用样例package com.yuanxw.chapter15;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.stream.IntStream;/** * ReentrantLock重入锁 */public class ReentrantLockExample &#123;    private static final Lock LOCK = new ReentrantLock();    public static void main(String[] args) &#123;        // 创建两个线程        IntStream.range(0, 2).forEach(i -&gt; &#123;            new Thread(() -&gt; testReentrantLock()).start();        &#125;);    &#125;    public static void testReentrantLock() &#123;        try &#123;            LOCK.lock();            System.out.println(String.format(&quot;线程【%s】工作---&gt;开始&quot;, Thread.currentThread().getName()));            TimeUnit.SECONDS.sleep(5);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            LOCK.unlock();            System.out.println(String.format(&quot;线程【%s】工作---&gt;结束&quot;, Thread.currentThread().getName()));        &#125;    &#125;&#125;

执行结果：
线程【Thread-0】工作---&gt;开始线程【Thread-0】工作---&gt;结束线程【Thread-1】工作---&gt;开始线程【Thread-1】工作---&gt;结束
1.4 ReentrantLock源码
构造方法，我们可以看出默认的无参是非公平锁，有参构造true表示公平，false表示非公平。lock()获取锁，其实就是把state从0变成n（重入锁可以累加）。实际调用的是sync的lock方法，分公平和非公平。

/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123;    sync = new NonfairSync();&#125;/** * Creates an instance of &#123;@code ReentrantLock&#125; with the * given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy */public ReentrantLock(boolean fair) &#123;    sync = fair ? new FairSync() : new NonfairSync();&#125;

公平实现：FairSync，我们发现其实调用的是acquire，其实这个是AQS的acquire，然后aqs的acquire的方法里面又会调用tryAcquire方法，因为这个方法需要同步组件自己去实现，所以ReentrantLock里面重写了AQS的tryAcquire方法,所以我们获取到锁就会返回true，没有就会返回false；然后没有获取到锁的线程就交给AQS去处理。

/** * Sync object for fair locks */static final class FairSync extends Sync &#123;    private static final long serialVersionUID = -3000897897090466540L;    final void lock() &#123;        acquire(1);    &#125;    /**     * Fair version of tryAcquire.  Don&#x27;t grant access unless     * recursive call or no waiters or is first.     */    protected final boolean tryAcquire(int acquires) &#123;        // 获取当前的线程        final Thread current = Thread.currentThread();        // 获取锁的状态        int c = getState();        if (c == 0) &#123;            /**              * hasQueuedPredecessors 判断队列还有没有其它node,要保证公平             * 没有在用cas设置状态            **/            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                // 设置获取锁的线程                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        // 判断当前线程有没有获取到锁        else if (current == getExclusiveOwnerThread()) &#123;            // 获取过了就累加，因为可以重入            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error(&quot;Maximum lock count exceeded&quot;);            // 重新设置锁的状态            setState(nextc);            return true;        &#125;        return false;    &#125;&#125;

非公平实现：NonfairSync,我们可以发现基本和公平一样，就没有hasQueuedPredecessors方法，没有遵循FIFO队列的模式，而是不管队列有没有node，自己都可以去获取锁，不需要排队

/** * Sync object for fair locks */static final class FairSync extends Sync &#123;    private static final long serialVersionUID = -3000897897090466540L;    final void lock() &#123;        acquire(1);    &#125;    /**     * Fair version of tryAcquire.  Don&#x27;t grant access unless     * recursive call or no waiters or is first.     */    protected final boolean tryAcquire(int acquires) &#123;        final Thread current = Thread.currentThread();        int c = getState();        if (c == 0) &#123;            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        else if (current == getExclusiveOwnerThread()) &#123;            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error(&quot;Maximum lock count exceeded&quot;);            setState(nextc);            return true;        &#125;        return false;    &#125;&#125;

unlock释放锁：其实就是把state从n（可能发生了锁的重入，需要多次释放）变成0，这个不区分公平与非公平，首先其实也是调用AQS的release方法，然后AQS在调用子类Sync的tryRelease方法。

/** * Attempts to release this lock. * * &lt;p&gt;If the current thread is the holder of this lock then the hold * count is decremented.  If the hold count is now zero then the lock * is released.  If the current thread is not the holder of this * lock then &#123;@link IllegalMonitorStateException&#125; is thrown. * * @throws IllegalMonitorStateException if the current thread does not *         hold this lock */public void unlock() &#123;    sync.release(1);&#125;protected final boolean tryRelease(int releases) &#123;    // 获取锁的状态    int c = getState() - releases;    // 获得锁的线程才能释放锁    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    // 直到锁的状态是0，说明锁释放成功，因为有重入锁    // 说明我们在一个线程里面调用几次lock，就要调用几次unlock，才能最终释放锁    if (c == 0) &#123;        free = true;        // 释放线程的拥有者        setExclusiveOwnerThread(null);    &#125;    // 设置锁的状态    setState(c);    return free;&#125;/** * Releases in exclusive mode.  Implemented by unblocking one or * more threads if &#123;@link #tryRelease&#125; returns true. * This method can be used to implement method &#123;@link Lock#unlock&#125;. * * @param arg the release argument.  This value is conveyed to *        &#123;@link #tryRelease&#125; but is otherwise uninterpreted and *        can represent anything you like. * @return the value returned from &#123;@link #tryRelease&#125; */public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十五)Java多线程之ReentrantLock重入锁》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十八)Java多线程之Executor框架&amp;ThreadPoolExecutor类</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E5%85%AB)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BExecutor%E6%A1%86%E6%9E%B6&amp;ThreadPoolExecutor%E7%B1%BB/</url>
    <content><![CDATA[1.JAVA多线程(十八)Java多线程之Executor框架&amp;ThreadPoolExecutor类&emsp;&emsp; Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。

this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。

在开发中如果需要创建线程可优先考虑使用Executor，无论你需要多线程还是单线程，Executor为你提供了很多其他功能，包括线程状态，生命周期的管理。Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。
1.1 无限制创建线程不足在生产环境中，“为每个任务分配一个线程”这种方法存在一些缺陷，尤其是当需要创建大量线程时：

管理线程的生命周期开销非常高：管理这些线程的生命周期会明显增加 CPU 的执行时间，会消耗大量计算资源。
资源消耗：活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可用的处理器的数量，那么有些线程将闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。如果你已经拥有足够多的线程使所有的CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。
稳定性：创建线程的数量存在一个限制，这个限制将随着平台的不同而不同，并且受多个因素制约，包括jvm的启动参数、Thread构造函数中请求的栈大小，以及底层操作的限制等。如果超过了这个限制，那么很可能抛出OutOfMemoryError异常，这对于运行中的应用来说是非常危险的。

所有的这些因素都会导致系统吞吐量下降。线程池通过保持一些存活线程并重用这些线程来克服这个问题。当提交到线程池中的任务多于线程池最大任务数时，那些多余的任务将被放到一个队列中。 一旦正在执行的线程有空闲了，它们会从队列中取下一个任务来执行。JDK 中的 Executors中， 此任务队列是没有长度限制的。
1.2 Executor的实现关系图Executor框架包括3大部分：

任务：包括被执行的任务需要实现的接口：Runable 接口、Callable接口；Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。
任务的执行：包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口：ThreadPoolExecutor 和 ScheduledThreadPoolExecutor、ForkJoinPool；这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 ThreadPoolExecutor 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。
任务的异步计算结果：包括Future接口和实现Future接口的FutureTask类、ForkJoinTask类，都可以代表异步计算的结果。当我们把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 submit() 方法时会返回一个 FutureTask 对象）

Java优秀框架的设计思路，顶级接口-次级接口-虚拟实现类-实现类。



属性
说明



Executor
执行者，java线程池框架的最上层父接口，地位类似于spring的BeanFactry、集合框架的Collection接口，在Executor这个接口中只有一个execute方法，该方法的作用是向线程池提交任务并执行。


ExecutorService
该接口继承自Executor接口，添加了shutdown、shutdownAll、submit、invokeAll等一系列对线程的操作方法，该接口比较重要，在使用线程池框架的时候，经常用到该接口。


AbstractExecutorService
这是一个抽象类，实现ExecuotrService接口


ThreadPoolExecutor
这是Java线程池最核心的一个类，该类继承自AbstractExecutorService，主要功能是创建线程池，给任务分配线程资源，执行任务。


ScheduledExecutorSerivce
提供了另一种线程池：延迟执行和周期性执行的线程池。


ScheduledThreadPoolExecutor
提供了另一种线程池：延迟执行和周期性执行的线程池。


Executors
这是一个静态工厂类，该类定义了一系列静态工厂方法，通过这些工厂方法可以返回各种不同的线程池。


1.3 ThreadPoolExecutor 类
线程池实现类 ThreadPoolExecutor 是 Executor 框架最核心的类。ThreadPoolExecutor 类中提供的四个构造方法，直接看参数最多的构造方法，其余三个都是在这个构造方法的基础上产生。源代码如下：

/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the *        pool * @param keepAliveTime when the number of threads is greater than *        the core, this is the maximum time that excess idle threads *        will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are *        executed.  This queue will hold only the &#123;@code Runnable&#125; *        tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor *        creates a new thread * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; *         &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize,     // 线程池的核心线程数量，即使空闲时仍保留在池中的线程数，除非设置 allowCoreThreadTimeOut                           int maximumPoolSize,  // 池中允许的最大线程数                           long keepAliveTime,   // 当线程数大于内核时，这是多余的空闲线程在终止前等待新任务的最大时间。                           TimeUnit unit,        // keepAliveTime参数的时间单位                          BlockingQueue&lt;Runnable&gt; workQueue,    // 用于在执行任务之前使用的队列。 这个队列将仅保存execute方法提交的Runnable任务。                           ThreadFactory threadFactory,  // 线程工厂，用来创建线程，一般默认即可                          RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务                          ) &#123;    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.acc = System.getSecurityManager() == null ?            null :            AccessController.getContext();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;&#125;



使用Executors风险：&emsp;&emsp;线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

【说明】：Executors返回的线程池对象的弊端如下： 

FixedThreadPool和SingleThreadPool： 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。 
CachedThreadPool： 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。摘自《阿里巴巴Java开发手册（华山版）》

package com.yuanxw.chapter18;import java.util.Random;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolExecutorExample &#123;    // 随机数：使用long参数的所有64位作为因子值。    private static Random random = new Random(System.currentTimeMillis());    public static void main(String[] args) throws InterruptedException &#123;        /**         * ThreadPoolExecutor 构造函数创建线程池         * int corePoolSize,     // 线程池的核心线程数量，即使空闲时仍保留在池中的线程数，除非设置 allowCoreThreadTimeOut。         * int maximumPoolSize,  // 池中允许的最大线程数。         * long keepAliveTime,   // 当线程数大于内核时，这是多余的空闲线程在终止前等待新任务的最大时间。         * TimeUnit unit,        // keepAliveTime参数的时间单位。         * BlockingQueue&lt;Runnable&gt; workQueue,    // 用于在执行任务之前使用的队列。 这个队列将仅保存execute方法提交的Runnable任务。         * ThreadFactory threadFactory,  // 线程工厂，用来创建线程，一般默认即可。         * RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务。         */        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), r -&gt; new Thread(r), new ThreadPoolExecutor.AbortPolicy());        threadPoolExecutor.execute(() -&gt; processTask(random.nextInt(100)));        threadPoolExecutor.execute(() -&gt; processTask(random.nextInt(100)));        threadPoolExecutor.execute(() -&gt; processTask(random.nextInt(100)));        /**         * shutdown() VS shutdownNow()         * - shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。         * - shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。         */        threadPoolExecutor.shutdown();        int activeCount = -1;        int queueSize = -1;        while (true) &#123;            /**             * isTerminated() VS isShutdown()             * - isShutDown 当调用 shutdown() 方法后返回为 true。             * - isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true。             */            if(threadPoolExecutor.isTerminated())&#123;                break;            &#125;            if (activeCount != threadPoolExecutor.getActiveCount()                    || queueSize != threadPoolExecutor.getQueue().size()) &#123;                System.out.println(&quot;获得活动的线程评估数：&quot; + threadPoolExecutor.getActiveCount());                System.out.println(&quot;核心线程数：&quot; + threadPoolExecutor.getCorePoolSize());                System.out.println(&quot;执行程序使用的任务队列大小：&quot; + threadPoolExecutor.getQueue().size());                System.out.println(&quot;允许的最大线程数：&quot; + threadPoolExecutor.getMaximumPoolSize());                activeCount = threadPoolExecutor.getActiveCount();                queueSize = threadPoolExecutor.getQueue().size();                System.out.println(&quot;--------------------------------------------&quot;);                TimeUnit.SECONDS.sleep(1);            &#125;        &#125;    &#125;    /**     * 线程休眠的方法     *     * @param seconds     */    private static void processTask(long seconds) &#123;        try &#123;            System.out.println(String.format(&quot;&gt;&gt;&gt;&gt;&gt;【%s】线程正在处理任务&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, Thread.currentThread().getName()));            TimeUnit.SECONDS.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
执行结果：
获得活动的线程评估数：2核心线程数：1执行程序使用的任务队列大小：1允许的最大线程数：2--------------------------------------------&gt;&gt;&gt;&gt;&gt;【Thread-0】线程正在处理任务&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;【Thread-1】线程正在处理任务&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;获得活动的线程评估数：1&gt;&gt;&gt;&gt;&gt;【Thread-0】线程正在处理任务&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;核心线程数：1执行程序使用的任务队列大小：0允许的最大线程数：2--------------------------------------------获得活动的线程评估数：0核心线程数：1执行程序使用的任务队列大小：0允许的最大线程数：2--------------------------------------------

1.4 ThreadPoolExecutor线程池原理分析&emsp;&emsp;为了搞懂线程池的原理，我们需要首先分析一下 execute方法。threadPoolExecutor.execute()，来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：
// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// Packing and unpacking ctlprivate static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;/** * The queue used for holding tasks and handing off to worker * threads.  We do not require that workQueue.poll() returning * null necessarily means that workQueue.isEmpty(), so rely * solely on isEmpty to see if the queue is empty (which we must * do for example when deciding whether to transition from * SHUTDOWN to TIDYING).  This accommodates special-purpose * queues such as DelayQueues for which poll() is allowed to * return null even if it may later return non-null when delays * expire. */private final BlockingQueue&lt;Runnable&gt; workQueue;/** * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;. * * @param command the task to execute * @throws RejectedExecutionException at discretion of *         &#123;@code RejectedExecutionHandler&#125;, if the task *         cannot be accepted for execution * @throws NullPointerException if &#123;@code command&#125; is null */public void execute(Runnable command) &#123;    // 如果任务为null，则抛出异常。    if (command == null)        throw new NullPointerException();    /*     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn&#x27;t, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */     // ctl 中保存的线程池当前的一些状态信息    int c = ctl.get();    // 下面会涉及到 3 步 操作    // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize    // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务    if (workerCountOf(c) &lt; corePoolSize) &#123;        if (addWorker(command, true))            return;        c = ctl.get();    &#125;    // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里    // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。        int recheck = ctl.get();        if (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        // 如果当前线程池为空就新创建一个线程并执行。        else if (workerCountOf(recheck) == 0)            addWorker(null, false);    &#125;    // 3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。    // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。    else if (!addWorker(command, false))        reject(command);&#125;
&emsp;&emsp;执行threadPoolExecutor.execute()方法，提交任务效果图，通过下图可以更好的对上面这 3 步做一个展示：

1.5 ThreadPoolExecutor拒绝策略&emsp;&emsp;如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:

ThreadPoolExecutor.AbortPolicy：（默认策略）抛出 RejectedExecutionException异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。
ThreadPoolExecutor.CallerRunsPolicy：（建议使用）调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略当最大池被填满时，此策略为我们提供可伸缩队列。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。
ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。
ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十八)Java多线程之Executor框架&amp;ThreadPoolExecutor类》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十六)Java多线程之Condition对象</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E5%85%AD)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCondition/</url>
    <content><![CDATA[1.JAVA多线程(十六)Java多线程之Condition对象1.1 什么是Condition？&emsp;&emsp; Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，阻塞队列实际上是使用了Condition来模拟线程间协作。
&emsp;&emsp; 我们使用synchronized来控制同步，配合Object的wait()、notify()系列方法可以实现等待&#x2F;通知模式。在Java SE5后，Java提供了Lock接口，相对于Synchronized而言，Lock提供了条件Condition，对线程的等待、唤醒操作更加详细和灵活。下图是Condition与Object的监视器方法的对比（摘自《Java并发编程的艺术》）
1.2 Condition使用样例package com.yuanxw.chapter16;import java.util.Arrays;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ConditionExample &#123;    // 定义【重入锁】非公平锁    private static final ReentrantLock REENTRANT_LOCK = new ReentrantLock();    // 获得Condition实例    private static final Condition CONDITION = REENTRANT_LOCK.newCondition();    // volatile:内存可见性关键字，默认为没有生产，可以进行生产    private static volatile boolean isProducted = false;    // 生产数量    private static int num = 0;    /**     * 生产方法     */    public static void produce() &#123;        try &#123;            // 加锁            REENTRANT_LOCK.lock();            while (isProducted) &#123;                CONDITION.await();            &#125;            // 生产消息数量 + 1            num++;            // 设置为已经生产消息            isProducted = true;            // 通知消费者，可以进行消费            CONDITION.signalAll();            System.out.println(String.format(&quot;线程【%s】，生产消息&gt;&gt;【%s】&quot;, Thread.currentThread().getName(), num));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            // 解锁            REENTRANT_LOCK.unlock();        &#125;    &#125;    /**     * 消息方法     */    public static void consumer() &#123;        // 加锁        try &#123;            REENTRANT_LOCK.lock();            // 如果已经生产，那么消费者消费            while (!isProducted) &#123;                CONDITION.await();            &#125;            System.out.println(String.format(&quot;线程【%s】，消费消息&lt;&lt;&lt;&lt;【%s】&quot;, Thread.currentThread().getName(), num));            // 设置标记：未生产            isProducted = false;            // 通知生产者已经消费            CONDITION.signalAll();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            REENTRANT_LOCK.unlock();        &#125;    &#125;    public static void main(String[] args) &#123;        // 创建两个生产者线程分别为：Produce1、Produce2        Arrays.asList(&quot;Produce1&quot;, &quot;Produce2&quot;).forEach(produceName -&gt; &#123;            new Thread(() -&gt; &#123;                while (true) &#123;                    ConditionExample.produce();                    try &#123;                        TimeUnit.SECONDS.sleep(1);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;,produceName).start();        &#125;);        // 创建三个生产者线程分别为：Consumer1、Consumer2、Consumer3        Arrays.asList(&quot;Consumer1&quot;, &quot;Consumer2&quot;, &quot;Consumer3&quot;).forEach(consumerName -&gt; &#123;            new Thread(() -&gt; &#123;                while (true) &#123;                    ConditionExample.consumer();                    try &#123;                        TimeUnit.SECONDS.sleep(1);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;,consumerName).start();        &#125;);    &#125;&#125;
执行结果：
线程【Produce1】，生产消息&gt;&gt;【1】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【1】线程【Produce2】，生产消息&gt;&gt;【2】线程【Consumer2】，消费消息&lt;&lt;&lt;&lt;【2】线程【Produce1】，生产消息&gt;&gt;【3】线程【Consumer3】，消费消息&lt;&lt;&lt;&lt;【3】线程【Produce2】，生产消息&gt;&gt;【4】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【4】线程【Produce1】，生产消息&gt;&gt;【5】线程【Consumer2】，消费消息&lt;&lt;&lt;&lt;【5】线程【Produce2】，生产消息&gt;&gt;【6】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【6】线程【Produce1】，生产消息&gt;&gt;【7】线程【Consumer3】，消费消息&lt;&lt;&lt;&lt;【7】线程【Produce2】，生产消息&gt;&gt;【8】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【8】线程【Produce2】，生产消息&gt;&gt;【9】线程【Consumer2】，消费消息&lt;&lt;&lt;&lt;【9】线程【Produce1】，生产消息&gt;&gt;【10】线程【Consumer1】，消费消息&lt;&lt;&lt;&lt;【10】

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十六)Java多线程之Condition对象》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(十四)Java多线程之Semaphore信号量</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E5%9B%9B)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSemaphore%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[1.JAVA多线程(十四)Java多线程之Semaphore信号量&emsp;&emsp; Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。把它比作是控制流量的红绿灯，比如一条马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入马路，但是如果前一百辆中有五辆车已经离开了马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。
1.1 Semaphore(信号量)-允许多个线程同时访问&emsp;&emsp; 执行 acquire 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 release 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。
&emsp;&emsp; 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10，代码如下：
package com.yuanxw.chapter14;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;public class SemaphoreExample &#123;    /** 随机数：使用long参数的所有64位作为因子值。 **/    private static Random random = new Random(System.currentTimeMillis());    /** 总线程数 **/    private static final int TOTAL_THREAD_NUMBER = 10;    /** 允许执行的线程数 **/    final static int ACQUIRE_THREAD_NUMBER = 3;    public static void main(String[] args) throws InterruptedException &#123;        Semaphore semaphore = new Semaphore(ACQUIRE_THREAD_NUMBER);        ExecutorService executorService = Executors.newFixedThreadPool(TOTAL_THREAD_NUMBER);        IntStream.range(0,TOTAL_THREAD_NUMBER).forEach(i -&gt; &#123;            executorService.execute(()-&gt;&#123;                try &#123;                    System.out.println(String.format(&quot;线程【%s】&gt;&gt;&gt;&gt;准备工作&quot;, Thread.currentThread().getName()));                    semaphore.acquire();                    System.out.println(String.format(&quot;线程【%s】工作===&gt;开始&quot;, Thread.currentThread().getName()));                    TimeUnit.SECONDS.sleep(random.nextInt(5));                    System.out.println(String.format(&quot;线程【%s】工作&lt;====结束&quot;, Thread.currentThread().getName()));                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    semaphore.release();                &#125;            &#125;);        &#125;);        executorService.shutdown();        // main线程监控信号量中许可数变化        while (true) &#123;            if(executorService.isTerminated())&#123;break;&#125;            System.out.println(&quot;信号量中当前可用的许可数：&quot; + semaphore.availablePermits());            System.out.println(&quot;等待获取的线程数:&quot; + semaphore.getQueueLength());            TimeUnit.SECONDS.sleep(1);        &#125;    &#125;&#125;

执行结果：
信号量中当前可用的许可数：3等待获取的线程数:0线程【pool-1-thread-6】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-5】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-7】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-1】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-3】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-8】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-7】工作===&gt;开始线程【pool-1-thread-5】工作===&gt;开始线程【pool-1-thread-6】工作===&gt;开始线程【pool-1-thread-2】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-4】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-9】&gt;&gt;&gt;&gt;准备工作线程【pool-1-thread-10】&gt;&gt;&gt;&gt;准备工作信号量中当前可用的许可数：0等待获取的线程数:7信号量中当前可用的许可数：0等待获取的线程数:7线程【pool-1-thread-5】工作&lt;====结束线程【pool-1-thread-6】工作&lt;====结束线程【pool-1-thread-7】工作&lt;====结束线程【pool-1-thread-3】工作===&gt;开始线程【pool-1-thread-1】工作===&gt;开始线程【pool-1-thread-8】工作===&gt;开始信号量中当前可用的许可数：0等待获取的线程数:4信号量中当前可用的许可数：0等待获取的线程数:4线程【pool-1-thread-8】工作&lt;====结束线程【pool-1-thread-1】工作&lt;====结束线程【pool-1-thread-3】工作&lt;====结束线程【pool-1-thread-2】工作===&gt;开始线程【pool-1-thread-4】工作===&gt;开始线程【pool-1-thread-9】工作===&gt;开始信号量中当前可用的许可数：0等待获取的线程数:1信号量中当前可用的许可数：0等待获取的线程数:1线程【pool-1-thread-4】工作&lt;====结束线程【pool-1-thread-2】工作&lt;====结束线程【pool-1-thread-9】工作&lt;====结束线程【pool-1-thread-10】工作===&gt;开始信号量中当前可用的许可数：2等待获取的线程数:0信号量中当前可用的许可数：2等待获取的线程数:0线程【pool-1-thread-10】工作&lt;====结束
1.3 Semaphore(信号量)-构造Lock锁Semaphore类其实就是synchronized关键字的升级版，这个类主要作用就是控制线程并发的数量。当我们把许可的数量设置为1时，就变成了同步锁.
package com.yuanxw.chapter14;import java.util.Random;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import java.util.stream.IntStream;/** * 信号量锁 */public class SemaphoreExampleV2 &#123;    /**     * 随机数：使用long参数的所有64位作为因子值。     **/    private static Random random = new Random(System.currentTimeMillis());    public static void main(String[] args) &#123;        final SemaphoreLock semaphoreLock = new SemaphoreLock();        IntStream.range(0, 5).forEach(i -&gt; &#123;            new Thread(() -&gt; &#123;                try &#123;                    System.out.println(String.format(&quot;线程【%s】已经开始工作&quot;, Thread.currentThread().getName()));                    semaphoreLock.lock();                    System.out.println(String.format(&quot;线程【%s】获得锁&quot;, Thread.currentThread().getName()));                    TimeUnit.SECONDS.sleep(random.nextInt(5));                    System.out.println(String.format(&quot;线程【%s】已经释放锁&quot;, Thread.currentThread().getName()));                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    semaphoreLock.unLock();                &#125;            &#125;).start();        &#125;);    &#125;    static class SemaphoreLock &#123;        /**         * 在JDK1.8，需要加上volatile关键字         * 构造一个 Semaphore与给只有一个数量的许可证         **/        private volatile static  Semaphore semaphore = new Semaphore(1);        /**         * 加锁方法         *         * @throws InterruptedException         */        public void lock() throws InterruptedException &#123;            semaphore.acquire(1);        &#125;        /**         * 解锁方法         */        public void unLock() &#123;            semaphore.release(1);        &#125;    &#125;&#125;
执行结果：
线程【Thread-1】已经开始工作线程【Thread-3】已经开始工作线程【Thread-0】已经开始工作线程【Thread-4】已经开始工作线程【Thread-2】已经开始工作线程【Thread-1】获得锁线程【Thread-1】已经释放锁线程【Thread-0】获得锁线程【Thread-0】已经释放锁线程【Thread-3】获得锁线程【Thread-3】已经释放锁线程【Thread-4】获得锁线程【Thread-4】已经释放锁线程【Thread-2】获得锁线程【Thread-2】已经释放锁

1.3 Semaphore(信号量)JDK源码-构造方法Semaphore这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。

公平模式： 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；
抢占式：  有可能一个新的获取线程恰好在一个许可证释放时得到了这个许可证，而前面还有等待的线程。

/** * Creates a &#123;@code Semaphore&#125; with the given number of * permits and nonfair fairness setting. * * @param permits the initial number of permits available. *        This value may be negative, in which case releases *        must occur before any acquires will be granted. */public Semaphore(int permits) &#123;    sync = new NonfairSync(permits);&#125;/** * Creates a &#123;@code Semaphore&#125; with the given number of * permits and the given fairness setting. * * @param permits the initial number of permits available. *        This value may be negative, in which case releases *        must occur before any acquires will be granted. * @param fair &#123;@code true&#125; if this semaphore will guarantee *        first-in first-out granting of permits under contention, *        else &#123;@code false&#125; */public Semaphore(int permits, boolean fair) &#123;    sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125;

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(十四)Java多线程之Semaphore》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程(四)Java多线程之join等待结束</title>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bjoin%E7%AD%89%E5%BE%85%E7%BB%93%E6%9D%9F/</url>
    <content><![CDATA[1.JAVA多线程(四)Java多线程之join等待结束1.1 join(等待结束)&emsp;&emsp;join()方法的作用，是等待这个线程结束；
也就是说，thread.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程thread完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。
package com.yuanxw.chapter4;public class ThreadJoin &#123;    public static void main(String[] args) throws InterruptedException &#123;        long startTime = System.currentTimeMillis();        Thread thread1 = new Thread(new SyncDatabase(&quot;T1&quot;,&quot;192.168.185.26&quot;,1000L));        Thread thread2 = new Thread(new SyncDatabase(&quot;T2&quot;,&quot;192.168.185.27&quot;,1500L));        Thread thread3 = new Thread(new SyncDatabase(&quot;T3&quot;,&quot;192.168.185.28&quot;,2500L));        thread1.start();        thread2.start();        thread3.start();        // 等待【thread1、thread2、thread3】对象线程死亡（结束）        thread1.join();        thread2.join();        thread3.join();        long endTime = System.currentTimeMillis();        System.out.println(String.format(&quot;所有服务器数据同步完成，共耗时【%s】毫秒&quot;,endTime - startTime ));    &#125;&#125;/** * 同步数据库数据 */class SyncDatabase implements Runnable&#123;    /** 同步服务器名称 **/    private String serviceName;    /** 同步服务IP地址 **/    private String ipAddr;    /** 同步时间 **/    private long syncTime;    public SyncDatabase(String serviceName, String ipAddr, long syncTime) &#123;        this.serviceName = serviceName;        this.ipAddr = ipAddr;        this.syncTime = syncTime;    &#125;    @Override    public void run() &#123;        try &#123;            Thread.sleep(syncTime);            System.out.println(String.format(&quot;同步【%s】服务器，IP地址【%s】，数据同步完成，共耗时【%s】毫秒&quot;, serviceName,ipAddr,syncTime));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
执行结果：
同步【T1】服务器，IP地址【192.168.185.26】，数据同步完成，共耗时【1000】毫秒同步【T2】服务器，IP地址【192.168.185.27】，数据同步完成，共耗时【1500】毫秒同步【T3】服务器，IP地址【192.168.185.28】，数据同步完成，共耗时【2500】毫秒所有服务器数据同步完成，共耗时【2502】毫秒

 &emsp;&emsp;&emsp;&emsp;– 以上为《JAVA多线程(四)Java多线程之join等待结束》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。  ——厚积薄发(yuanxw)
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka源码分析(一)环境搭建</title>
    <url>/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[Kafka源码分析(一)环境搭建一、前言源码的思路是先分析老版本，再分析新版本。因为老版本的架构是稳定的，基础特性都是有的。最后我们对比Feature提升对Kafka理解。由浅入深：假设我们认为Kafka是一个单体的，首先分析一条消息从Producer发到Kafka再到Consumer的一个消费，再到集群的处理的消费。
二、前置条件2.1 安装和配置JDK
JDK配置要求JDK1.8，使用java -version命令来查看当前JDK的版本，示例如下：
  C:\Users\yuanxw&gt;java -versionjava version &quot;1.8.0_241&quot;Java(TM) SE Runtime Environment (build 1.8.0_241-b07)Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode)

2.2 下载并安装配置Gradle
下载地址为：https://gradle.org/releases/，笔者使用的版本是5.6.4。一般只需要将下载的包解压，然后再将GRADLE_HOME&#x2F;bin的路径添加到环境变量Path中即可，其中;GRADLE_HOME指的是Gradle的根目录。可以使用gradle -v命令来验证Gradle是否已经配置完成，示例如下：
  C:\Users\yuanxw&gt;gradle -vWelcome to Gradle 5.6.4!Here are the highlights of this release: - Incremental Groovy compilation - Groovy compile avoidance - Test fixtures for Java projects - Manage plugin versions via settings scriptFor more details see https://docs.gradle.org/5.6.4/release-notes.html------------------------------------------------------------Gradle 5.6.4------------------------------------------------------------Build time:   2019-11-01 20:42:00 UTCRevision:     dd870424f9bd8e195d614dc14bb140f43c22da98Kotlin:       1.3.41Groovy:       2.5.4Ant:          Apache Ant(TM) version 1.9.14 compiled on March 12 2019JVM:          1.8.0_241 (Oracle Corporation 25.241-b07)OS:           Windows 10 10.0 amd64

2.3 下载并安装配置Scala
在win上安装Scala 2.10.6，上官网找到2.10.6版本对应的下载地址，kafka的服务器端的源码是scala写的，但是新版本的客户端的源码是java写的https://www.scala-lang.org/download/2.10.6.html然后就可以下载win上的安装包，scala.msi，下载好之后傻瓜式安装就可以了，接着必须配置SCALA_HOME和PATH两个环境变量，首先必须得有Java和Scala两种编程语言的支持才可以。
  C:\Users\yuanxw&gt;scala -versionScala code runner version 2.10.6 -- Copyright 2002-2013, LAMP/EPFL

2.4 构建Kafka源码环境
在GitHub上fork一份kafka源码到自已仓库，从自己的仓库中下载，下载地址：https://github.com/apache/kafka.git
  # 在 E： 盘新建一个 kafka 目录，然后把 Kafka 项目 Clone 到这里。(作者位置：E:\workspace\IdeaWork\github)E:\workspace\IdeaWork\github&gt;**git clone git@github.com:yuanxw/kafka.git**Cloning into &#x27;kafka&#x27;...remote: Enumerating objects: 451197, done.remote: Total 451197 (delta 0), reused 0 (delta 0), pack-reused 451197 (from 1)Receiving objects: 100% (451197/451197), 227.47 MiB | 81.00 KiB/s, done.Resolving deltas: 100% (220962/220962), done.Updating files: 100% (6890/6890), done.# 切换到 0.10.2 版本*git checkout origin/0.10.2

Gradle 构建 Kafka 项目之前确认事项：

确保 gradle.properties 配置文件中的 scalaVersion 与 Windows 中 Scala 版本一致，0.10.2 版本的 Kafka 是 2.10.6 版本的 Scala。
 group=org.apache.kafka# NOTE: When you change this version number, you should also make sure to update# the version numbers in tests/kafkatest/__init__.py and kafka-merge-pr.py.version=0.10.2.3-SNAPSHOTscalaVersion=2.10.6task=buildorg.gradle.jvmargs=-XX:MaxPermSize=512m -Xmx1024m -Xss2m

配置 Gradle 的仓库为阿里的镜像仓库

改之前遇到的错误：

 E:\workspace\IdeaWork\github\kafka&gt;gradle ideaStarting a Gradle Daemon (subsequent builds will be faster)&gt; Configure project :[Fatal Error] gradle-versions-plugin-0.13.0.pom:7:3: 元素类型 &quot;hr&quot; 必须由匹配的结束标记 &quot;&lt;/hr&gt;&quot; 终止。FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring root project &#x27;kafka&#x27;.&gt; Could not resolve all artifacts for configuration &#x27;:classpath&#x27;.   &gt; Could not resolve com.github.ben-manes:gradle-versions-plugin:0.13.0.     Required by:         project :      &gt; Could not resolve com.github.ben-manes:gradle-versions-plugin:0.13.0.         &gt; Could not parse POM http://dl.bintray.com/content/netflixoss/external-gradle-plugins/com/github/ben-manes/gradle-versions-plugin/0.13.0/gradle-versions-plugin-0.13.0.pom            &gt; 元素类型 &quot;hr&quot; 必须由匹配的结束标记 &quot;&lt;/hr&gt;&quot; 终止。* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 12s

修改 org.scoverage:gradle-scoverage 的版本号
 dependencies &#123;  // For Apache Rat plugin to ignore non-Git files  classpath &quot;org.ajoberstar:grgit:1.7.0&quot;  classpath &#x27;com.github.ben-manes:gradle-versions-plugin:0.13.0&#x27;    // 这里原来是 2.1.0 修改为 2.5.0  // classpath &#x27;org.scoverage:gradle-scoverage:2.1.0&#x27;  classpath &#x27;org.scoverage:gradle-scoverage:2.5.0&#x27;  &#125;

改之前遇到的错误：

 &gt; Configure project :\github\kafka&gt;gradle ideaBuilding project &#x27;core&#x27; with Scala version 2.10.6FAILURE: Build failed with an exception.* Where:Build file &#x27;E:\workspace\IdeaWork\github\kafka\build.gradle&#x27; line: 388* What went wrong:A problem occurred evaluating root project &#x27;kafka&#x27;.&gt; Failed to apply plugin [id &#x27;org.scoverage&#x27;]   &gt; Could not create an instance of type org.scoverage.ScoverageExtension.      &gt; You can&#x27;t map a property that does not exist: propertyName=testClassesDir* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgDeprecated Gradle features were used in this build, making it incompatible with Gradle 6.0.Use &#x27;--warning-mode all&#x27; to show the individual deprecation warnings.See https://docs.gradle.org/5.6.4/userguide/command_line_interface.html#sec:command_line_warningsBUILD FAILED in 1s

修改好上面的文件之后就可以在 kafka 根目录直接执行 gradle idea，等成功之后就可以用 IDEA 打开了。
 E:\workspace\IdeaWork\github\kafka&gt;gradle idea&gt; Configure project :Building project &#x27;core&#x27; with Scala version 2.10.6&gt; Task :ideaGenerated IDEA project at file:///E:/workspace/IdeaWork/github/kafka/kafka.iprDeprecated Gradle features were used in this build, making it incompatible with Gradle 6.0.Use &#x27;--warning-mode all&#x27; to show the individual deprecation warnings.See https://docs.gradle.org/5.6.4/userguide/command_line_interface.html#sec:command_line_warningsBUILD SUCCESSFUL in 3m 19s19 actionable tasks: 19 executed
 




2.5 Idea配置Kafka源码环境
IDEA 安装 Scala 插件，在 File -&gt; Settings -&gt; Plugin 中搜索 Scala 并安装。
  

配置 Scala SDK，在 File -&gt; Settings -&gt; ProjectStructure
  

将 config 目录下的 log4j.properties 文件拷贝到 core&#x2F;src&#x2F;main&#x2F;scala 目录下，这样可以让 Kafka 在运行时能够输出日志信息。
  

配置 server.properties 文件
  # 开启这个功能方便Kafka在运行一段时间之后，能够删除一些不需要的临时topicdelete.topic.enable=true# 禁用自动创建topic的功能auto.create.topics.enable=false# 在Windows环境下运行，所以需要修改这个配置，注意这里的双反斜杠log.dirs=E:\\workspace\\IdeaWork\\github\\kafka\\tmp\\kafka-logs# 配置kafka依赖的zookeeper路径地址，这里的前提是在本地开启了一个zookeeper的服务zookeeper.connect=localhost:2181/kafka

2.6 Zookeeper的安装、配置及启动Kafka需要使用Zookeeper来管理元数据，比如记录topic、partitions（分区）以及replica（副本）的分配信息。由于这里只是阐述如何构建Kafka的源码环境搭建，所以这里的Zookeeper的安装也以极简为主，即采用单机配置。Zookeeper下载地址为：http://zookeeper.apache.org/releases.html，下载之后解压，然后将**$ZOOKEEPER_HOME目录下的conf&#x2F;zoo_sample.cfg重命名为zoo.cfg，其中$ZOOKEEPER_HOME**指的是ZooKeeper的根目录。
修改**$ZOOKEEPER_HOME**&#x2F;conf&#x2F;zoo.cfg配置，示例配置如下（其余配置可以不做修改）：

本地下载Zookeeper

下载版本：apache-zookeeper-3.6.1
修改配置：dataDir&#x3D;D:\software\apache-zookeeper-3.6.1\data


配置zookeeper环境变量
  将$ZOOKEEPER_HOME&#x2F;bin配置到Path中，之后直接运行zkServer命令即可开启Zookeeper服务。示例如下：
  C:\Users\yuanxw&gt;zkServerC:\Users\yuanxw&gt;call &quot;D:\software\Java\jdk1.8\jdk1.8.0_241&quot;\bin\java &quot;-Dzookeeper.log.dir=D:\software\apache-zookeeper-3.6.1\bin\..\logs&quot; &quot;-Dzookeeper.root.logger=INFO,CONSOLE&quot; &quot;-Dzookeeper.log.file=zookeeper-yuanxw-server-DESKTOP-EDMKNEI.log&quot; &quot;-XX:+HeapDumpOnOutOfMemoryError&quot; &quot;-XX:OnOutOfMemoryError=cmd /c taskkill /pid %%p /t /f&quot; -cp &quot;D:\software\apache-zookeeper-3.6.1\bin\..\build\classes;D:\software\apache-zookeeper-3.6.1\bin\..\build\lib\*;D:\software\apache-zookeeper-3.6.1\bin\..\*;D:\software\apache-zookeeper-3.6.1\bin\..\lib\*;D:\software\apache-zookeeper-3.6.1\bin\..\conf&quot; org.apache.zookeeper.server.quorum.QuorumPeerMain &quot;D:\software\apache-zookeeper-3.6.1\bin\..\conf\zoo.cfg&quot;2025-07-13 12:03:32,539 [myid:] - INFO  [main:QuorumPeerConfig@173] - Reading configuration from: D:\software\apache-zookeeper-3.6.1\bin\..\conf\zoo.cfg2025-07-13 12:03:32,566 [myid:] - INFO  [main:QuorumPeerConfig@459] - clientPortAddress is 0.0.0.0:21812025-07-13 12:03:32,567 [myid:] - INFO  [main:QuorumPeerConfig@463] - secureClientPort is not set2025-07-13 12:03:32,567 [myid:] - INFO  [main:QuorumPeerConfig@479] - observerMasterPort is not set2025-07-13 12:03:32,569 [myid:] - INFO  [main:QuorumPeerConfig@496] - metricsProvider.className is org.apache.zookeeper.metrics.impl.DefaultMetricsProvider2025-07-13 12:03:32,570 [myid:] - INFO  [main:DatadirCleanupManager@78] - autopurge.snapRetainCount set to 32025-07-13 12:03:32,570 [myid:] - INFO  [main:DatadirCleanupManager@79] - autopurge.purgeInterval set to 02025-07-13 12:03:32,570 [myid:] - INFO  [main:DatadirCleanupManager@101] - Purge task is not scheduled.2025-07-13 12:03:32,570 [myid:] - WARN  [main:QuorumPeerMain@138] - Either no config or no quorum defined in config, running in standalone mode2025-07-13 12:03:32,574 [myid:] - INFO  [main:ManagedUtil@44] - Log4j 1.2 jmx support found and enabled.2025-07-13 12:03:32,630 [myid:] - INFO  [main:QuorumPeerConfig@173] - Reading configuration from: D:\software\apache-zookeeper-3.6.1\bin\..\conf\zoo.cfg2025-07-13 12:03:32,631 [myid:] - INFO  [main:QuorumPeerConfig@459] - clientPortAddress is 0.0.0.0:21812025-07-13 12:03:32,631 [myid:] - INFO  [main:QuorumPeerConfig@463] - secureClientPort is not set2025-07-13 12:03:32,632 [myid:] - INFO  [main:QuorumPeerConfig@479] - observerMasterPort is not set2025-07-13 12:03:32,632 [myid:] - INFO  [main:QuorumPeerConfig@496] - metricsProvider.className is org.apache.zookeeper.metrics.impl.DefaultMetricsProvider2025-07-13 12:03:32,632 [myid:] - INFO  [main:ZooKeeperServerMain@122] - Starting server2025-07-13 12:03:32,680 [myid:] - INFO  [main:ServerMetrics@62] - ServerMetrics initialized with provider org.apache.zookeeper.metrics.impl.DefaultMetricsProvider@7a929222025-07-13 12:03:32,683 [myid:] - INFO  [main:FileTxnSnapLog@124] - zookeeper.snapshot.trust.empty : false2025-07-13 12:03:32,691 [myid:] - INFO  [main:ZookeeperBanner@42] -2025-07-13 12:03:32,691 [myid:] - INFO  [main:ZookeeperBanner@42] -   ______                  _2025-07-13 12:03:32,691 [myid:] - INFO  [main:ZookeeperBanner@42] -  |___  /                 | |2025-07-13 12:03:32,692 [myid:] - INFO  [main:ZookeeperBanner@42] -     / /    ___     ___   | | __   ___    ___   _ __     ___   _ __2025-07-13 12:03:32,692 [myid:] - INFO  [main:ZookeeperBanner@42] -    / /    / _ \   / _ \  | |/ /  / _ \  / _ \ | &#x27;_ \   / _ \ | &#x27;__|2025-07-13 12:03:32,692 [myid:] - INFO  [main:ZookeeperBanner@42] -   / /__  | (_) | | (_) | |   &lt;  |  __/ |  __/ | |_) | |  __/ | |2025-07-13 12:03:32,693 [myid:] - INFO  [main:ZookeeperBanner@42] -  /_____|  \___/   \___/  |_|\_\  \___|  \___| | .__/   \___| |_|2025-07-13 12:03:32,693 [myid:] - INFO  [main:ZookeeperBanner@42] -                                               | |2025-07-13 12:03:32,693 [myid:] - INFO  [main:ZookeeperBanner@42] -                                               |_|2025-07-13 12:03:32,694 [myid:] - INFO  [main:ZookeeperBanner@42] -2025-07-13 12:03:32,705 [myid:] - INFO  [main:Environment@98] - Server environment:zookeeper.version=3.6.1--104dcb3e3fb464b30c5186d229e00af9f332524b, built on 04/21/2020 15:01 GMT2025-07-13 12:03:32,705 [myid:] - INFO  [main:Environment@98] - Server environment:host.name=DESKTOP-EDMKNEI2025-07-13 12:03:32,705 [myid:] - INFO  [main:Environment@98] - Server environment:java.version=1.8.0_2412025-07-13 12:03:32,706 [myid:] - INFO  [main:Environment@98] - Server environment:java.vendor=Oracle Corporation2025-07-13 12:03:32,708 [myid:] - INFO  [main:Environment@98] - Server environment:java.home=D:\software\Java\jdk1.8\jdk1.8.0_241\jre2025-07-13 12:03:32,874 [myid:] - INFO  [main:ContextHandler@825] - Started o.e.j.s.ServletContextHandler@887af79&#123;/,null,AVAILABLE&#125;2025-07-13 12:03:33,262 [myid:] - INFO  [main:AbstractConnector@330] - Started ServerConnector@57baeedf&#123;HTTP/1.1,[http/1.1]&#125;&#123;0.0.0.0:8080&#125;2025-07-13 12:03:33,263 [myid:] - INFO  [main:Server@399] - Started @925ms2025-07-13 12:03:33,264 [myid:] - INFO  [main:JettyAdminServer@178] - Started AdminServer on address 0.0.0.0, port 8080 and command URL /commands2025-07-13 12:03:33,268 [myid:] - INFO  [main:ServerCnxnFactory@169] - Using org.apache.zookeeper.server.NIOServerCnxnFactory as server connection factory2025-07-13 12:03:33,269 [myid:] - WARN  [main:ServerCnxnFactory@309] - maxCnxns is not configured, using default value 0.2025-07-13 12:03:33,271 [myid:] - INFO  [main:NIOServerCnxnFactory@666] - Configuring NIO connection handler with 10s sessionless connection timeout, 2 selector thread(s), 16 worker threads, and 64 kB direct buffers.2025-07-13 12:03:33,272 [myid:] - INFO  [main:NIOServerCnxnFactory@674] - binding to port 0.0.0.0/0.0.0.0:21812025-07-13 12:03:33,285 [myid:] - INFO  [main:WatchManagerFactory@42] - Using org.apache.zookeeper.server.watch.WatchManager as watch manager2025-07-13 12:03:33,286 [myid:] - INFO  [main:WatchManagerFactory@42] - Using org.apache.zookeeper.server.watch.WatchManager as watch manager2025-07-13 12:03:33,286 [myid:] - INFO  [main:ZKDatabase@132] - zookeeper.snapshotSizeFactor = 0.332025-07-13 12:03:33,286 [myid:] - INFO  [main:ZKDatabase@152] - zookeeper.commitLogCount=5002025-07-13 12:03:33,290 [myid:] - INFO  [main:SnapStream@61] - zookeeper.snapshot.compression.method = CHECKED2025-07-13 12:03:33,291 [myid:] - INFO  [main:FileSnap@85] - Reading snapshot D:\software\apache-zookeeper-3.6.1\data\version-2\snapshot.02025-07-13 12:03:33,293 [myid:] - INFO  [main:DataTree@1737] - The digest value is empty in snapshot2025-07-13 12:03:33,298 [myid:] - INFO  [main:ZKDatabase@289] - Snapshot loaded in 11 ms, highest zxid is 0x0, digest is 13719855042025-07-13 12:03:33,299 [myid:] - INFO  [main:FileTxnSnapLog@470] - Snapshotting: 0x0 to D:\software\apache-zookeeper-3.6.1\data\version-2\snapshot.02025-07-13 12:03:33,301 [myid:] - INFO  [main:ZooKeeperServer@519] - Snapshot taken in 2 ms2025-07-13 12:03:33,315 [myid:] - INFO  [main:RequestThrottler@74] - zookeeper.request_throttler.shutdownTimeout = 100002025-07-13 12:03:33,326 [myid:] - INFO  [main:ContainerManager@83] - Using checkIntervalMs=60000 maxPerMinute=10000 maxNeverUsedIntervalMs=02025-07-13 12:03:33,328 [myid:] - INFO  [main:ZKAuditProvider@42] - ZooKeeper audit is disabled.

]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Kafka源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka源码分析(三)Sender线程获取metadata数据</title>
    <url>/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)Sender%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96metadata%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[Kafka源码分析(三)Sender线程获取metadata数据一、前言
前面KafkaProducer 类里面开启sender线程。

private KafkaProducer(ProducerConfig config, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer) &#123;// .....省略....// 启动Kafka网络线程this.ioThread = new KafkaThread(ioThreadName, this.sender, true);this.ioThread.start();// .....省略....

二、Sender线程执行流程图

sequenceDiagram
autonumber
KafkaProducer -&gt;&gt; Sender: ioThread.start()
Sender-&gt;&gt;Sender: run()多线程方法
loop while (running)[死循环]
    Sender-&gt;&gt;Sender: 获取当前集群metadata信息 metadata.fetch();
    Sender-&gt;&gt;Sender: 获取已准备好发送数据的分区请求
    Sender-&gt;&gt;Sender: 创建批次请求this.accumulator.drain
    Sender-&gt;&gt;Sender: 保证消息顺序，guaranteeMessageOrder：false
    Sender-&gt;&gt;Sender: 准备待发送请求的数据，sendProduceRequests(batches, now);
    Sender-&gt;&gt;NetworkClient: this.client.poll(pollTimeout, now);
    NetworkClient-&gt;&gt; NetworkClient: 封装要拉取元数据的请求metadataUpdater.maybeUpdate(now);
    NetworkClient-&gt;&gt; Selector: 阻塞等待，直到有可用连接或超时select(timeout);
end



三、源代码分析
Sender线程的run方法被执行

	/**  * producer线程的主 run 循环  */ public void run() &#123;     log.debug(&quot;Starting Kafka producer I/O thread.&quot;);     // main 循环，一直运行直到调用 close     while (running) &#123;         try &#123;             run(time.milliseconds());         &#125; catch (Exception e) &#123;             log.error(&quot;Uncaught error in kafka producer I/O thread: &quot;, e);         &#125;     &#125;     log.debug(&quot;Beginning shutdown of Kafka producer I/O thread, sending remaining records.&quot;);     // okay we stopped accepting requests but there may still be     // requests in the accumulator or waiting for acknowledgment,     // wait until these are completed.     while (!forceClose &amp;&amp; (this.accumulator.hasUnsent() || this.client.inFlightRequestCount() &gt; 0)) &#123;         try &#123;             run(time.milliseconds());         &#125; catch (Exception e) &#123;             log.error(&quot;Uncaught error in kafka producer I/O thread: &quot;, e);         &#125;     &#125;     if (forceClose) &#123;         // We need to fail all the incomplete batches and wake up the threads waiting on         // the futures.         this.accumulator.abortIncompleteBatches();     &#125;     try &#123;         this.client.close();     &#125; catch (Exception e) &#123;         log.error(&quot;Failed to close network client&quot;, e);     &#125;     log.debug(&quot;Shutdown of Kafka producer I/O thread has completed.&quot;); &#125;

/** * Run a single iteration of sending *  * @param now *            The current POSIX time in milliseconds */void run(long now) &#123;    // 获取当前集群metadata信息    Cluster cluster = metadata.fetch();    // 获取已准备好发送数据的节点    RecordAccumulator.ReadyCheckResult result = this.accumulator.ready(cluster, now);    // 如果有任何分区的 leader 尚不清楚，则强制元数据更新。第一次执行topic，不会走    if (!result.unknownLeaderTopics.isEmpty()) &#123;        // The set of topics with unknown leader contains topics with leader election pending as well as        // topics which may have expired. Add the topic again to metadata to ensure it is included        // and request metadata update, since there are messages to send to the topic.        for (String topic : result.unknownLeaderTopics)            this.metadata.add(topic);        this.metadata.requestUpdate();    &#125;    // 判断节点有没有准备好，并移除没有准备的节点    // remove any nodes we aren&#x27;t ready to send to    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();    long notReadyTimeout = Long.MAX_VALUE;    while (iter.hasNext()) &#123;        Node node = iter.next();        if (!this.client.ready(node, now)) &#123;            iter.remove();            notReadyTimeout = Math.min(notReadyTimeout, this.client.connectionDelay(node, now));        &#125;    &#125;    // 创建批次请求    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = this.accumulator.drain(cluster,                                                                     result.readyNodes,                                                                     this.maxRequestSize,                                                                     now);    // 保证消息顺序，第一次执行guaranteeMessageOrder为false，不会走    if (guaranteeMessageOrder) &#123;        // Mute all the partitions drained        for (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;            for (RecordBatch batch : batchList)                this.accumulator.mutePartition(batch.topicPartition);        &#125;    &#125;    // 检查超时的批次，第一次执行没expiredBatches为空    List&lt;RecordBatch&gt; expiredBatches = this.accumulator.abortExpiredBatches(this.requestTimeout, now);    // 更新超时批次的错误计数    for (RecordBatch expiredBatch : expiredBatches)        this.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);    sensors.updateProduceRequestMetrics(batches);    // If we have any nodes that are ready to send + have sendable data, poll with 0 timeout so this can immediately    // loop and try sending more data. Otherwise, the timeout is determined by nodes that have partitions with data    // that isn&#x27;t yet sendable (e.g. lingering, backing off). Note that this specifically does not include nodes    // with sendable data that aren&#x27;t ready to send since they would cause busy looping.    long pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);    if (!result.readyNodes.isEmpty()) &#123;        log.trace(&quot;Nodes with data ready to send: &#123;&#125;&quot;, result.readyNodes);        pollTimeout = 0;    &#125;    // 准备待发送请求的数据    sendProduceRequests(batches, now);    // 执行网络请求    // if some partitions are already ready to be sent, the select time would be 0;    // otherwise if some partition already has some data accumulated but not ready yet,    // the select time will be the time difference between now and its linger expiry time;    // otherwise the select time will be the time difference between now and the metadata expiry time;    this.client.poll(pollTimeout, now);&#125;


拉取元数据的请求，在第一次执行的时候，不会返回任何的数据

/** * Do actual reads and writes to sockets. * * @param timeout The maximum amount of time to wait (in ms) for responses if there are none immediately, *                must be non-negative. The actual timeout will be the minimum of timeout, request timeout and *                metadata timeout * @param now The current time in milliseconds * @return The list of responses received */@Overridepublic List&lt;ClientResponse&gt; poll(long timeout, long now) &#123;    // 封装要拉取元数据的请求    long metadataTimeout = metadataUpdater.maybeUpdate(now);    try &#123;        this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));    &#125; catch (IOException e) &#123;        log.error(&quot;Unexpected error during I/O&quot;, e);    &#125;    // 处理已完成请求的操作    long updatedNow = this.time.milliseconds();    List&lt;ClientResponse&gt; responses = new ArrayList&lt;&gt;();    handleAbortedSends(responses);    handleCompletedSends(responses, updatedNow);    handleCompletedReceives(responses, updatedNow);    handleDisconnections(responses, updatedNow);    handleConnections();    handleInitiateApiVersionRequests(updatedNow);    handleTimedOutRequests(responses, updatedNow);    // invoke callbacks    for (ClientResponse response : responses) &#123;        try &#123;            response.onComplete();        &#125; catch (Exception e) &#123;            log.error(&quot;Uncaught error in request completion:&quot;, e);        &#125;    &#125;    return responses;&#125;


拉取元数据，给定超时间返回可用的通道或超时

@Overridepublic void poll(long timeout) throws IOException &#123;    if (timeout &lt; 0)        throw new IllegalArgumentException(&quot;timeout should be &gt;= 0&quot;);    clear();    if (hasStagedReceives() || !immediatelyConnectedKeys.isEmpty())        timeout = 0;    /* check ready keys */    long startSelect = time.nanoseconds();    // 阻塞等待，直到有可用连接或超时    int readyKeys = select(timeout);    long endSelect = time.nanoseconds();    this.sensors.selectTime.record(endSelect - startSelect, time.milliseconds());    if (readyKeys &gt; 0 || !immediatelyConnectedKeys.isEmpty()) &#123;        pollSelectionKeys(this.nioSelector.selectedKeys(), false, endSelect);        pollSelectionKeys(immediatelyConnectedKeys, true, endSelect);    &#125;    addToCompletedReceives();    long endIo = time.nanoseconds();    this.sensors.ioTime.record(endIo - endSelect, time.milliseconds());    // we use the time at the end of select to ensure that we don&#x27;t close any connections that    // have just been processed in pollSelectionKeys    maybeCloseOldestConnection(endSelect);&#125;]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Kafka源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka源码分析(二)KafkaProducer初始化</title>
    <url>/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)KafkaProducer%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[Kafka源码分析(二)KafkaProducer初始化一、前言Kafka的源码中附带了一个examples模块，我们从KafkaConsumerProducerDemo类中作为Producer生产者入口进入源码。
二、源码分析
KafkaConsumerProducerDemo 在Demo中创建Producer实例，并且开启多线程start

public class KafkaConsumerProducerDemo &#123;    public static void main(String[] args) &#123;        // 判断是否是异步：如果参数个数为0，或者第一个参数不是&quot;sync&quot;，则是异步。生产环境一般是异步的数据处理。        boolean isAsync = args.length == 0 || !args[0].trim().equalsIgnoreCase(&quot;sync&quot;);        Producer producerThread = new Producer(KafkaProperties.TOPIC, isAsync);        producerThread.start();								// 本章节只看Producer，因此把Consumer相关的代码暂时注释掉        // Consumer consumerThread = new Consumer(KafkaProperties.TOPIC);        // consumerThread.start();    &#125;&#125;


KafkaProducer初始化流程图



sequenceDiagram
autonumber
Note right of Producer: Producer初始化
Producer-&gt;&gt; Producer: KafkaProducer实例化，传入props配置信息
Producer-&gt;&gt; KafkaProducer: KafkaProducer实例化，传入props配置信息
KafkaProducer-&gt;&gt; ProducerConfig: ProducerConfig初始化配置并验证参数信息
KafkaProducer-&gt;&gt; KafkaProducer: 获取clientId属性，如果没有设置，则生成一个唯一的id
KafkaProducer-&gt;&gt; KafkaProducer: 从配置中获取分区器，如果没有设置，则使用默认分区器
KafkaProducer-&gt;&gt; KafkaProducer: 获取重试的间隔时间，默认100ms
KafkaProducer-&gt;&gt; KafkaProducer: 获取序列化器
KafkaProducer-&gt;&gt; KafkaProducer: 初始化metadata元数据，并设置集群资源监听器
KafkaProducer-&gt;&gt; KafkaProducer: 初始化缓存对象accumulator，用于缓存待发送的记录
KafkaProducer-&gt;&gt; KafkaProducer: 更新元数据，设置cluster信息，cluster信息来自于配置文件中的bootstrap.servers
KafkaProducer-&gt;&gt; KafkaProducer: 初始化网络客户端，用于发送请求。
KafkaProducer-&gt;&gt; KafkaProducer: 初始化网络线程sender，用于发送请求。
KafkaProducer-&gt;&gt; KafkaProducer: 启动Kafka网络线程this.ioThread.start();




生产者构造函数

/** * 生产者构造函数 * topic: 主题名称 * isAsync: 是否异步发送 * * @param topic * @param isAsync */public Producer(String topic, Boolean isAsync) &#123;    Properties props = new Properties();    // 连接kafka集群地址，这里使用默认配置：localhost:9092    props.put(&quot;bootstrap.servers&quot;, KafkaProperties.KAFKA_SERVER_URL + &quot;:&quot; + KafkaProperties.KAFKA_SERVER_PORT);    // client.id: 客户端ID，用于标识当前生产者实例    props.put(&quot;client.id&quot;, &quot;DemoProducer&quot;);    // key.serializer: key序列化器，这里使用IntegerSerializer    // value.serializer: value序列化器，这里使用StringSerializer    props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.IntegerSerializer&quot;);    props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);    // KafkaProducer实例化，传入配置信息    producer = new KafkaProducer&lt;&gt;(props);    this.topic = topic;    this.isAsync = isAsync;&#125;


构建KafkaProducer
   /**  * 通过提供一组键值对作为配置来实例化创建者。有效的配置字符串  * 记录在 &lt;a href=“http://kafka.apache.org/documentation.html#producerconfigs”&gt;这里&lt;/a&gt;。  * @param properties   生产者配置  */ public KafkaProducer(Properties properties) &#123;     this(new ProducerConfig(properties), null, null); &#125;/**  * 通过提供一组键值对作为配置、一个键和一个值 &#123;@link Serializer&#125; 来实例化生产者。  * 此处记录了有效的配置字符串&lt;a href=“http://kafka.apache.org/documentation.html#producerconfigs”&gt;&lt;/a&gt;。  * @param properties 生产者配置  * @param keySerializer 实现 &#123;@link Serializer&#125; 的 key 的序列化器。configure（） 方法不会是  * 在直接传入序列化程序时在 producer 中调用。  * @param valueSerializer 实现 &#123;@link Serializer&#125; 的值的序列化器。configure（） 方法不会  * 当直接传入序列化程序时，在 producer 中调用。  */ public KafkaProducer(Properties properties, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer) &#123;     this(new ProducerConfig(ProducerConfig.addSerializerToConfig(properties, keySerializer, valueSerializer)),          keySerializer, valueSerializer); &#125;    

KafkaProducer实例化


private KafkaProducer(ProducerConfig config, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer) &#123;    try &#123;        log.trace(&quot;Starting the Kafka producer&quot;);        Map&lt;String, Object&gt; userProvidedConfigs = config.originals();        this.producerConfig = config;        this.time = Time.SYSTEM;        // 获取clientId属性，如果没有设置，则生成一个唯一的id        clientId = config.getString(ProducerConfig.CLIENT_ID_CONFIG);        if (clientId.length() &lt;= 0)            clientId = &quot;producer-&quot; + PRODUCER_CLIENT_ID_SEQUENCE.getAndIncrement();        // 指标、监控相关代码        Map&lt;String, String&gt; metricTags = new LinkedHashMap&lt;String, String&gt;();        metricTags.put(&quot;client-id&quot;, clientId);        MetricConfig metricConfig = new MetricConfig().samples(config.getInt(ProducerConfig.METRICS_NUM_SAMPLES_CONFIG))                .timeWindow(config.getLong(ProducerConfig.METRICS_SAMPLE_WINDOW_MS_CONFIG), TimeUnit.MILLISECONDS)                .tags(metricTags);        List&lt;MetricsReporter&gt; reporters = config.getConfiguredInstances(ProducerConfig.METRIC_REPORTER_CLASSES_CONFIG,                MetricsReporter.class);        reporters.add(new JmxReporter(JMX_PREFIX));        this.metrics = new Metrics(metricConfig, reporters, time);        // 从配置中获取分区器，如果没有设置，则使用默认分区器        this.partitioner = config.getConfiguredInstance(ProducerConfig.PARTITIONER_CLASS_CONFIG, Partitioner.class);        // 获取重试的间隔时间，默认100ms        long retryBackoffMs = config.getLong(ProducerConfig.RETRY_BACKOFF_MS_CONFIG);        // 获取序列化器        if (keySerializer == null) &#123;            this.keySerializer = config.getConfiguredInstance(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,                    Serializer.class);            this.keySerializer.configure(config.originals(), true);        &#125; else &#123;            config.ignore(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG);            this.keySerializer = keySerializer;        &#125;        if (valueSerializer == null) &#123;            this.valueSerializer = config.getConfiguredInstance(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,                    Serializer.class);            this.valueSerializer.configure(config.originals(), false);        &#125; else &#123;            config.ignore(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG);            this.valueSerializer = valueSerializer;        &#125;        // 设置拦截器        userProvidedConfigs.put(ProducerConfig.CLIENT_ID_CONFIG, clientId);        List&lt;ProducerInterceptor&lt;K, V&gt;&gt; interceptorList = (List) (new ProducerConfig(userProvidedConfigs, false)).getConfiguredInstances(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG,                ProducerInterceptor.class);        this.interceptors = interceptorList.isEmpty() ? null : new ProducerInterceptors&lt;&gt;(interceptorList);        // 集群资源监听器        ClusterResourceListeners clusterResourceListeners = configureClusterResourceListeners(keySerializer, valueSerializer, interceptorList, reporters);        /**         * 初始化metadata元数据结构，并设置集群资源监听器         * retryBackoffMs:重试的间隔时间，默认100ms         * metadataMaxAgeMs:元数据最大存活时间，默认5分钟         * allowAutoTopicCreation:是否允许自动创建主题，默认true         * clusterResourceListeners:集群资源监听器         */        this.metadata = new Metadata(retryBackoffMs, config.getLong(ProducerConfig.METADATA_MAX_AGE_CONFIG), true, clusterResourceListeners);        /**         * 获取maxRequestSize属性，(最大请求大小)，默认1M         * 获取totalMemorySize属性，(缓冲区总大小)，默认32M         * 获取compressionType属性，(压缩类型)，默认none         */        this.maxRequestSize = config.getInt(ProducerConfig.MAX_REQUEST_SIZE_CONFIG);        this.totalMemorySize = config.getLong(ProducerConfig.BUFFER_MEMORY_CONFIG);        this.compressionType = CompressionType.forName(config.getString(ProducerConfig.COMPRESSION_TYPE_CONFIG));        /* 检查用户定义的设置。         * 如果 BLOCK_ON_BUFFER_FULL 设置为 true，则不执行 METADATA_FETCH_TIMEOUT_CONFIG。         * 当已弃用的配置被删除时，这应该在 0.9 版本中删除。         */        if (userProvidedConfigs.containsKey(ProducerConfig.BLOCK_ON_BUFFER_FULL_CONFIG)) &#123;            log.warn(ProducerConfig.BLOCK_ON_BUFFER_FULL_CONFIG + &quot; config is deprecated and will be removed soon. &quot; +                    &quot;Please use &quot; + ProducerConfig.MAX_BLOCK_MS_CONFIG);            boolean blockOnBufferFull = config.getBoolean(ProducerConfig.BLOCK_ON_BUFFER_FULL_CONFIG);            if (blockOnBufferFull) &#123;                this.maxBlockTimeMs = Long.MAX_VALUE;            &#125; else if (userProvidedConfigs.containsKey(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG)) &#123;                log.warn(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG + &quot; config is deprecated and will be removed soon. &quot; +                        &quot;Please use &quot; + ProducerConfig.MAX_BLOCK_MS_CONFIG);                this.maxBlockTimeMs = config.getLong(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG);            &#125; else &#123;                this.maxBlockTimeMs = config.getLong(ProducerConfig.MAX_BLOCK_MS_CONFIG);            &#125;        &#125; else if (userProvidedConfigs.containsKey(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG)) &#123;            // 获取元数据超时时间，默认60s            log.warn(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG + &quot; config is deprecated and will be removed soon. &quot; +                    &quot;Please use &quot; + ProducerConfig.MAX_BLOCK_MS_CONFIG);            this.maxBlockTimeMs = config.getLong(ProducerConfig.METADATA_FETCH_TIMEOUT_CONFIG);        &#125; else &#123;            // 获取最大阻塞时间，默认60s            this.maxBlockTimeMs = config.getLong(ProducerConfig.MAX_BLOCK_MS_CONFIG);        &#125;        /* 检查用户定义的设置。         * 如果设置了 TIME_OUT 配置，请将其用于请求超时。         * 这应该在 0.9 版中删除         */        if (userProvidedConfigs.containsKey(ProducerConfig.TIMEOUT_CONFIG)) &#123;            log.warn(ProducerConfig.TIMEOUT_CONFIG + &quot; config is deprecated and will be removed soon. Please use &quot; +                    ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG);            this.requestTimeoutMs = config.getInt(ProducerConfig.TIMEOUT_CONFIG);        &#125; else &#123;            // 获取请求超时时间，默认30s            this.requestTimeoutMs = config.getInt(ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG);        &#125;        // 初始化缓存对象，用于缓存待发送的记录。        this.accumulator = new RecordAccumulator(config.getInt(ProducerConfig.BATCH_SIZE_CONFIG),                this.totalMemorySize,                this.compressionType,                config.getLong(ProducerConfig.LINGER_MS_CONFIG),                retryBackoffMs,                metrics,                time);        // 更新元数据，设置cluster信息，cluster信息来自于配置文件中的bootstrap.servers        List&lt;InetSocketAddress&gt; addresses = ClientUtils.parseAndValidateAddresses(config.getList(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG));        this.metadata.update(Cluster.bootstrap(addresses), Collections.&lt;String&gt;emptySet(), time.milliseconds());        /**         * 初始化管理网络组件NetworkClient         * connections.max.idle.ms : 连接最大空闲时间，默认9分钟         * max.in.flight.requests.per.connection : 单个连接最大未确认请求数，默认5。如果需要有序，需要设置：为1         * reconnect.backoff.ms : 重连间隔时间，默认50毫秒         * send.buffer.bytes : 发送缓冲区大小，默认128K         * receive.buffer.bytes : 接收缓冲区大小，默认32K         * requestTimeoutMs：请求超时时间，默认5分钟         */        ChannelBuilder channelBuilder = ClientUtils.createChannelBuilder(config.values());        NetworkClient client = new NetworkClient(                new Selector(config.getLong(ProducerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG), this.metrics, time, &quot;producer&quot;, channelBuilder),                this.metadata,                clientId,                config.getInt(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION),                config.getLong(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG),                config.getInt(ProducerConfig.SEND_BUFFER_CONFIG),                config.getInt(ProducerConfig.RECEIVE_BUFFER_CONFIG),                this.requestTimeoutMs,                time,                true);        /**         *  初始化网络Sender线程，用于发送请求。         *  acks：确认模式：默认值为：1         *      0：不确认，即使集群中有leader，也不会等待确认。         *      1：leader确认，即使集群中有follower，也不会等待确认。         *      2：leader和follower都确认，等待所有副本确认。         * retries：重试次数，默认值为：0。         */        this.sender = new Sender(client,                this.metadata,                this.accumulator,                config.getInt(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION) == 1,                config.getInt(ProducerConfig.MAX_REQUEST_SIZE_CONFIG),                (short) parseAcks(config.getString(ProducerConfig.ACKS_CONFIG)),                config.getInt(ProducerConfig.RETRIES_CONFIG),                this.metrics,                Time.SYSTEM,                this.requestTimeoutMs);        String ioThreadName = &quot;kafka-producer-network-thread&quot; + (clientId.length() &gt; 0 ? &quot; | &quot; + clientId : &quot;&quot;);        // 启动Kafka网络线程        this.ioThread = new KafkaThread(ioThreadName, this.sender, true);        this.ioThread.start();        this.errors = this.metrics.sensor(&quot;errors&quot;);        config.logUnused();        AppInfoParser.registerAppInfo(JMX_PREFIX, clientId);        log.debug(&quot;Kafka producer started&quot;);    &#125; catch (Throwable t) &#123;        // this is to prevent resource leak. see KAFKA-2121        close(0, TimeUnit.MILLISECONDS, true);        throw new KafkaException(&quot;Failed to construct kafka producer&quot;, t);    &#125;&#125;]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Kafka源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka源码分析(四)Producer生产者执行流程</title>
    <url>/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Kafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)Producer%E7%94%9F%E4%BA%A7%E8%80%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[Kafka源码分析(四)Producer生产者执行流程一、前言
代码的入口main方法中Producer类是一个多线程，在main中对producerThread进行start。表示开始了这个线程，Producer类中的run方法被获得被执行。

public class KafkaConsumerProducerDemo &#123;    public static void main(String[] args) &#123;        // 判断是否是异步：如果参数个数为0，或者第一个参数不是&quot;sync&quot;，则是异步。生产环境一般是异步的数据处理。        boolean isAsync = args.length == 0 || !args[0].trim().equalsIgnoreCase(&quot;sync&quot;);        Producer producerThread = new Producer(KafkaProperties.TOPIC, isAsync);        producerThread.start();        Consumer consumerThread = new Consumer(KafkaProperties.TOPIC);        consumerThread.start();    &#125;&#125;

二、Producer获取元数据流程图
Producer流程图



获取元素流程图
  

Broker和Partition关系图
  




sequenceDiagram
autonumber
Producer -&gt;&gt; Producer: run()方法
Producer -&gt;&gt; KafkaProducer:send()
KafkaProducer -&gt;&gt; KafkaProducer: 执行拦截器
Note right of KafkaProducer : Producer唤醒sender线程等待元数据更新
KafkaProducer -&gt;&gt; KafkaProducer: 从服务端获取metadata数据
	KafkaProducer -&gt;&gt; Metadata: 将topic添加到metadata列表，如果列表中不存在topic，则把属性needUpdate设置为：true
	KafkaProducer -&gt;&gt; KafkaProducer: 从缓存中获取metadata数据，如果存在已经存在缓存的数据，直接返回流程结束
  loop topic主题分区数量：partitionsCount
      KafkaProducer -&gt;&gt; Metadata: 属性needUpdate设置为：true
      KafkaProducer --&gt;&gt; Sender: 唤醒sender线程
      KafkaProducer -&gt;&gt; Metadata: 等待元数据更新，直到当前版本大于我们所知道的最后一个版本，或者等待超时
  end
  
loop Sender线程while true死循环
			Note right of NetworkClient: 获取并验证apiVersion版本：handleInitiateApiVersionRequests()] 
			Sender -&gt;&gt; NetworkClient: 当Producer线程把needUpdate设置为true时，&lt;br&#x2F;&gt;说明需要更新metadata信息
			NetworkClient -&gt;&gt; NetworkClient: 第一次初始化网络连接：initiateConnect
			NetworkClient -&gt;&gt; NetworkClient: 网络连接已经完成后，注册版本添加一个write写的事件
			NetworkClient -&gt;&gt; NetworkClient : handleInitiateApiVersionRequests()处理apiVersion请求。
			NetworkClient -&gt;&gt; NetworkClient : 再次循环handleApiVersionsResponse()成功校验apiVersion版本，并修改连接状态为ready
			Note right of NetworkClient: 元数据获取
			NetworkClient -&gt;&gt; NetworkClient : 构建获取元数据请求参数sendInternalMetadataRequest
			NetworkClient -&gt;&gt; NetworkClient : 处理返回值handleCompletedMetadataResponse更新元素数据metadata对象，版本号+1
			NetworkClient --&gt;&gt; Producer: notifyAll，唤醒Producer主线程
			Sender -&gt;&gt; Sender: 获取已准备好发送数据的分区请求
			Sender -&gt;&gt; Sender: 判断节点有没有准备好，并移除没有准备的节点
			Sender -&gt;&gt; NetworkClient: 如果没有建立连接 -&gt; 初始化网络连接
			NetworkClient -&gt;&gt; Selector: 建立连接注册的OP_CONNECT事件
			Sender -&gt;&gt; Sender: 准备待发送请求的数据
			Sender -&gt;&gt; NetworkClient: 执行网络请求poll
			NetworkClient -&gt;&gt; NetworkClient: 封装要拉取元数据的请求
			NetworkClient -&gt;&gt; NetworkClient: 处理返回请求的操作，包括：&lt;br&#x2F;&gt;处理被中止的发送请求、&lt;br&#x2F;&gt;处理已完成的发送请求、&lt;br&#x2F;&gt;处理从Broker接收到的响应、&lt;br&#x2F;&gt;处理连接断开事件、&lt;br&#x2F;&gt;建立新连接、&lt;br&#x2F;&gt;处理API版本协商请求、&lt;br&#x2F;&gt;处理超时请求
			NetworkClient -&gt;&gt; NetworkClient: 执行回调函数
			
	end	
	
KafkaProducer -&gt;&gt; KafkaProducer: 对消息key和value进行序列化
KafkaProducer -&gt;&gt; KafkaProducer: 根据分区策略获取消息发送的分区
%% 默认分区策略（DefaultPartitioner.java）
%% 获得topic的分区的数量
%% 如果没有指定key，则生成一个随机数，正整数，然后取模获得分区号。
%% 有指定key，把key的字节数组用hash算法生成一个整数，然后取模获得分区号。
KafkaProducer -&gt;&gt; KafkaProducer: 获取序列化后的消息大小并验证大小是否超过默认1M限制
KafkaProducer -&gt;&gt; KafkaProducer: 绑定拦截器和回调函数
KafkaProducer -&gt;&gt; KafkaProducer: 消息添加到Accumulator中，Accumulator负责将消息分成多个批次，并将消息发送到Kafka集群
KafkaProducer -&gt;&gt; KafkaProducer: 如果Accumulator中缓存的消息数量已满或已创建新的批次，则唤醒sender线程
KafkaProducer -&gt;&gt; KafkaProducer: 返回RecordMetadataFuture，用于获取消息发送结果



三、源代码分析
Producer 主线程
  public class Producer extends Thread &#123;    private final KafkaProducer&lt;Integer, String&gt; producer;    private final String topic;    private final Boolean isAsync;    /**     * 生产者构造函数     * topic: 主题名称     * isAsync: 是否异步发送     *     * @param topic     * @param isAsync     */    public Producer(String topic, Boolean isAsync) &#123;        Properties props = new Properties();        // 连接kafka集群地址，这里使用默认配置：localhost:9092        props.put(&quot;bootstrap.servers&quot;, KafkaProperties.KAFKA_SERVER_URL + &quot;:&quot; + KafkaProperties.KAFKA_SERVER_PORT);        // client.id: 客户端ID，用于标识当前生产者实例        props.put(&quot;client.id&quot;, &quot;DemoProducer&quot;);        // key.serializer: key序列化器，这里使用IntegerSerializer        // value.serializer: value序列化器，这里使用StringSerializer        props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.IntegerSerializer&quot;);        props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);        // KafkaProducer实例化, 传入配置信息        producer = new KafkaProducer&lt;&gt;(props);        this.topic = topic;        this.isAsync = isAsync;    &#125;    public void run() &#123;        int messageNo = 1;        while (true) &#123;            String messageStr = &quot;Message_&quot; + messageNo;            long startTime = System.currentTimeMillis();            if (isAsync) &#123; // Send asynchronously                producer.send(new ProducerRecord&lt;&gt;(topic,                    messageNo,                    messageStr), new DemoCallBack(startTime, messageNo, messageStr));            &#125; else &#123; // Send synchronously                try &#123;                    producer.send(new ProducerRecord&lt;&gt;(topic,                        messageNo,                        messageStr)).get();                    System.out.println(&quot;Sent message: (&quot; + messageNo + &quot;, &quot; + messageStr + &quot;)&quot;);                &#125; catch (InterruptedException | ExecutionException e) &#123;                    e.printStackTrace();                &#125;            &#125;            ++messageNo;        &#125;    &#125;&#125;

KafkaProducer.send() 发送消息之前，先将消息拦截器拦截
      @Overridepublic Future&lt;RecordMetadata&gt; send(ProducerRecord&lt;K, V&gt; record, Callback callback) &#123;    // 发送消息之前，先将消息拦截器拦截    // intercept the record, which can be potentially modified; this method does not throw exceptions    ProducerRecord&lt;K, V&gt; interceptedRecord = this.interceptors == null ? record : this.interceptors.onSend(record);    // 发送消息    return doSend(interceptedRecord, callback);&#125;    

KafkaProducer.doSend() 发送消息
  private Future&lt;RecordMetadata&gt; doSend(ProducerRecord&lt;K, V&gt; record, Callback callback) &#123;    TopicPartition tp = null;    try &#123;        // 从服务端获取元数据：maxBlockTimeMs：最大阻塞时间，默认60s        ClusterAndWaitTime clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);        // remainingWaitMs（剩余可用时间） = maxBlockTimeMs（最大阻塞时间） - clusterAndWaitTime.waitedOnMetadataMs(上次获取元数据耗时)        long remainingWaitMs = Math.max(0, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);        Cluster cluster = clusterAndWaitTime.cluster;            // 对消息key和value进行序列化        byte[] serializedKey;        try &#123;            serializedKey = keySerializer.serialize(record.topic(), record.key());        &#125; catch (ClassCastException cce) &#123;            throw new SerializationException(&quot;Can&#x27;t convert key of class &quot; + record.key().getClass().getName() +                    &quot; to class &quot; + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +                    &quot; specified in key.serializer&quot;);        &#125;        byte[] serializedValue;        try &#123;            serializedValue = valueSerializer.serialize(record.topic(), record.value());        &#125; catch (ClassCastException cce) &#123;            throw new SerializationException(&quot;Can&#x27;t convert value of class &quot; + record.value().getClass().getName() +                    &quot; to class &quot; + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +                    &quot; specified in value.serializer&quot;);        &#125;            // 根据分区策略获取消息发送的分区        int partition = partition(record, serializedKey, serializedValue, cluster);            // 获取序列化后的消息大小        int serializedSize = Records.LOG_OVERHEAD + Record.recordSize(serializedKey, serializedValue);            // 验证消息大小是否超出限制，默认1M        ensureValidRecordSize(serializedSize);        tp = new TopicPartition(record.topic(), partition);        long timestamp = record.timestamp() == null ? time.milliseconds() : record.timestamp();        log.trace(&quot;Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;&quot;, record, callback, record.topic(), partition);        // producer callback will make sure to call both &#x27;callback&#x27; and interceptor callback            // 绑定拦截器和回调函数        Callback interceptCallback = this.interceptors == null ? callback : new InterceptorCallback&lt;&gt;(callback, this.interceptors, tp);        // 消息添加到Accumulator中，Accumulator负责将消息分成多个批次，并将消息发送到Kafka集群        RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey, serializedValue, interceptCallback, remainingWaitMs);            // 如果Accumulator中缓存的消息数量已满或已创建新的批次，则唤醒sender线程        if (result.batchIsFull || result.newBatchCreated) &#123;            log.trace(&quot;Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch&quot;, record.topic(), partition);            this.sender.wakeup();        &#125;        // 返回RecordMetadataFuture，用于获取消息发送结果        return result.future;        // handling exceptions and record the errors;        // for API exceptions return them in the future,        // for other exceptions throw directly    &#125; catch (ApiException e) &#123;        log.debug(&quot;Exception occurred during message send:&quot;, e);        if (callback != null)            callback.onCompletion(null, e);        this.errors.record();        if (this.interceptors != null)            this.interceptors.onSendError(record, tp, e);        return new FutureFailure(e);    &#125; catch (InterruptedException e) &#123;        this.errors.record();        if (this.interceptors != null)            this.interceptors.onSendError(record, tp, e);        throw new InterruptException(e);    &#125; catch (BufferExhaustedException e) &#123;        this.errors.record();        this.metrics.sensor(&quot;buffer-exhausted-records&quot;).record();        if (this.interceptors != null)            this.interceptors.onSendError(record, tp, e);        throw e;    &#125; catch (KafkaException e) &#123;        this.errors.record();        if (this.interceptors != null)            this.interceptors.onSendError(record, tp, e);        throw e;    &#125; catch (Exception e) &#123;        // we notify interceptor about all exceptions, since onSend is called before anything else in this method        if (this.interceptors != null)            this.interceptors.onSendError(record, tp, e);        throw e;    &#125;&#125;

从服务端获取元数据waitOnMetadata
  /** * Wait for cluster metadata including partitions for the given topic to be available. * @param topic The topic we want metadata for * @param partition A specific partition expected to exist in metadata, or null if there&#x27;s no preference * @param maxWaitMs The maximum time in ms for waiting on the metadata * @return The cluster containing topic metadata and the amount of time we waited in ms */private ClusterAndWaitTime waitOnMetadata(String topic, Integer partition, long maxWaitMs) throws InterruptedException &#123;    // 将主题添加到元数据主题列表（如果尚不存在）并重置过期时间和needUpdate设置为true    metadata.add(topic);    Cluster cluster = metadata.fetch();    Integer partitionsCount = cluster.partitionCountForTopic(topic);        // 如果我们有缓存的metadata数据，并且消息的分区未定义或在已知分区范围内，则返回缓存的metadata数据    if (partitionsCount != null &amp;&amp; (partition == null || partition &lt; partitionsCount))        return new ClusterAndWaitTime(cluster, 0);        // 当前时间    long begin = time.milliseconds();    // 剩余可用时间，默认值为maxWaitMs，最多可以等待时间    long remainingWaitMs = maxWaitMs;    long elapsed;    // Issue metadata requests until we have metadata for the topic or maxWaitTimeMs is exceeded.    // In case we already have cached metadata for the topic, but the requested partition is greater    // than expected, issue an update request only once. This is necessary in case the metadata    // is stale and the number of partitions for this topic has increased in the meantime.    do &#123;        log.trace(&quot;Requesting metadata update for topic &#123;&#125;.&quot;, topic);        // needUpdate设置为true，返回更新前的当前版本        int version = metadata.requestUpdate();        // 唤醒sender线程        sender.wakeup();            try &#123;            metadata.awaitUpdate(version, remainingWaitMs);        &#125; catch (TimeoutException ex) &#123;            // Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs            throw new TimeoutException(&quot;Failed to update metadata after &quot; + maxWaitMs + &quot; ms.&quot;);        &#125;        // 再次获取集群的元数据信息        cluster = metadata.fetch();        // 计算拉取metadata数据耗时        elapsed = time.milliseconds() - begin;        // 如果拉取metadata数据耗时超过了最大阻塞时间，则抛出超时异常        if (elapsed &gt;= maxWaitMs)            throw new TimeoutException(&quot;Failed to update metadata after &quot; + maxWaitMs + &quot; ms.&quot;);        // 如果获取到metadata数据，topic没有授权，则抛出TopicAuthorizationException        if (cluster.unauthorizedTopics().contains(topic))            throw new TopicAuthorizationException(topic);        // 计算剩余可用时间        remainingWaitMs = maxWaitMs - elapsed;        // 如果topic的分区数量未知，则继续等待        partitionsCount = cluster.partitionCountForTopic(topic);    &#125; while (partitionsCount == null);        if (partition != null &amp;&amp; partition &gt;= partitionsCount) &#123;        throw new KafkaException(                String.format(&quot;Invalid partition given with record: %d is not in the range [0...%d).&quot;, partition, partitionsCount));    &#125;    // 返回集群元数据和耗时时间    return new ClusterAndWaitTime(cluster, elapsed);&#125;

Sender线程在run()方法死循环
  /** * Run a single iteration of sending *  * @param now *            The current POSIX time in milliseconds */void run(long now) &#123;    // 获取当前集群metadata信息    Cluster cluster = metadata.fetch();    // 获取已准备好发送数据的分区请求    RecordAccumulator.ReadyCheckResult result = this.accumulator.ready(cluster, now);        // 如果有任何分区的 leader 尚不清楚，则强制元数据更新。第一次执行topic，不会走    if (!result.unknownLeaderTopics.isEmpty()) &#123;        // The set of topics with unknown leader contains topics with leader election pending as well as        // topics which may have expired. Add the topic again to metadata to ensure it is included        // and request metadata update, since there are messages to send to the topic.        for (String topic : result.unknownLeaderTopics)            this.metadata.add(topic);        this.metadata.requestUpdate();    &#125;    // 判断节点有没有准备好，并移除没有准备的节点    // remove any nodes we aren&#x27;t ready to send to    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();    long notReadyTimeout = Long.MAX_VALUE;    while (iter.hasNext()) &#123;        Node node = iter.next();        if (!this.client.ready(node, now)) &#123;            iter.remove();            notReadyTimeout = Math.min(notReadyTimeout, this.client.connectionDelay(node, now));        &#125;    &#125;        // 创建批次请求    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = this.accumulator.drain(cluster,                                                                     result.readyNodes,                                                                     this.maxRequestSize,                                                                     now);    // 保证消息顺序，第一次执行guaranteeMessageOrder为false，不会走    if (guaranteeMessageOrder) &#123;        // Mute all the partitions drained        for (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;            for (RecordBatch batch : batchList)                this.accumulator.mutePartition(batch.topicPartition);        &#125;    &#125;        // 检查超时的批次，第一次执行没expiredBatches为空    List&lt;RecordBatch&gt; expiredBatches = this.accumulator.abortExpiredBatches(this.requestTimeout, now);    // 更新超时批次的错误计数    for (RecordBatch expiredBatch : expiredBatches)        this.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);        sensors.updateProduceRequestMetrics(batches);        // If we have any nodes that are ready to send + have sendable data, poll with 0 timeout so this can immediately    // loop and try sending more data. Otherwise, the timeout is determined by nodes that have partitions with data    // that isn&#x27;t yet sendable (e.g. lingering, backing off). Note that this specifically does not include nodes    // with sendable data that aren&#x27;t ready to send since they would cause busy looping.    long pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);    if (!result.readyNodes.isEmpty()) &#123;        log.trace(&quot;Nodes with data ready to send: &#123;&#125;&quot;, result.readyNodes);        // 如果有已经准备好的节点，超时间隔为0，立即发送请求        pollTimeout = 0;    &#125;    // 准备待发送请求的数据    sendProduceRequests(batches, now);        // 执行网络请求    // if some partitions are already ready to be sent, the select time would be 0;    // otherwise if some partition already has some data accumulated but not ready yet,    // the select time will be the time difference between now and its linger expiry time;    // otherwise the select time will be the time difference between now and the metadata expiry time;    this.client.poll(pollTimeout, now);&#125;

获取已准备好发送数据的分区请求ready
  public ReadyCheckResult ready(Cluster cluster, long nowMs) &#123;    Set&lt;Node&gt; readyNodes = new HashSet&lt;&gt;();    long nextReadyCheckDelayMs = Long.MAX_VALUE;    Set&lt;String&gt; unknownLeaderTopics = new HashSet&lt;&gt;();        // 内存已经耗尽，并且线程阻塞等待buffer，则所有partition都可以发送    boolean exhausted = this.free.queued() &gt; 0;        // 遍历所有队列，获取每个partition的leader节点，如果leader节点不存在，则说明该partition的leader节点未知，    for (Map.Entry&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; entry : this.batches.entrySet()) &#123;        TopicPartition part = entry.getKey();        Deque&lt;RecordBatch&gt; deque = entry.getValue();            Node leader = cluster.leaderFor(part);        synchronized (deque) &#123;            if (leader == null &amp;&amp; !deque.isEmpty()) &#123;                // This is a partition for which leader is not known, but messages are available to send.                // Note that entries are currently not removed from batches when deque is empty.                unknownLeaderTopics.add(part.topic());            &#125; else if (!readyNodes.contains(leader) &amp;&amp; !muted.contains(part)) &#123;                // 从队列头部获取第一个批次，如果批不为null，则判断是否可以发送，如果可以发送，则添加到readyNodes集合中                RecordBatch batch = deque.peekFirst();                if (batch != null) &#123;                    /**                     * batch.attempts重试的次数                     * batch.lastAttemptMs上次重试的时间                     * batch.retryBackoffMs重试的间隔时间                     * nowMs当前时间                     */                    boolean backingOff = batch.attempts &gt; 0 &amp;&amp; batch.lastAttemptMs + retryBackoffMs &gt; nowMs;                    // waitedTimeMs（已经等待的时间） = nowMs当前时间 - batch.lastAttemptMs上次重试的时间                    long waitedTimeMs = nowMs - batch.lastAttemptMs;                        // timeToWaitMs最多等待的时间 = backingOff是否处于重试状态？重试间隔时间：lingerMs等待时间，默认为：0                    long timeToWaitMs = backingOff ? retryBackoffMs : lingerMs;                        // timeLeftMs剩余等待的时间 = timeToWaitMs（最多等待的时间） - waitedTimeMs（已经等待的时间）                    long timeLeftMs = Math.max(timeToWaitMs - waitedTimeMs, 0);                        //full是否已满 = 队列中有多个批次 || 当前批次已满                    boolean full = deque.size() &gt; 1 || batch.isFull();                        // expired是否已过期 = waitedTimeMs（已经等待的时间） &gt;= timeToWaitMs（最多等待的时间）                    boolean expired = waitedTimeMs &gt;= timeToWaitMs;                        // sendable是否可以发送 = 队列中有多个批次或者当前批次已满 || 等待时间已过 || 内存耗尽 || 关闭 || 正在flush                    boolean sendable = full || expired || exhausted || closed || flushInProgress();                    if (sendable &amp;&amp; !backingOff) &#123;                        readyNodes.add(leader);                    &#125; else &#123;                        // Note that this results in a conservative estimate since an un-sendable partition may have                        // a leader that will later be found to have sendable data. However, this is good enough                        // since we&#x27;ll just wake up and then sleep again for the remaining time.                        nextReadyCheckDelayMs = Math.min(timeLeftMs, nextReadyCheckDelayMs);                    &#125;                &#125;            &#125;        &#125;    &#125;        return new ReadyCheckResult(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);&#125;

判断节点有没有准备好，并移除没有准备的节点
      // 判断节点有没有准备好，并移除没有准备的节点    // remove any nodes we aren&#x27;t ready to send to    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();    long notReadyTimeout = Long.MAX_VALUE;    while (iter.hasNext()) &#123;        Node node = iter.next();        if (!this.client.ready(node, now)) &#123;            iter.remove();            notReadyTimeout = Math.min(notReadyTimeout, this.client.connectionDelay(node, now));        &#125;    &#125;         /** * Begin connecting to the given node, return true if we are already connected and ready to send to that node. * * @param node The node to check * @param now The current timestamp * @return True if we are ready to send to the given node */@Overridepublic boolean ready(Node node, long now) &#123;    if (node.isEmpty())        throw new IllegalArgumentException(&quot;Cannot connect to empty node &quot; + node);        if (isReady(node, now))        return true;        if (connectionStates.canConnect(node.idString(), now))        // 初始化网络连接        initiateConnect(node, now);        return false;&#125;    /** * 初始化连接，如果连接失败，则会尝试重试。 */private void initiateConnect(Node node, long now) &#123;    String nodeConnectionId = node.idString();    try &#123;        log.debug(&quot;Initiating connection to node &#123;&#125; at &#123;&#125;:&#123;&#125;.&quot;, node.id(), node.host(), node.port());        // 修改状态为正在连接        this.connectionStates.connecting(nodeConnectionId, now);        // 尝试连接        selector.connect(nodeConnectionId,                         new InetSocketAddress(node.host(), node.port()),                         this.socketSendBuffer,                         this.socketReceiveBuffer);    &#125; catch (IOException e) &#123;        /* attempt failed, we&#x27;ll try again after the backoff */        connectionStates.disconnected(nodeConnectionId, now);        /* maybe the problem is our metadata, update it */        metadataUpdater.requestUpdate();        log.debug(&quot;Error connecting to node &#123;&#125; at &#123;&#125;:&#123;&#125;:&quot;, node.id(), node.host(), node.port(), e);    &#125;&#125;@Overridepublic void connect(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize) throws IOException &#123;    if (this.channels.containsKey(id))        throw new IllegalStateException(&quot;There is already a connection for id &quot; + id);    // 获取SocketChannel.open()    SocketChannel socketChannel = SocketChannel.open();    // 设置非阻塞模式    socketChannel.configureBlocking(false);    // 获取socket    Socket socket = socketChannel.socket();    socket.setKeepAlive(true);    // 设置发送缓冲区大小、接收缓冲区大小    if (sendBufferSize != Selectable.USE_DEFAULT_BUFFER_SIZE)        socket.setSendBufferSize(sendBufferSize);    if (receiveBufferSize != Selectable.USE_DEFAULT_BUFFER_SIZE)        socket.setReceiveBufferSize(receiveBufferSize);    // 设置TcpNoDelay属性为true，用于控制 TCP 连接中数据包的发送方式。    // 默认情况下，TCP 使用 Nagle 算法 来减少网络中的小数据包数量，从而提高网络利用率。    // 然而，这种方式可能会增加延迟，特别是在需要快速响应的应用中    socket.setTcpNoDelay(true);    boolean connected;    try &#123;        // 尝试连接服务器，有可能连接成功：true，也有可能连接失败:false        connected = socketChannel.connect(address);    &#125; catch (UnresolvedAddressException e) &#123;        socketChannel.close();        throw new IOException(&quot;Can&#x27;t resolve address: &quot; + address, e);    &#125; catch (IOException e) &#123;        socketChannel.close();        throw e;    &#125;    // SocketChannel.register()注册到Selector，并设置OP_CONNECT事件    SelectionKey key = socketChannel.register(nioSelector, SelectionKey.OP_CONNECT);    KafkaChannel channel;    try &#123;        // 根据SocketChannel创建KafkaChannel        channel = channelBuilder.buildChannel(id, key, maxReceiveSize);    &#125; catch (Exception e) &#123;        try &#123;            socketChannel.close();        &#125; finally &#123;            key.cancel();        &#125;        throw new IOException(&quot;Channel could not be created for socket &quot; + socketChannel, e);    &#125;    // 把key和channel绑定，并设置附件为channel    key.attach(channel);    // 缓存channel    this.channels.put(id, channel);        if (connected) &#123;        // OP_CONNECT won&#x27;t trigger for immediately connected channels        log.debug(&quot;Immediately connected to node &#123;&#125;&quot;, channel.id());        immediatelyConnectedKeys.add(key);        // 取消前面注册的OP_CONNECT事件        key.interestOps(0);    &#125;&#125;

创建批次请求
  // 创建批次请求Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = this.accumulator.drain(cluster,                                                                 result.readyNodes,                                                                 this.maxRequestSize,                                                                 now);                                                                     /** * 实现按照NodeId进行分组，把相同NodeId的batch分到一组中，返回Map&lt;NodeId, List&lt;RecordBatch&gt;&gt; * Drain all the data for the given nodes and collate them into a list of batches that will fit within the specified * size on a per-node basis. This method attempts to avoid choosing the same topic-node over and over. *  * @param cluster The current cluster metadata * @param nodes The list of node to drain * @param maxSize The maximum number of bytes to drain * @param now The current unix time in milliseconds * @return A list of &#123;@link RecordBatch&#125; for each node specified with total size less than the requested maxSize. */public Map&lt;Integer, List&lt;RecordBatch&gt;&gt; drain(Cluster cluster,                                             Set&lt;Node&gt; nodes,                                             int maxSize,                                             long now) &#123;    if (nodes.isEmpty())        return Collections.emptyMap();        Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = new HashMap&lt;&gt;();    for (Node node : nodes) &#123;        int size = 0;        List&lt;PartitionInfo&gt; parts = cluster.partitionsForNode(node.id());        List&lt;RecordBatch&gt; ready = new ArrayList&lt;&gt;();        /* to make starvation less likely this loop doesn&#x27;t start at 0 */        int start = drainIndex = drainIndex % parts.size();        do &#123;            PartitionInfo part = parts.get(drainIndex);            TopicPartition tp = new TopicPartition(part.topic(), part.partition());            // Only proceed if the partition has no in-flight batches.            if (!muted.contains(tp)) &#123;                Deque&lt;RecordBatch&gt; deque = getDeque(new TopicPartition(part.topic(), part.partition()));                if (deque != null) &#123;                    synchronized (deque) &#123;                        RecordBatch first = deque.peekFirst();                        if (first != null) &#123;                            boolean backoff = first.attempts &gt; 0 &amp;&amp; first.lastAttemptMs + retryBackoffMs &gt; now;                            // Only drain the batch if it is not during backoff period.                            if (!backoff) &#123;                                if (size + first.sizeInBytes() &gt; maxSize &amp;&amp; !ready.isEmpty()) &#123;                                    // there is a rare case that a single batch size is larger than the request size due                                    // to compression; in this case we will still eventually send this batch in a single                                    // request                                    break;                                &#125; else &#123;                                    RecordBatch batch = deque.pollFirst();                                    batch.close();                                    size += batch.sizeInBytes();                                    ready.add(batch);                                    batch.drainedMs = now;                                &#125;                            &#125;                        &#125;                    &#125;                &#125;            &#125;            this.drainIndex = (this.drainIndex + 1) % parts.size();        &#125; while (start != drainIndex);        batches.put(node.id(), ready);    &#125;    return batches;&#125;

执行网络请求
  /** * Do actual reads and writes to sockets. * * @param timeout The maximum amount of time to wait (in ms) for responses if there are none immediately, *                must be non-negative. The actual timeout will be the minimum of timeout, request timeout and *                metadata timeout * @param now The current time in milliseconds * @return The list of responses received */@Overridepublic List&lt;ClientResponse&gt; poll(long timeout, long now) &#123;    // 封装要拉取元数据的请求    long metadataTimeout = metadataUpdater.maybeUpdate(now);    try &#123;        this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));    &#125; catch (IOException e) &#123;        log.error(&quot;Unexpected error during I/O&quot;, e);    &#125;        // 处理已完成请求的操作    long updatedNow = this.time.milliseconds();    List&lt;ClientResponse&gt; responses = new ArrayList&lt;&gt;();    handleAbortedSends(responses);    handleCompletedSends(responses, updatedNow);    handleCompletedReceives(responses, updatedNow);    handleDisconnections(responses, updatedNow);    handleConnections();    handleInitiateApiVersionRequests(updatedNow);    handleTimedOutRequests(responses, updatedNow);        // invoke callbacks    for (ClientResponse response : responses) &#123;        try &#123;            response.onComplete();        &#125; catch (Exception e) &#123;            log.error(&quot;Uncaught error in request completion:&quot;, e);        &#125;    &#125;        return responses;&#125;

更新元数据信息
   @Override public long maybeUpdate(long now) &#123;     // 是否要更新metadata信息，当Producer线程把needUpdate设置为true时，说明需要更新metadata信息     long timeToNextMetadataUpdate = metadata.timeToNextUpdate(now);     long waitForMetadataFetch = this.metadataFetchInProgress ? requestTimeoutMs : 0;         long metadataTimeout = Math.max(timeToNextMetadataUpdate, waitForMetadataFetch);     if (metadataTimeout &gt; 0) &#123;         return metadataTimeout;     &#125;         // Beware that the behavior of this method and the computation of timeouts for poll() are     // highly dependent on the behavior of leastLoadedNode.     // 获取请求最少的Node节点     Node node = leastLoadedNode(now);     if (node == null) &#123;         log.debug(&quot;Give up sending metadata request since no node is available&quot;);         return reconnectBackoffMs;     &#125;         return maybeUpdate(now, node); &#125; /**  * Add a metadata request to the list of sends if we can make one  */ private long maybeUpdate(long now, Node node) &#123;     String nodeConnectionId = node.idString();         if (canSendRequest(nodeConnectionId)) &#123;         this.metadataFetchInProgress = true;         MetadataRequest.Builder metadataRequest;         if (metadata.needMetadataForAllTopics())             metadataRequest = MetadataRequest.Builder.allTopics();         else             metadataRequest = new MetadataRequest.Builder(new ArrayList&lt;&gt;(metadata.topics()));             log.debug(&quot;Sending metadata request &#123;&#125; to node &#123;&#125;&quot;, metadataRequest, node.id());         sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now);         return requestTimeoutMs;     &#125;         // If there&#x27;s any connection establishment underway, wait until it completes. This prevents     // the client from unnecessarily connecting to additional nodes while a previous connection     // attempt has not been completed.     if (isAnyNodeConnecting()) &#123;         // Strictly the timeout we should return here is &quot;connect timeout&quot;, but as we don&#x27;t         // have such application level configuration, using reconnect backoff instead.         return reconnectBackoffMs;     &#125;         if (connectionStates.canConnect(nodeConnectionId, now)) &#123;         // we don&#x27;t have a connection to this node right now, make one         log.debug(&quot;Initialize connection to node &#123;&#125; for sending metadata request&quot;, node.id());         initiateConnect(node, now);         return reconnectBackoffMs;     &#125;         // connected, but can&#x27;t send more OR connecting     // In either case, we just need to wait for a network event to let us know the selected     // connection might be usable again.     return Long.MAX_VALUE; &#125;  

发送Meatadata元数据请求


private void sendInternalMetadataRequest(MetadataRequest.Builder builder,                                          String nodeConnectionId, long now) &#123;     ClientRequest clientRequest = newClientRequest(nodeConnectionId, builder, now, true);     doSend(clientRequest, true, now); &#125; private void doSend(ClientRequest clientRequest, boolean isInternalRequest, long now) &#123;     String nodeId = clientRequest.destination();     if (!isInternalRequest) &#123;         // If this request came from outside the NetworkClient, validate         // that we can send data.  If the request is internal, we trust         // that that internal code has done this validation.  Validation         // will be slightly different for some internal requests (for         // example, ApiVersionsRequests can be sent prior to being in         // READY state.)         if (!canSendRequest(nodeId))             throw new IllegalStateException(&quot;Attempt to send a request to node &quot; + nodeId + &quot; which is not ready.&quot;);     &#125;     AbstractRequest request = null;     AbstractRequest.Builder&lt;?&gt; builder = clientRequest.requestBuilder();     try &#123;         NodeApiVersions versionInfo = nodeApiVersions.get(nodeId);         // Note: if versionInfo is null, we have no server version information. This would be         // the case when sending the initial ApiVersionRequest which fetches the version         // information itself.  It is also the case when discoverBrokerVersions is set to false.         if (versionInfo == null) &#123;             if (discoverBrokerVersions &amp;&amp; log.isTraceEnabled())                 log.trace(&quot;No version information found when sending message of type &#123;&#125; to node &#123;&#125;. &quot; +                         &quot;Assuming version &#123;&#125;.&quot;, clientRequest.apiKey(), nodeId, builder.version());         &#125; else &#123;             short version = versionInfo.usableVersion(clientRequest.apiKey());             builder.setVersion(version);         &#125;         // The call to build may also throw UnsupportedVersionException, if there are essential         // fields that cannot be represented in the chosen version.         request = builder.build();     &#125; catch (UnsupportedVersionException e) &#123;         // If the version is not supported, skip sending the request over the wire.         // Instead, simply add it to the local queue of aborted requests.         log.debug(&quot;Version mismatch when attempting to send &#123;&#125; to &#123;&#125;&quot;,                 clientRequest.toString(), clientRequest.destination(), e);         ClientResponse clientResponse = new ClientResponse(clientRequest.makeHeader(),                 clientRequest.callback(), clientRequest.destination(), now, now,                 false, e, null);         abortedSends.add(clientResponse);         return;     &#125;     RequestHeader header = clientRequest.makeHeader();     if (log.isDebugEnabled()) &#123;         int latestClientVersion = ProtoUtils.latestVersion(clientRequest.apiKey().id);         if (header.apiVersion() == latestClientVersion) &#123;             log.trace(&quot;Sending &#123;&#125; to node &#123;&#125;.&quot;, request, nodeId);         &#125; else &#123;             log.debug(&quot;Using older server API v&#123;&#125; to send &#123;&#125; to node &#123;&#125;.&quot;,                 header.apiVersion(), request, nodeId);         &#125;     &#125;     Send send = request.toSend(nodeId, header);     InFlightRequest inFlightRequest = new InFlightRequest(             header,             clientRequest.createdTimeMs(),             clientRequest.destination(),             clientRequest.callback(),             clientRequest.expectResponse(),             isInternalRequest,             send,             now);     this.inFlightRequests.add(inFlightRequest);     selector.send(inFlightRequest.send); &#125;  /**  * Queue the given request for sending in the subsequent &#123;@link #poll(long)&#125; calls  * @param send The request to send  */ public void send(Send send) &#123;     String connectionId = send.destination();     if (closingChannels.containsKey(connectionId))         this.failedSends.add(connectionId);     else &#123;         KafkaChannel channel = channelOrFail(connectionId, false);         try &#123;             channel.setSend(send);         &#125; catch (CancelledKeyException e) &#123;             this.failedSends.add(connectionId);             close(channel, false);         &#125;     &#125; &#125;  public void setSend(Send send) &#123;     if (this.send != null)         throw new IllegalStateException(&quot;Attempt to begin a send operation with prior send operation still in progress.&quot;);     this.send = send;     this.transportLayer.addInterestOps(SelectionKey.OP_WRITE); &#125;]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Kafka源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis(一)认识Redis</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%80)%E8%AE%A4%E8%AF%86Redis%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[Redis(一)认识Redis1. Redis 是什么？Redis（Remote Dictionary Server )，即远程字典服务 !是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！

2. Redis 能干嘛？google guava提供两种方式：

内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）
效率高，可以用于高速缓存
发布订阅系统
地图信息分析
计时器、计数器（浏览量！）……..

3. 特性
多样的数据类型
持久化
集群
事务

4. Redis安装
Windows安装

下载安装包：Releases · microsoftarchive&#x2F;redis · GitHub
下载完毕得到压缩包：

  

解压到自己电脑上的环境目录下的就可以的！Redis 十分的小，只有5M

  

开启Redis，双击运行服务即可！

  

使用Redis客户单连接redis

  
  127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set name yuanxwOK127.0.0.1:6379&gt; get name&quot;yuanxw&quot;127.0.0.1:6379&gt;
  


4.2 Linux安装

下载安装包：wget https://download.redis.io/releases/redis-6.2.6.tar.gz
解压Redis的安装包



进入解压后的文件，可以看到我们redis的配置文件



基本的环境安装

yum install gcc-c++makemake install




Redis的默认安装路径

 目录：&#x2F;usr&#x2F;local&#x2F;bin


将Redis配置文件。复制到我们当前目录下

mkdir /usr/local/bin/configcp /usr/local/software/redis-6.2.6/redis.conf /usr/local/bin/config


Redis默认不是后台启动的，修改配置文件！




启动Redis服务

./redis-server config/redis.conf


验证服务



使用redis-cli 进行连接测试



如何关闭Redis服务呢

[root@localhost bin]# redis-cli 127.0.0.1:6379&gt; SHUTDOWN


5. Redis默认有16个数据库Redis默认数据库有16个，默认使用database：0

可以使用 select 进行切换数据库！
127.0.0.1:6379&gt; select 3 # 切换数据库OK127.0.0.1:6379[3]&gt; DBSIZE # 查看DB大小！(integer) 0


127.0.0.1:6379[3]&gt; keys * # 查看数据库所有的key1) &quot;name&quot;

6. 清除当前数据库flushdb

7. 清除全部数据库的内容FLUSHALL

127.0.0.1:6379[3]&gt; flushdbOK127.0.0.1:6379[3]&gt; keys *(empty array)

8. Redis 是单线程的明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所有就使用了单线程了！Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的Memecache差！

Redis 为什么单线程还这么快？
误区1：高性能的服务器一定是多线程的？

误区2：多线程（CPU上下文会切换！）一定比单线程效率高！
  先去CPU&gt;内存&gt;硬盘的速度要有所了解！  核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程  （CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高  的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！




]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(七)Redis.conf详解</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%83)Redis%20conf%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[Redis基础入门(七)Redis.conf详解1. 配置文件
单位

配置文件 unit单位 对大小写不敏感！

  

include(包含)

就是好比我们学习Spring、Improt， include

  

NETWORK（网络）
  bind 127.0.0.1      # 绑定的ipprotected-mode yes  # 保护模式port 6379           # 端口设置

GENERAL(通用 )
  daemonize yes # 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！pidfile /var/run/redis_6379.pid # 如果以后台的方式运行，我们就需要指定一个 pid 文件！# 日志# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably) 生产环境# warning (only very important / critical messages are logged)loglevel noticelogfile &quot;&quot; # 日志的文件位置名databases 16 # 数据库的数量，默认是 16 个数据库always-show-logo yes # 是否总是显示LOGO

SNAPSHOTTING（快照）

持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof。Redis 是内存数据库，如果没有持久化，那么数据断电及失！

  # 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作save 900 1# 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作save 300 10# 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作save 60 10000# 我们之后学习持久化，会自己定义这个测试！stop-writes-on-bgsave-error yes # 持久化如果出错，是否还需要继续工作！rdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验！dir ./ # rdb 文件保存的目录！

SECURITY (安全)
  可以在这里设置redis的密码，默认是没有密码！


127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; config get requirepass # 获取redis的密码1) &quot;requirepass&quot;2) &quot;&quot;127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis的密码OK127.0.0.1:6379&gt; config get requirepass # 发现所有的命令都没有权限了(error) NOAUTH Authentication required.127.0.0.1:6379&gt; ping(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录！OK127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;123456&quot;


CLIENTS(限制 )
  maxclients 10000 # 设置能连接上redis的最大客户端的数量maxmemory &lt;bytes&gt; # redis 配置最大的内存容量maxmemory-policy noeviction # 内存到达上限之后的处理策略

内存到达上限之后的处理策略：
volatile-lru：  只对设置了过期时间的key进行LRU（默认值）
allkeys-lru ： 删除lru算法的key
volatile-random：随机删除即将过期key
allkeys-random：随机删除
volatile-ttl ： 删除即将过期的
noeviction ： 永不过期，返回错误





APPEND ONLY 模式 aof配置ppendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字# appendfsync always # 每次修改都会 sync。消耗性能appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！# appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(三)三种特殊数据类型</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%89)%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[Redis基础入门(三)三种特殊数据类型1. Geospatial 地理位置
朋友的定位，附近的人，打车距离计算？

Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！可以查询一些测试数据：http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/

  


官方文档：https://www.redis.net.cn/order/3685.html

getadd 添加地理位置

# getadd 添加地理位置# 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！# 有效的经度从-180度到180度。# 有效的纬度从-85.05112878度到85.05112878度。# 当坐标位置超出上述指定范围时，该命令将会返回一个错误。# 127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijin(error) ERR invalid longitude,latitude pair 39.900000,116.400000# 参数 key 值（）127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shengzhen(integer) 2127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian(integer) 2


getpos获得当前定位：一定是一个坐标值！

127.0.0.1:6379&gt; GEOPOS china:city beijing # 获取指定的城市的经度和纬度！1) 1) &quot;116.39999896287918091&quot;   2) &quot;39.90000009167092543&quot;127.0.0.1:6379&gt; GEOPOS china:city beijing chongqing1) 1) &quot;116.39999896287918091&quot;   2) &quot;39.90000009167092543&quot;2) 1) &quot;106.49999767541885376&quot;   2) &quot;29.52999957900659211&quot;


GEODIST 两人之间的距离

单位：  m 表示单位为米。  km 表示单位为千米。  mi 表示单位为英里。  ft 表示单位为英尺。

  127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km # 查看上海到北京的直线距离&quot;1067.3788&quot;127.0.0.1:6379&gt; GEODIST china:city beijing chongqing km # 查看重庆到北京的直线距离&quot;1464.0708&quot;

georadius 以给定的经纬度为中心， 找出某一半径内的元素


127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻找方圆1000km内的城市1) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km1) &quot;chongqing&quot;2) &quot;xian&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist # 显示到中间距离的位置1) 1) &quot;chongqing&quot;   2) &quot;341.9374&quot;2) 1) &quot;xian&quot;   2) &quot;483.8340&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord # 显示他人的定位信息1) 1) &quot;chongqing&quot;   2) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 1 # 筛选出指定的结果！1) 1) &quot;chongqing&quot;   2) &quot;341.9374&quot;   3) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 21) 1) &quot;chongqing&quot;   2) &quot;341.9374&quot;   3) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) &quot;483.8340&quot;   3) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;


GEORADIUSBYMEMBER  找出位于指定元素周围的其他元素！

127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km1) &quot;beijing&quot;2) &quot;xian&quot;127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km1) &quot;hangzhou&quot;2) &quot;shanghai&quot;


GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示

127.0.0.1:6379&gt; geohash china:city beijing chongqing # 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！1) &quot;wx4fbxxfke0&quot;2) &quot;wm5xzrybty0&quot;


GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！

127.0.0.1:6379&gt; ZRANGE china:city 0 -1 # 查看地图中全部的元素1) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;6) &quot;beijing&quot;127.0.0.1:6379&gt; zrem china:city beijing # 移除指定元素！(integer) 1127.0.0.1:6379&gt; ZRANGE china:city 0 -11) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;

Hyperloglog
什么是基数？

基数（不重复的元素） &#x3D; 5，可以接受误差！
A &#123;1,3,5,7,8,7&#125;B &#123;1,3,5,7,8&#125;


简介
  Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！  Redis Hyperloglog 基数统计的算法！

网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）
  传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !  这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；  0.81% 错误率！ 统计UV任务，可以忽略不计的！

测试使用
  127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey # 统计 mykey 元素的基数数量(integer) 10127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey2(integer) 9127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 =&gt; mykey3 并集OK127.0.0.1:6379&gt; PFCOUNT mykey3 # 看并集的数量！(integer) 15

  如果允许容错，那么一定可以使用 Hyperloglog ！  如果不允许容错，就使用 set 或者自己的数据类型即可！


Bitmap 位存储统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用Bitmaps！Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！365 天 &#x3D; 365 bit 1字节 &#x3D; 8bit 46 个字节左右！

使用bitmap 来记录 周一到周日的打卡！周一：1 周二：0 周三：0 周四：1 ……

127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 0(integer) 0127.0.0.1:6379&gt; setbit sign 6 0(integer) 0127.0.0.1:6379&gt; getbit sign 3 # 查看某一天是否有打卡！(integer) 1127.0.0.1:6379&gt; getbit sign 6(integer) 0127.0.0.1:6379&gt; bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！(integer) 3127.0.0.1:6379&gt;]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(九)Redis发布订阅</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B9%9D)Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[Redis基础入门(九)Redis发布订阅Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、微博、关注系统！Redis 客户端可以订阅任意数量的频道。订阅&#x2F;发布消息图：第一个：消息发送者， 第二个：频道 第三个：消息订阅者！

下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的

当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：


命令

这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。

  
  

测试

订阅端

  127.0.0.1:6379&gt; SUBSCRIBE peppa # 订阅一个频道 peppaReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;peppa&quot;3) (integer) 1# 等待读取推送的信息1) &quot;message&quot; # 消息2) &quot;peppa&quot; # 那个频道的消息3) &quot;hello,kuangshen&quot; # 消息的具体内容1) &quot;message&quot;2) &quot;peppa&quot;3) &quot;hello,redis&quot;

发送端：

  127.0.0.1:6379&gt; PUBLISH peppa &quot;hello,kuangshen&quot; # 发布者发布消息到频道！(integer) 1127.0.0.1:6379&gt; PUBLISH peppa &quot;hello,redis&quot; # 发布者发布消息到频道！(integer) 1127.0.0.1:6379&gt;

原理
  Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。
  Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。  微信：  通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。
  


通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。
Pub&#x2F;Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。

使用场景
实时消息系统！
事实聊天！（频道当做聊天室，将信息回显给所有人即可！）
订阅，关注系统都是可以的！稍微复杂的场景我们就会使用 消息中间件



]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(二)五大数据类型</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%BA%8C)%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[Redis基础入门(二)五大数据类型1. 官网文档
Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。
2. Redis-Key127.0.0.1:6379&gt; keys * # 查看所有的key(empty list or set)127.0.0.1:6379&gt; set name     yuanxw # set keyOK127.0.0.1:6379&gt; keys *1) &quot;name&quot;127.0.0.1:6379&gt; set age 1OK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; EXISTS name # 判断当前的key是否存在(integer) 1127.0.0.1:6379&gt; EXISTS name1(integer) 0127.0.0.1:6379&gt; move name 1 # 移除当前的key(integer) 1127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; set name beijingOK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; clear127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; get name&quot;beijing&quot;127.0.0.1:6379&gt; EXPIRE name 10 # 设置key的过期时间，单位是秒(integer) 1127.0.0.1:6379&gt; ttl name # 查看当前key的剩余时间(integer) 4127.0.0.1:6379&gt; ttl name(integer) 3127.0.0.1:6379&gt; ttl name(integer) 2127.0.0.1:6379&gt; ttl name(integer) 1127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; get name(nil)127.0.0.1:6379&gt; type name # 查看当前key的一个类型！string127.0.0.1:6379&gt; type agestring

后面如果遇到不会的命令，可以在官网查看帮助文档！

3. String（字符串）##########################################################################127.0.0.1:6379&gt; set key1 v1 # 设置值OK127.0.0.1:6379&gt; get key1 # 获得值&quot;v1&quot;127.0.0.1:6379&gt; keys * # 获得所有的key1) &quot;key1&quot;127.0.0.1:6379&gt; EXISTS key1 # 判断某一个key是否存在(integer) 1127.0.0.1:6379&gt; APPEND key1 &quot;hello&quot; # 追加字符串，如果当前key不存在，就相当于setkey(integer) 7127.0.0.1:6379&gt; get key1&quot;v1hello&quot;127.0.0.1:6379&gt; STRLEN key1 # 获取字符串的长度！(integer) 7127.0.0.1:6379&gt; APPEND key1 &quot;,peppa&quot;(integer) 13127.0.0.1:6379&gt; STRLEN key1(integer) 13127.0.0.1:6379&gt; get key1&quot;v1hello,peppa&quot;########################################################################### i++# 步长 i+=127.0.0.1:6379&gt; set views 0 # 初始浏览量为0OK127.0.0.1:6379&gt; get views&quot;0&quot;127.0.0.1:6379&gt; incr views # 自增1 浏览量变为1(integer) 1127.0.0.1:6379&gt; incr views(integer) 2127.0.0.1:6379&gt; get views&quot;2&quot;127.0.0.1:6379&gt; decr views # 自减1 浏览量-1(integer) 1127.0.0.1:6379&gt; decr views(integer) 0127.0.0.1:6379&gt; decr views(integer) -1127.0.0.1:6379&gt; get views&quot;-1&quot;127.0.0.1:6379&gt; INCRBY views 10 # 可以设置步长，指定增量！(integer) 9127.0.0.1:6379&gt; INCRBY views 10(integer) 19127.0.0.1:6379&gt; DECRBY views 5(integer) 14########################################################################### 字符串范围 range127.0.0.1:6379&gt; set key1 &quot;hello,peppa&quot; # 设置 key1 的值OK127.0.0.1:6379&gt; get key1&quot;hello,peppa&quot;127.0.0.1:6379&gt; GETRANGE key1 0 3 # 截取字符串 [0,3]&quot;hell&quot;127.0.0.1:6379&gt; GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的&quot;hello,peppa&quot;# 替换！127.0.0.1:6379&gt; set key2 abcdefgOK127.0.0.1:6379&gt; get key2&quot;abcdefg&quot;127.0.0.1:6379&gt; SETRANGE key2 1 xx # 替换指定位置开始的字符串！(integer) 7127.0.0.1:6379&gt; get key2&quot;axxdefg&quot;########################################################################### setex (set with expire) # 设置过期时间# setnx (set if not exist) # 不存在在设置 （在分布式锁中会常常使用！）127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot; # 设置key3 的值为 hello,30秒后过期OK127.0.0.1:6379&gt; ttl key3(integer) 26127.0.0.1:6379&gt; get key3&quot;hello&quot;127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果mykey 不存在，创建mykey(integer) 1127.0.0.1:6379&gt; keys *1) &quot;key2&quot;2) &quot;mykey&quot;3) &quot;key1&quot;127.0.0.1:6379&gt; ttl key3(integer) -2127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot; # 如果mykey存在，创建失败！(integer) 0127.0.0.1:6379&gt; get mykey&quot;redis&quot;##########################################################################msetmget127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值OK127.0.0.1:6379&gt; keys *1) &quot;k1&quot;2) &quot;k2&quot;3) &quot;k3&quot;127.0.0.1:6379&gt; mget k1 k2 k3 # 同时获取多个值1) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起失败！(integer) 0127.0.0.1:6379&gt; get k4(nil)# 对象set user:1 &#123;name:zhangsan,age:3&#125; # 设置一个user:1 对象 值为 json字符来保存一个对象！# 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhangsan&quot;2) &quot;2&quot;##########################################################################getset # 先get然后在set127.0.0.1:6379&gt; getset db redis # 如果不存在值，则返回 nil(nil)127.0.0.1:6379&gt; get db&quot;redis&quot;127.0.0.1:6379&gt; getset db mongodb # 如果存在值，获取原来的值，并设置新的值&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;mongodb&quot;

数据结构是相同的！String类似的使用场景：value除了是我们的字符串还可以是我们的数字！

计数器
统计多单位的数量
粉丝数
对象缓存存储！

List（列表）基本的数据类型：列表
在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！所有的list命令都是用l开头的，Redis不区分大小命令

在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！所有的list命令都是用l开头的，Redis不区分大小命令

##########################################################################127.0.0.1:6379&gt; LPUSH list one # 将一个值或者多个值，插入到列表头部 （左）(integer) 1127.0.0.1:6379&gt; LPUSH list two(integer) 2127.0.0.1:6379&gt; LPUSH list three(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -1 # 获取list中值！1) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; LRANGE list 0 1 # 通过区间获取具体的值！1) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; Rpush list righr # 将一个值或者多个值，插入到列表位部 （右）(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;righr&quot;##########################################################################LPOPRPOP127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;righr&quot;127.0.0.1:6379&gt; Lpop list # 移除list的第一个元素&quot;three&quot;127.0.0.1:6379&gt; Rpop list # 移除list的最后一个元素&quot;righr&quot;127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;2) &quot;one&quot;##########################################################################Lindex127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379&gt; lindex list 1 # 通过下标获得 list 中的某一个值！&quot;one&quot;127.0.0.1:6379&gt; lindex list 0&quot;two&quot;##########################################################################Llen127.0.0.1:6379&gt; Lpush list one(integer) 1127.0.0.1:6379&gt; Lpush list two(integer) 2127.0.0.1:6379&gt; Lpush list three(integer) 3127.0.0.1:6379&gt; Llen list # 返回列表的长度(integer) 3127.0.0.1:6379&gt; Lpush list three(integer) 4##########################################################################移除指定的值！取关 uidLrem127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;127.0.0.1:6379&gt; lrem list 1 one # 移除list集合中指定个数的value，精确匹配(integer) 1127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;127.0.0.1:6379&gt; lrem list 1 three(integer) 1127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; Lpush list three(integer) 3127.0.0.1:6379&gt; lrem list 2 three(integer) 2127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;##########################################################################trim 修剪；list 截断!127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; Rpush mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; Rpush mylist &quot;hello1&quot;(integer) 2127.0.0.1:6379&gt; Rpush mylist &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; Rpush mylist &quot;hello3&quot;(integer) 4127.0.0.1:6379&gt; ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素！OK127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;##########################################################################rpoplpush # 移除列表的最后一个元素，将他移动到新的列表中！127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush mylist &quot;hello1&quot;(integer) 2127.0.0.1:6379&gt; rpush mylist &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的列表中！&quot;hello2&quot;127.0.0.1:6379&gt; lrange mylist 0 -1 # 查看原来的列表1) &quot;hello&quot;2) &quot;hello1&quot;127.0.0.1:6379&gt; lrange myotherlist 0 -1 # 查看目标列表中，确实存在改值！1) &quot;hello2&quot;##########################################################################lset 将列表中指定下标的值替换为另外一个值，更新操作127.0.0.1:6379&gt; EXISTS list # 判断这个列表是否存在(integer) 0127.0.0.1:6379&gt; lset list 0 item # 如果不存在列表我们去更新就会报错(error) ERR no such key127.0.0.1:6379&gt; lpush list value1(integer) 1127.0.0.1:6379&gt; LRANGE list 0 01) &quot;value1&quot;127.0.0.1:6379&gt; lset list 0 item # 如果存在，更新当前下标的值OK127.0.0.1:6379&gt; LRANGE list 0 01) &quot;item&quot;127.0.0.1:6379&gt; lset list 1 other # 如果不存在，则会报错！(error) ERR index out of range##########################################################################linsert # 将某个具体的value插入到列把你中某个元素的前面或者后面！127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; Rpush mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; Rpush mylist &quot;world&quot;(integer) 2127.0.0.1:6379&gt; LINSERT mylist before &quot;world&quot; &quot;other&quot;(integer) 3127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;127.0.0.1:6379&gt; LINSERT mylist after world new(integer) 4127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;4) &quot;new&quot;

小结：

list实际上是一个链表，before Node after ， left，right 都可以插入值。
如果key 不存在，创建新的链表。如果key存在，新增内容
如果key存在，新增内容
在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~
消息排队！消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）！

Set（集合）set中的值是不能重读的！
#########################################################################127.0.0.1:6379&gt; sadd myset &quot;hello&quot; # set集合中添加匀速(integer) 1127.0.0.1:6379&gt; sadd myset &quot;peppa&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;lovepeppa&quot;(integer) 1127.0.0.1:6379&gt; SMEMBERS myset # 查看指定set的所有值1) &quot;hello&quot;2) &quot;lovepeppa&quot;3) &quot;peppa&quot;127.0.0.1:6379&gt; SISMEMBER myset hello # 判断某一个值是不是在set集合中！(integer) 1127.0.0.1:6379&gt; SISMEMBER myset world(integer) 0##########################################################################127.0.0.1:6379&gt; scard myset # 获取set集合中的内容元素个数！(integer) 3##########################################################################rem127.0.0.1:6379&gt; srem myset hello # 移除set集合中的指定元素(integer) 1127.0.0.1:6379&gt; scard myset(integer) 2127.0.0.1:6379&gt; SMEMBERS myset2) &quot;lovepeppa&quot;3) &quot;peppa&quot;##########################################################################set 无序不重复集合。抽随机！127.0.0.1:6379&gt; sadd myset &quot;lovepeppa2&quot;(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;lovepeppa2&quot;2) &quot;peppa&quot;3) &quot;lovepeppa&quot;127.0.0.1:6379&gt; SRANDMEMBER myset # 随机抽选出一个元素&quot;peppa&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;peppa&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;peppa&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;peppa&quot;127.0.0.1:6379&gt; SRANDMEMBER myset 2 # 随机抽选出指定个数的元素1) &quot;lovepeppa&quot;2) &quot;lovepeppa2&quot;127.0.0.1:6379&gt; SRANDMEMBER myset 21) &quot;lovepeppa&quot;2) &quot;lovepeppa2&quot;127.0.0.1:6379&gt; SRANDMEMBER myset # 随机抽选出一个元素&quot;lovepeppa2&quot;##########################################################################删除定的key，随机删除key！127.0.0.1:6379&gt; SMEMBERS myset1) &quot;lovepeppa2&quot;2) &quot;lovepeppa&quot;3) &quot;peppa&quot;127.0.0.1:6379&gt; spop myset # 随机删除一些set集合中的元素！&quot;lovepeppa2&quot;127.0.0.1:6379&gt; spop myset&quot;lovepeppa&quot;127.0.0.1:6379&gt; SMEMBERS myset1) &quot;peppa&quot;##########################################################################将一个指定的值，移动到另外一个set集合！127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; sadd myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;world&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;peppa&quot;(integer) 1127.0.0.1:6379&gt; sadd myset2 &quot;set2&quot;(integer) 1127.0.0.1:6379&gt; smove myset myset2 &quot;peppa&quot; # 将一个指定的值，移动到另外一个set集合！(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;world&quot;2) &quot;hello&quot;127.0.0.1:6379&gt; SMEMBERS myset21) &quot;peppa&quot;2) &quot;set2&quot;##########################################################################微博，微信朋友圈，共同关注！(并集)数字集合类：- 差集 SDIFF- 交集- 并集127.0.0.1:6379&gt; FLUSHALLOK127.0.0.1:6379&gt; sadd key1 a  b c (integer) 3127.0.0.1:6379&gt; sadd key2 c  d  e (integer) 3127.0.0.1:6379&gt; SDIFF key1 key2 # 差集1) &quot;b&quot;2) &quot;a&quot;127.0.0.1:6379&gt; SINTER key1 key2 # 交集 共同好友就可以这样实现1) &quot;c&quot;127.0.0.1:6379&gt; SUNION key1 key2 # 并集1) &quot;b&quot;2) &quot;c&quot;3) &quot;e&quot;4) &quot;a&quot;5) &quot;d&quot;

微博，A用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）
Hash（哈希）Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的key-vlaue！set myhash field peppa
#########################################################################127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; hset myhash field1 peppa # set一个具体 key-vlaue(integer) 1127.0.0.1:6379&gt; hget myhash field1 # 获取一个字段值&quot;peppa&quot;127.0.0.1:6379&gt; hmset myhash field1 hello field2 world # set多个 key-vlaueOK127.0.0.1:6379&gt; hmget myhash field1 field2 # 获取多个字段值1) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; hgetall myhash # 获取全部的数据，1) &quot;field1&quot;2) &quot;hello&quot;3) &quot;field2&quot;4) &quot;world&quot;127.0.0.1:6379&gt; hdel myhash field1 # 删除hash指定key字段！对应的value值也就消失了！(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;world&quot;##########################################################################hlen127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; hmset myhash field1 hello field2 worldOK127.0.0.1:6379&gt; HGETALL myhash1) &quot;field2&quot;2) &quot;world&quot;3) &quot;field1&quot;4) &quot;hello&quot;127.0.0.1:6379&gt; hlen myhash # 获取hash表的字段数量！(integer) 2##########################################################################127.0.0.1:6379&gt; HEXISTS myhash field1 # 判断hash中指定字段是否存在！(integer) 1127.0.0.1:6379&gt; HEXISTS myhash field3(integer) 0########################################################################### 只获得所有field# 只获得所有value127.0.0.1:6379&gt; hkeys myhash # 只获得所有field1) &quot;field2&quot;2) &quot;field1&quot;

hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的存储，String更加适合字符串存储！
Zset（有序集合）在set的基础上，增加了一个值，set k1 v1 zset k1 score1 v1
127.0.0.1:6379&gt; FLUSHDBOK27.0.0.1:6379&gt; zadd myset 1 one # 添加一个值(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three # 添加多个值(integer) 2127.0.0.1:6379&gt; ZRANGE myset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;##########################################################################排序如何实现127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; zadd salary 2500 zhangsan # 添加三个用户(integer) 1127.0.0.1:6379&gt; zadd salary 5000 lisi(integer) 1127.0.0.1:6379&gt; zadd salary 500 wangwu(integer) 1# ZRANGEBYSCORE key min max127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf # 显示全部的用户 从小到大！1) &quot;wangwu&quot;2) &quot;zhangsan&quot;3) &quot;lisi&quot;127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 # 从大到进行排序！1) &quot;lisi&quot;2) &quot;zhangsan&quot;3) &quot;wangwu&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成绩1) &quot;wangwu&quot;2) &quot;500&quot;3) &quot;zhangsan&quot;4) &quot;2500&quot;5) &quot;lisi&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores # # 显示工资小于2500员工的升序排序！1) &quot;wangwu&quot;2) &quot;500&quot;3) &quot;zhangsan&quot;4) &quot;2500&quot;########################################################################### 移除rem中的元素127.0.0.1:6379&gt; zrange salary 0 -11) &quot;wangwu&quot;2) &quot;zhangsan&quot;3) &quot;lisi&quot;127.0.0.1:6379&gt; zrem salary zhangsan # 移除有序集合中的指定元素(integer) 1127.0.0.1:6379&gt; zrange salary 0 -11) &quot;wangwu&quot;2) &quot;lisi&quot;127.0.0.1:6379&gt; zcard salary # 获取有序集合中的个数(integer) 2##########################################################################127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; zadd myset 1 hello(integer) 1127.0.0.1:6379&gt; zadd myset 2 world 3 peppa(integer) 2127.0.0.1:6379&gt; zcount myset 1 3 # 获取指定区间的成员数量！(integer) 3127.0.0.1:6379&gt; zcount myset 1 2(integer) 2

其它更多的API，查询官方文档：Command reference – Redis
案例思路：set 排序 存储班级成绩表，工资表排序！普通消息，1， 重要消息 2，带权重进行判断！排行榜应用实现，取Top N 测试！
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(五)Java连接开发工具Jedis</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%BA%94)Java%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Jedis/</url>
    <content><![CDATA[Redis基础入门(五)Java连接开发工具Jedis什么是Jedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用java操作redis，那么一定要对Jedis 十分的熟悉！
1. 新建Jedis项目创建peppa-jedis，引用相关jar包

&lt;dependencies&gt;        &lt;!-- jedis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;            &lt;version&gt;4.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--fastjson--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.79&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.13.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--slf4j --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;2.0.0-alpha5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- logback --&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.3.0-alpha12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;            &lt;version&gt;1.3.0-alpha12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-access&lt;/artifactId&gt;            &lt;version&gt;1.3.0-alpha12&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;

2. PingTest测试连接package com.peppa;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import redis.clients.jedis.Jedis;public class PingTest &#123;    private static final Logger logger= LoggerFactory.getLogger(PingTest.class);    @Test    public void ping()&#123;        Jedis jedis = new Jedis(&quot;192.168.3.21&quot;,6379);        logger.info(&quot;jedis.ping()==&gt;&#123;&#125;&quot;,jedis.ping());    &#125;&#125;

3. StringTest字符package com.peppa;import org.junit.Test;import org.omg.CORBA.PUBLIC_MEMBER;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import redis.clients.jedis.Jedis;import java.util.Arrays;import java.util.Set;import java.util.concurrent.TimeUnit;public class StringTest &#123;    private static final Logger logger = LoggerFactory.getLogger(StringTest.class);    @Test    public void key() &#123;        Jedis jedis = new Jedis(&quot;192.168.3.21&quot;, 6379);        logger.info(&quot;按索引查询：&#123;&#125;&quot;, jedis.select(0));        logger.info(&quot;清空数据：&#123;&#125;&quot;, jedis.flushDB());        logger.info(&quot;判断某个键是否存在：&#123;&#125;&quot;, jedis.exists(&quot;username&quot; ));        logger.info(&quot;新增&lt;&#x27;username&#x27;,&#x27;peppa&#x27;&gt;的键值对：&#123;&#125;&quot;, jedis.set(&quot;username&quot;, &quot;peppa&quot; ));        logger.info(&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&#123;&#125;&quot;, jedis.set(&quot;password&quot;, &quot;123456&quot; ));        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot; );        logger.info(&quot;系统中所有的键如下：&#123;&#125;&quot;, Arrays.toString(keys.toArray()));        logger.info(&quot;删除键password:&#123;&#125;&quot;, jedis.del(&quot;password&quot; ));        logger.info(&quot;判断键password是否存在：&#123;&#125;&quot;, jedis.exists(&quot;password&quot; ));        logger.info(&quot;查看键username所存储的值的类型:&#123;&#125;&quot;, jedis.type(&quot;username&quot; ));        logger.info(&quot;随机返回key空间的一个：&#123;&#125;&quot;, jedis.randomKey());        logger.info(&quot;重命名key：&#123;&#125;&quot;, jedis.rename(&quot;username&quot;, &quot;name&quot; ));        logger.info(&quot;取出改后的name：&#123;&#125;&quot;, jedis.get(&quot;name&quot; ));        logger.info(&quot;删除当前选择数据库中的所有：&#123;&#125;&quot;, jedis.flushDB());        logger.info(&quot;返回当前数据库中key的数目：&#123;&#125;&quot;, jedis.dbSize());        logger.info(&quot;删除所有数据库中的所有key：&#123;&#125;&quot;, jedis.flushAll());    &#125;    @Test    public void str() throws InterruptedException &#123;        Jedis jedis = new Jedis(&quot;192.168.3.21&quot;, 6379);        jedis.flushDB();        logger.info(&quot;==========增加数据=========&quot; );        logger.info(jedis.set(&quot;key1&quot;, &quot;valuel&quot; ));        logger.info(jedis.set(&quot;key2&quot;, &quot;value2&quot; ));        logger.info(jedis.set(&quot;key3&quot;, &quot;value3&quot; ));        logger.info(&quot;删除键key2:&#123;&#125;&quot;, jedis.del(&quot;key2&quot; ));        logger.info(&quot;获取键key2:&#123;&#125;&quot;, jedis.get(&quot;key2&quot; ));        logger.info(&quot;修改key:&#123;&#125;&quot;, jedis.set(&quot;key1&quot;, &quot;valueChanged&quot; ));        logger.info(&quot;获取key1的值：&#123;&#125;&quot;, jedis.get(&quot;key1&quot; ));        logger.info(&quot;在key3后面加入值：&#123;&#125;&quot;, jedis.append(&quot;key3&quot;, &quot;End&quot; ));        logger.info(&quot;key3的值：&quot; + jedis.get(&quot;key3&quot; ));        logger.info(&quot;增加多个键值对：&#123;&#125;&quot;, jedis.mset(&quot;key01&quot;, &quot;value02&quot;, &quot;key02&quot;, &quot;value02&quot;, &quot;key03&quot;, &quot;value03&quot;, &quot;key04&quot;, &quot;value04&quot; ));        logger.info(&quot;获取多个键值对：&#123;&#125;&quot;, jedis.mget(&quot;key01&quot;, &quot;key02&quot;, &quot;key03&quot; ));        logger.info(&quot;获取多个键值对：&#123;&#125;&quot;, jedis.mget(&quot;key01&quot;, &quot;key02&quot;, &quot;key03&quot;, &quot;key04&quot; ));        logger.info(&quot;删除多个键值对：&#123;&#125;&quot;, jedis.del(&quot;key01&quot;, &quot;key02&quot; ));        logger.info(&quot;获取多个键值对：&#123;&#125;&quot;, jedis.mget(&quot;key01&quot;, &quot;key02&quot;, &quot;key03&quot; ));        jedis.flushDB();        logger.info(&quot;===========新增键值对防止覆盖筛先值=============&quot; );        logger.info(&quot;jedis.setnx():&#123;&#125;&quot;, jedis.setnx(&quot;key1&quot;, &quot;value1&quot; ));        logger.info(&quot;jedis.setnx():&#123;&#125;&quot;, jedis.setnx(&quot;key2&quot;, &quot;value2&quot; ));        logger.info(&quot;jedis.setnx():&#123;&#125;&quot;, jedis.setnx(&quot;key2&quot;, &quot;value2-new&quot; ));        logger.info(&quot;jedis.get():&#123;&#125;&quot;, jedis.get(&quot;key1&quot; ));        logger.info(&quot;jedis.get():&#123;&#125;&quot;, jedis.get(&quot;key2&quot; ));        logger.info(&quot;=======新增键值对并设置有效时间=====&quot; );        logger.info(&quot;jedis.setex():&#123;&#125;&quot;, jedis.setex(&quot;key3&quot;, 2, &quot;value3&quot; ));        logger.info(&quot;jedis.get(key3):&#123;&#125;&quot;, jedis.get(&quot;key3&quot; ));        TimeUnit.SECONDS.sleep(3);        logger.info(&quot;jedis.get(key3):&#123;&#125;&quot;, jedis.get(&quot;key3&quot; ));        logger.info(&quot;===========获取原值，更新为新值===========&quot; );        logger.info(jedis.getSet(&quot;key2&quot;, &quot;key2GetSet&quot; ));        logger.info(jedis.get(&quot;key2&quot; ));        logger.info(&quot;获得key2的值的字串：&#123;&#125;&quot;, jedis.getrange(&quot;key2&quot;, 2, 4));    &#125;&#125;

4. ListTest列表package com.peppa;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import redis.clients.jedis.Jedis;public class ListTest &#123;    private static final Logger logger = LoggerFactory.getLogger(ListTest.class);    @Test    public void list() &#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        logger.info(&quot;=======添加一个1ist===========&quot; );        jedis.lpush(&quot;collections&quot;, &quot;ArrayList&quot;, &quot;Vector&quot;, &quot;Stack&quot;, &quot;HashMap&quot;, &quot;WeakHashMap&quot;, &quot;LinkedHashMap&quot; );        jedis.lpush(&quot;collections&quot;, &quot;HashSet&quot; );        jedis.lpush(&quot;collections&quot;, &quot;TreeSet&quot; );        jedis.lpush(&quot;collections&quot;, &quot;TreeMap&quot; );        logger.info(&quot;collections的内容：&#123;&#125;&quot; ,jedis.lrange(&quot;collections&quot;, 0, -1)); //-1代表倒数第一个元素，-2代表倒数第二个元素        logger.info(&quot;collections区间0-3的元素：&#123;&#125;&quot; ,jedis.lrange(&quot;collections&quot;, 0, 3));        logger.info(&quot;=================================&quot; );        // 删除列表指定的值，第二个参数的个数（有重复时），后add进去的值先被删，类似于出栈        logger.info(&quot;删除指定元素个数：&#123;&#125;&quot; ,jedis.lrem(&quot;collections&quot;, 2, &quot;HashMap&quot; ));        logger.info(&quot;collections的内容：&#123;&#125;&quot; ,jedis.lrange(&quot;collections&quot;, 0, -1));        logger.info(&quot;删除下表0-3区间之外的元素：&#123;&#125;&quot; ,jedis.ltrim(&quot;collections&quot;, 0, 3));        logger.info(&quot;collections的内容：&#123;&#125;&quot; ,jedis.lrange(&quot;collections&quot;, 0, -1));        logger.info(&quot;collections列表出栈（左端）：&#123;&#125;&quot; ,jedis.lpop(&quot;collections&quot; ));        logger.info(&quot;collections的内容：&#123;&#125;&quot; ,jedis.lrange(&quot;collections&quot;, 0, -1));        logger.info(&quot;collections添加元素，从列表右端，与1push相对应：&#123;&#125;&quot; ,jedis.rpush(&quot;collections&quot;, &quot;EnumMap&quot; ));        logger.info(&quot;collections的内容：&#123;&#125;&quot; ,jedis.lrange(&quot;collections&quot;, 0, -1));        logger.info(&quot;collections3列表出栈（右端）：&#123;&#125;&quot; ,jedis.rpop(&quot;collections&quot; ));        logger.info(&quot;collections的内容：&#123;&#125;&quot; ,jedis.lrange(&quot;collections&quot;, 0, -1));        logger.info(&quot;修改collections指定下标1的内容：&#123;&#125;&quot; ,jedis.lset(&quot;collections&quot;, 1, &quot;LinkedArrayList&quot; ));        logger.info(&quot;collections的内容：&#123;&#125;&quot; ,jedis.lrange(&quot;collections&quot;, 0, -1));        logger.info(&quot;=================================&quot; );        logger.info(&quot;collections的长度：&#123;&#125;&quot; ,jedis.llen(&quot;collections&quot; ));        logger.info(&quot;获取collections下标为2的元素：&#123;&#125;&quot; ,jedis.lindex(&quot;collections&quot;, 2));        logger.info(&quot;=================================&quot; );        jedis.lpush(&quot;sortedList&quot;, &quot;3&quot;, &quot;6&quot;, &quot;2&quot;, &quot;0&quot;, &quot;7&quot;, &quot;4&quot; );        logger.info(&quot;sortedList排序前：&#123;&#125;&quot; ,jedis.lrange(&quot;sortedList&quot;, 0, -1));        logger.info(&quot;jedis.sort():&#123;&#125;&quot;,jedis.sort(&quot;sortedList&quot; ));        logger.info(&quot;sortedList排序后：&#123;&#125;&quot; ,jedis.lrange(&quot;sortedList&quot;, 0, -1));    &#125;&#125;

5. SetTest集合package com.peppa;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import redis.clients.jedis.Jedis;public class SetTest &#123;    private static final Logger logger = LoggerFactory.getLogger(SetTest.class);    @Test    public void set() &#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        logger.info(&quot;================向集合中添加元素（不重复）============&quot; );        logger.info(&quot;jedis.sadd():&#123;&#125;&quot;,jedis.sadd(&quot;eleSet&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e4&quot;, &quot;e3&quot;, &quot;e0&quot;, &quot;e8&quot;, &quot;e7&quot;, &quot;e5&quot; ));        logger.info(&quot;jedis.sadd():&#123;&#125;&quot;,jedis.sadd(&quot;eleSet&quot;, &quot;e6&quot; ));        logger.info(&quot;jedis.sadd():&#123;&#125;&quot;,jedis.sadd(&quot;eleSet&quot;, &quot;e6&quot; ));        logger.info(&quot;eleSet的所有元素为：&#123;&#125;&quot; ,jedis.smembers(&quot;eleSet&quot; ));        logger.info(&quot;删除一个元素e0：&#123;&#125;&quot; ,jedis.srem(&quot;eleSet&quot;, &quot;e0&quot; ));        logger.info(&quot;eleSet的所有元素为：&#123;&#125;&quot; ,jedis.smembers(&quot;eleSet&quot; ));        logger.info(&quot;删除两个元素e7和e6：&#123;&#125;&quot; ,jedis.srem(&quot;eleSet&quot;, &quot;e7&quot;, &quot;e6&quot; ));        logger.info(&quot;eleSet的所有元素为：&#123;&#125;&quot; ,jedis.smembers(&quot;eleSet&quot; ));        logger.info(&quot;随机的移除集合中的一个元素：&#123;&#125;&quot; ,jedis.spop(&quot;eleSet&quot; ));        logger.info(&quot;随机的移除集合中的一个元素：&#123;&#125;&quot; ,jedis.spop(&quot;eleSet&quot; ));        logger.info(&quot;eleSet的所有元素为：&#123;&#125;&quot; ,jedis.smembers(&quot;eleSet&quot; ));        logger.info(&quot;eleSet中包含元素的个数：&#123;&#125;&quot; ,jedis.scard(&quot;eleSet&quot; ));        logger.info(&quot;e3是否在eleSet中：&#123;&#125;&quot; ,jedis.sismember(&quot;eleSet&quot;, &quot;e3&quot; ));        logger.info(&quot;e1是否在eleSet中：&#123;&#125;&quot; ,jedis.sismember(&quot;eleSet&quot;, &quot;e1&quot; ));        logger.info(&quot;e1是否在eleSet中：&#123;&#125;&quot; ,jedis.sismember(&quot;eleSet&quot;, &quot;e5&quot; ));        logger.info(&quot;=============================&quot; );        logger.info(&quot;jedis.sadd():&#123;&#125;&quot;,jedis.sadd(&quot;eleSet1&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e4&quot;, &quot;e3&quot;, &quot;e0&quot;, &quot;e8&quot;, &quot;e7&quot;, &quot;e5&quot; ));        logger.info(&quot;jedis.sadd():&#123;&#125;&quot;,jedis.sadd(&quot;eleSet2&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e4&quot;, &quot;e3&quot;, &quot;e0&quot;, &quot;e8&quot; ));        logger.info(&quot;将eleSet1中删除e1并存入eleSet3中：&#123;&#125;&quot; ,jedis.smove(&quot;eleSet1&quot;, &quot;eleSet3&quot;, &quot;el&quot; ));//移到集合元素         logger.info(&quot;将eleSet1中删除e2并存入eleSet3中：&#123;&#125;&quot; ,jedis.smove(&quot;eleSet1&quot;, &quot;eleSet3&quot;, &quot;e2&quot; ));        logger.info(&quot;eleSet1中的元素：&#123;&#125;&quot; ,jedis.smembers(&quot;eleSet1&quot; ));        logger.info(&quot;eleSet3中的元素：&#123;&#125;&quot; ,jedis.smembers(&quot;eleSet3&quot; ));        logger.info(&quot;=================集合运算================&quot; );        logger.info(&quot;eleSet1中的元素：&#123;&#125;&quot; ,jedis.smembers(&quot;eleSet1&quot; ));        logger.info(&quot;eleSet2中的元素：&#123;&#125;&quot; ,jedis.smembers(&quot;eleSet2&quot; ));        logger.info(&quot;eleSet1和eleSet2的交集：&#123;&#125;&quot; ,jedis.sinter(&quot;eleSet1&quot;, &quot;eleSet2&quot; ));        logger.info(&quot;eleSet1和eleSet2的并集：&#123;&#125;&quot; ,jedis.sunion(&quot;eleSet1&quot;, &quot;eleSet2&quot; ));        logger.info(&quot;eleSet1和eleSet2的差集:&quot; + jedis.sdiff(&quot;eleSet1&quot;, &quot;eleSet2&quot; ));//eLeSet1中有，eLeSet2中没有        jedis.sinterstore( &quot;eleSet4&quot;, &quot;eleSet1&quot;,&quot;eleSet2&quot;);//求交集并将交集保        logger.info(&quot;eleSet4中的元素：&#123;&#125;&quot;,jedis.smembers(&quot;eleSet4&quot;));    &#125;&#125;

6. TestHashpackage com.peppa;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import redis.clients.jedis.Jedis;import java.util.HashMap;import java.util.Map;public class TestHash &#123;    private static final Logger logger = LoggerFactory.getLogger(ListTest.class);    @Test    public void hash() &#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;key1&quot;, &quot;value1&quot; );        map.put(&quot;key2&quot;, &quot;value2&quot; );        map.put(&quot;key3&quot;, &quot;value3&quot; );        map.put(&quot;key4&quot;, &quot;value4&quot; );        //添加名称为hash（key）的hash元素        jedis.hmset(&quot;hash&quot;, map);        //名称为hash的hash中添加Rey 为key5，vaLue为vatue5元素        jedis.hset(&quot;hash&quot;, &quot;key5&quot;, &quot;value5&quot; );        logger.info(&quot;散列hash的所有键值对为：&#123;&#125;&quot; ,jedis.hgetAll(&quot;hash&quot; )); //return Map&lt;s        logger.info(&quot;散列hash的所有键为：&#123;&#125;&quot; ,jedis.hkeys(&quot;hash&quot; )); //return Set&lt;String&gt;        logger.info(&quot;散列hash的所有值为：&#123;&#125;&quot; ,jedis.hvals(&quot;hash&quot; )); //return List&lt;String        logger.info(&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&#123;&#125;&quot; ,jedis.hincrBy(&quot;hash&quot;, &quot;key6&quot;, 5));        logger.info(&quot;散列hash的所有键值对为：&#123;&#125;&quot; ,jedis.hgetAll(&quot;hash&quot; ));        logger.info(&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&#123;&#125;&quot; ,jedis.hincrBy(&quot;hash&quot;, &quot;key6&quot;, 10));        logger.info(&quot;散列hash的所有键值对为：&#123;&#125;&quot; ,jedis.hgetAll(&quot;hash&quot; ));        logger.info(&quot;删除一个或者多个键值对：&#123;&#125;&quot; ,jedis.hdel(&quot;hash&quot;, &quot;key2&quot; ));        logger.info(&quot;散列hash的所有键值对为：&#123;&#125;&quot; ,jedis.hgetAll(&quot;hash&quot; ));        logger.info(&quot;散列hash中键值对的个数： &quot; + jedis.hlen(&quot;hash&quot; ));        logger.info(&quot;判断hash中是否存在key2：&#123;&#125;&quot; ,jedis.hexists(&quot;hash&quot;, &quot;key2&quot; ));        logger.info(&quot;判断hash中是否存在key3：&#123;&#125;&quot; ,jedis.hexists(&quot;hash&quot;, &quot;key3&quot; ));        logger.info(&quot;获取hash中的值：&#123;&#125;&quot; ,jedis.hmget(&quot;hash&quot;, &quot;key3&quot; ));        logger.info(&quot;获取hash中的值：&#123;&#125;&quot; ,jedis.hmget(&quot;hash&quot;, &quot;key3&quot;, &quot;key4&quot; ));    &#125;&#125;

7. TransactionTest（事务）package com.peppa;import com.alibaba.fastjson.JSONObject;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import redis.clients.jedis.Jedis;import redis.clients.jedis.Transaction;public class TransactionTest &#123;    private static final Logger logger = LoggerFactory.getLogger(ListTest.class);    @Test    public void transaction()&#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        JSONObject jsonObject = new JSONObject();        jsonObject.put(&quot;hello&quot;,&quot;world&quot;);        // 开启事务        Transaction multi = jedis.multi();        String jsonStr = jsonObject.toJSONString();        multi.set(&quot;user1&quot;,jsonStr);        try&#123;            // 代码抛出异常，执行失败            int i = 1/0;            // 执行事务            multi.exec();        &#125;catch(Exception ex)&#123;            logger.error(ex.getMessage(),ex);            multi.discard(); // 放弃事务        &#125;finally &#123;            // 关闭连接            jedis.close();            logger.info(&quot;jsonStr:&#123;&#125;&quot;,jedis.get(&quot;user1&quot;));        &#125;    &#125;&#125;]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(八)Redis持久化</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%85%AB)Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[Redis基础入门(八)Redis持久化Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！
1. RDB（Redis DataBase）
什么是RDB

在主从复制中，rdb就是备用了！从机上面！

  
  在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。  Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。  这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是  RDB，一般情况下不需要修改这个配置！  有时候在生产环境我们会将这个文件进行备份！  rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！
  
  
  

触发机制

save的规则满足的情况下，会自动触发rdb规则
执行 flushall 命令，也会触发我们的rdb规则！
退出redis，也会产生 rdb 文件！备份就自动生成一个 dump.rdb

  

如果恢复rdb文件

只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！
查看需要存在的位置

  127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;/usr/local/bin&quot; # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据

优点缺点：

优点：
适合大规模的数据恢复！
对数据的完整性要不高！


缺点：
需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！
fork进程的时候，会占用一定的内容空间！！





2. AOF（Append Only File）将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！

什么是AOF
  


以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。
Aof保存的是 appendonly.aof 文件

append
  
  默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！重启，redis 就可以生效了！  如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件  redis 给我们提供了一个工具：redis-check-aof --fix
  

重写规则说明

aof 默认就是文件的无限追加，文件会越来越大！，如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！
  appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字# appendfsync always # 每次修改都会 sync。消耗性能appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！# appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！# rewrite 重写，


优点和缺点

优点：
每一次修改都同步，文件的完整会更加好！
每秒同步一次，可能会丢失一秒的数据
从不同步，效率最高的！


缺点：
相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！
Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化！





扩展
RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储
AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。
只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化
同时开启两种持久化方式：
在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有  AOF可能潜在的Bug，留着作为一个万一的手段。


性能建议
因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。
如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产  生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重  写可以改到适当的数值。
如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时倒掉，会丢失十几分钟的数据，  启动脚本也要比较两个 Master&#x2F;Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。



]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(六)SpringBoot整合</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%85%AD)SpringBoot%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[Redis基础入门(六)SpringBoot整合SpringBoot 操作数据，添加Spring Data下
Spring Data:  Spring 的一个子项目。用于简化数据库访问，支持NoSQL和关系数据库存储。其主要目标是使数据库的访问变得方便快捷。
Spring Data 项目所支持NoSQL存储：


MongoDB（文档数据库）



Neo4j （图形数据库）



Redis（键&#x2F;值存储）



Hbase（列族数据库）



Spring Data 项目所支持的关系数据存储技术：


JDBC


- JPA


1. 创建Springboot模块
选择创建Module ⇒ Spring Initializr



配置参数及JDK版本



选择开发工具



选择存储位置



自动导入依赖
  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.6.2&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.peppa&lt;/groupId&gt;    &lt;artifactId&gt;peppa-springboot-redis&lt;/artifactId&gt;    &lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;
  

说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?
  jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式  lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式

查看自动配置文件：spring-autoconfigure-metadata.properties
  SpringBoot所有的配置类，都有一个自动配置类，自动配置类都会绑定一个properties配置文件
  

源码分析：
  @Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)public class RedisAutoConfiguration &#123;	@Bean	@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)	@ConditionalOnSingleCandidate(RedisConnectionFactory.class)	public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;    // 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！    // 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;		RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();		template.setConnectionFactory(redisConnectionFactory);		return template;	&#125;	@Bean	@ConditionalOnMissingBean  // 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！	@ConditionalOnSingleCandidate(RedisConnectionFactory.class)	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;		return new StringRedisTemplate(redisConnectionFactory);	&#125;&#125;

配置连接
  # 配置redisspring.redis.host=192.168.3.21spring.redis.port=6379

测试
  package com.peppa;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;@SpringBootTestclass PeppaSpringbootRedisApplicationTests &#123;    private static final Logger logger = LoggerFactory.getLogger(PeppaSpringbootRedisApplicationTests.class);    @Autowired    private RedisTemplate redisTemplate;    @Test    void contextLoads() &#123;        // redisTemplate 操作不同的数据类型，api和我们的指令是一样的        // opsForValue 操作字符串 类似String        // opsForList 操作List 类似List        // opsForSet        // opsForHash        // opsForZSet        // opsForGeo        // opsForHyperLogLog        // 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD        // 获取redis的连接对象        // RedisConnection connection =        redisTemplate.getConnectionFactory().getConnection();        // connection.flushDb();        // connection.flushAll();        redisTemplate.opsForValue().set(&quot;mykey&quot;, &quot;小猪佩奇&quot;);        logger.info(&quot;mykey===&gt;&#123;&#125;&quot;,redisTemplate.opsForValue().get(&quot;mykey&quot;));    &#125;&#125;

2. Redis序列化配置
默认序列化

Redis模板对象中会使用到的序列化：org.springframework.data.redis.core.RedisTemplate，默认的序列化是JDK

  

关于保存对象
  所有的对象，都需要序列化，不需要的会报如下错误
  @Testpublic void setObjectToRedisTest() &#123;    User user = new User(1,&quot;小猪佩奇&quot;);    redisTemplate.opsForValue().set(&quot;user&quot;,user);    logger.info(&quot;user==&gt;&#123;&#125;&quot;,redisTemplate.opsForValue().get(&quot;user&quot;));&#125;
  

自定义RedisTemplete


package com.peppa.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.JsonTypeInfo;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import org.springframework.stereotype.Component;@Configurationpublic class RedisConfig &#123;    /**     * 自己定义了一个 RedisTemplate     * @param redisConnectionFactory     * @return     */    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        // 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(redisConnectionFactory);        // Json序列化配置        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);        jackson2JsonRedisSerializer.setObjectMapper(om);        // String 的序列化        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        // key采用String的序列化方式        template.setKeySerializer(stringRedisSerializer);        // hash的key也采用String的序列化方式        template.setHashKeySerializer(stringRedisSerializer);        // value序列化方式采用jackson        template.setValueSerializer(jackson2JsonRedisSerializer);        // hash的value序列化方式采用jackson        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    &#125;&#125;


自定义RedisUtil

package com.peppa.util;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;@Componentpublic class RedisUtil &#123;    @Autowired    private RedisTemplate redisTemplate;    // =============================common============================    /**     * 指定缓存失效时间     *     * @param key  键     * @param time 时间(秒)     */    public boolean expire(String key, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.expire(key, time, TimeUnit.SECONDS);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 根据key 获取过期时间     *     * @param key 键 不能为null     * @return 时间(秒) 返回0代表为永久有效     */    public long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    /**     * 判断key是否存在     *     * @param key 键     * @return true 存在 false不存在     */    public boolean hasKey(String key) &#123;        try &#123;            return redisTemplate.hasKey(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 删除缓存     *     * @param key 可以传一个值 或多个     */    @SuppressWarnings(&quot;unchecked&quot;)    public void del(String... key) &#123;        if (key != null &amp;&amp; key.length &gt; 0) &#123;            if (key.length == 1) &#123;                redisTemplate.delete(key[0]);            &#125; else &#123;                redisTemplate.delete(CollectionUtils.arrayToList(key));            &#125;        &#125;    &#125;    // ============================String=============================    /**     * 普通缓存获取     *     * @param key 键     * @return 值     */    public Object get(String key) &#123;        return key == null ? null : redisTemplate.opsForValue().get(key);    &#125;    /**     * 普通缓存放入     *     * @param key   键     * @param value 值     * @return true成功 false失败     */    public boolean set(String key, Object value) &#123;        try &#123;            redisTemplate.opsForValue().set(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 普通缓存放入并设置时间     *     * @param key   键     * @param value 值     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期     * @return true成功 false 失败     */    public boolean set(String key, Object value, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125; else &#123;                set(key, value);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 递增     *     * @param key   键     * @param delta 要增加几(大于0)     */    public long incr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递增因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    /**     * 递减     *     * @param key   键     * @param delta 要减少几(小于0)     */    public long decr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递减因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    // ================================Map=================================    /**     * HashGet     *     * @param key  键 不能为null     * @param item 项 不能为null     */    public Object hget(String key, String item) &#123;        return redisTemplate.opsForHash().get(key, item);    &#125;    /**     * 获取hashKey对应的所有键值     *     * @param key 键     * @return 对应的多个键值     */    public Map&lt;Object, Object&gt; hmget(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    /**     * HashSet     *     * @param key 键     * @param map 对应多个键值     */    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * HashSet 并设置时间     *     * @param key  键     * @param map  对应多个键值     * @param time 时间(秒)     * @return true成功 false失败     */    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     *     * @param key   键     * @param item  项     * @param value 值     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     *     * @param key   键     * @param item  项     * @param value 值     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value, long time) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 删除hash表中的值     *     * @param key  键 不能为null     * @param item 项 可以使多个 不能为null     */    public void hdel(String key, Object... item) &#123;        redisTemplate.opsForHash().delete(key, item);    &#125;    /**     * 判断hash表中是否有该项的值     *     * @param key  键 不能为null     * @param item 项 不能为null     * @return true 存在 false不存在     */    public boolean hHasKey(String key, String item) &#123;        return redisTemplate.opsForHash().hasKey(key, item);    &#125;    /**     * hash递增 如果不存在,就会创建一个 并把新增后的值返回     *     * @param key  键     * @param item 项     * @param by   要增加几(大于0)     */    public double hincr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, by);    &#125;    /**     * hash递减     *     * @param key  键     * @param item 项     * @param by   要减少记(小于0)     */    public double hdecr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, -by);    &#125;    // ============================set=============================    /**     * 根据key获取Set中的所有值     *     * @param key 键     */    public Set&lt;Object&gt; sGet(String key) &#123;        try &#123;            return redisTemplate.opsForSet().members(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    /**     * 根据value从一个set中查询,是否存在     *     * @param key   键     * @param value 值     * @return true 存在 false不存在     */    public boolean sHasKey(String key, Object value) &#123;        try &#123;            return redisTemplate.opsForSet().isMember(key, value);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将数据放入set缓存     *     * @param key    键     * @param values 值 可以是多个     * @return 成功个数     */    public long sSet(String key, Object... values) &#123;        try &#123;            return redisTemplate.opsForSet().add(key, values);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 将set数据放入缓存     *     * @param key    键     * @param time   时间(秒)     * @param values 值 可以是多个     * @return 成功个数     */    public long sSetAndTime(String key, long time, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().add(key, values);            if (time &gt; 0)                expire(key, time);            return count;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 获取set缓存的长度     *     * @param key 键     */    public long sGetSetSize(String key) &#123;        try &#123;            return redisTemplate.opsForSet().size(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 移除值为value的     *     * @param key    键     * @param values 值 可以是多个     * @return 移除的个数     */    public long setRemove(String key, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().remove(key, values);            return count;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    // ===============================list=================================    /**     * 获取list缓存的内容     *     * @param key   键     * @param start 开始     * @param end   结束 0 到 -1代表所有值     */    public List&lt;Object&gt; lGet(String key, long start, long end) &#123;        try &#123;            return redisTemplate.opsForList().range(key, start, end);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    /**     * 获取list缓存的长度     *     * @param key 键     */    public long lGetListSize(String key) &#123;        try &#123;            return redisTemplate.opsForList().size(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 通过索引 获取list中的值     *     * @param key   键     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推     */    public Object lGetIndex(String key, long index) &#123;        try &#123;            return redisTemplate.opsForList().index(key, index);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    /**     * 将list放入缓存     *     * @param key   键     * @param value 值     */    public boolean lSet(String key, Object value) &#123;        try &#123;            redisTemplate.opsForList().rightPush(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @param time  时间(秒)     */    public boolean lSet(String key, Object value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPush(key, value);            if (time &gt; 0)                expire(key, time);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            if (time &gt; 0)                expire(key, time);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 根据索引修改list中的某条数据     *     * @param key   键     * @param index 索引     * @param value 值     * @return     */    public boolean lUpdateIndex(String key, long index, Object value) &#123;        try &#123;            redisTemplate.opsForList().set(key, index, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 移除N个值为value     *     * @param key   键     * @param count 移除多少个     * @param value 值     * @return 移除的个数     */    public long lRemove(String key, long count, Object value) &#123;        try &#123;            Long remove = redisTemplate.opsForList().remove(key, count, value);            return remove;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;&#125;


测试RedisUtil

@Autowiredprivate RedisUtil redisUtil;@Testpublic void redisUtilTest()&#123;    redisUtil.set(&quot;userName&quot;,&quot;peppa&quot;);    logger.info(&quot;userName===&gt;&#123;&#125;&quot;,redisUtil.get(&quot;userName&quot;));&#125;



]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(十)Redis主从复制</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%8D%81)Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[Redis基础入门(十)Redis主从复制1. 主从复制主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

主从复制的作用主要包括：
数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。



一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：

从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；
从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。
电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。对于这种场景，我们可以使如下这种架构：


主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！
2. 环境配置
只配置从库，不用配置主库！

127.0.0.1:6379&gt; info replication # 查看当前库的信息# Replicationrole:master # 角色 masterconnected_slaves:0 # 没有从机master_failover_state:no-failovermaster_replid:b63c90e6c501143759cb0e7f450bd1eb0c70882amaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0


复制3个配置文件，然后修改对应的信息
端口
pid 名字
log文件名字
dump.rdb 名字  修改完毕之后，启动我们的3个redis服务器，可以通过进程信息查看！



3. 一主二从配置默认情况下，每台Redis服务器都是主节点； 我们一般情况下只用配置从机就好了！认老大！ 一主 （79）二从（80，81）

服务器：6380、6381节点，命令：SLAVEOF 127.0.0.1 6379
真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！

127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379OK127.0.0.1:6380&gt; info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:11master_sync_in_progress:0slave_read_repl_offset:14slave_repl_offset:14slave_priority:100slave_read_only:1replica_announced:1connected_slaves:0master_failover_state:no-failovermaster_replid:b0d63cc54f188f3c8a92cc65e88134759417b18emaster_replid2:0000000000000000000000000000000000000000master_repl_offset:14second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:14


在主机节点：【6379】中查看！

127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2   # 多了从机的配置slave0:ip=127.0.0.1,port=6380,state=online,offset=14,lag=1  # 多了从机的配置slave1:ip=127.0.0.1,port=6381,state=online,offset=14,lag=0  # 多了从机的配置master_failover_state:no-failovermaster_replid:b0d63cc54f188f3c8a92cc65e88134759417b18emaster_replid2:0000000000000000000000000000000000000000master_repl_offset:14second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:14


主从测试
  主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！
  主机写：
  

从机只能读取内容：
  
  测试：

主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！
如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！


复制原理

Slave 启动成功连接到 master 后会发送一个sync同步命令。
Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。
全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。
增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步。但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！


手动选对主节点
  如果主机断开了连接，我们可以使用 SLAVEOF no one 让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接（重新设置**SLAVEOF命令**）！


4. 哨兵模式概述：自动选举master的模式
主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。
后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。


这里的哨兵有两个作用

通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。

  然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。  各个哨兵之间还会进行监控，这样就形成了多哨兵模式。
  
  假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。
  

测试
  我们目前的状态是 一主二从！

配置哨兵配置文件 sentinel.conf
  # sentinel monitor 被监控的名称 host port 1sentinel monitor myredis 127.0.0.1 6379 1
  后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！

启动哨兵


  [root@localhost bin]# ./redis-sentinel config/sentinel.conf 23283:X 12 Jan 2022 07:06:19.119 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo23283:X 12 Jan 2022 07:06:19.119 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=23283, just started23283:X 12 Jan 2022 07:06:19.119 # Configuration loaded23283:X 12 Jan 2022 07:06:19.121 * monotonic clock: POSIX clock_gettime                _._                                                             _.-``__ &#x27;&#x27;-._                                                   _.-``    `.  `_.  &#x27;&#x27;-._           Redis 6.2.6 (00000000/0) 64 bit  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._                                   (    &#x27;      ,       .-`  | `,    )     Running in sentinel mode |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 26379 |    `-._   `._    /     _.-&#x27;    |     PID: 23283  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                    |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                   |    `-._`-._        _.-&#x27;_.-&#x27;    |           https://redis.io         `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                    |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                   |    `-._`-._        _.-&#x27;_.-&#x27;    |                                    `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                         `-._    `-.__.-&#x27;    _.-&#x27;                                                 `-._        _.-&#x27;                                                         `-.__.-&#x27;                                               23283:X 12 Jan 2022 07:06:19.122 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.23283:X 12 Jan 2022 07:06:19.122 # Sentinel ID is 4cc0f01814993b512993fe592448af8fb6590b0123283:X 12 Jan 2022 07:06:19.122 # +monitor master myredis 127.0.0.1 6379 quorum 123283:X 12 Jan 2022 07:06:19.123 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 637923283:X 12 Jan 2022 07:06:19.125 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379

如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）

  
  
  如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！
  

优点缺点

优点
哨兵集群，基于主从复制模式，所有的主从配置优点，它全有
主从可以切换，故障可以转移，系统的可用性就会更好
哨兵模式就是主从模式的升级，手动到自动，更加健壮！


缺点：
Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！
实现哨兵模式的配置其实是很麻烦的，里面有很多选择！




哨兵模式的全部配置


# Example sentinel.conf# 哨兵sentinel实例运行的端口 默认26379port 26379# 哨兵sentinel的工作目录dir /tmp# 哨兵sentinel监控的redis主节点的 ip port# master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。# quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 2# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster MySUPER--secret-0123passw0rd# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，# 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。# 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1# 故障转移的超时时间 failover-timeout 可以用在以下这些方面：#1. 同一个sentinel对同一个master两次failover之间的间隔时间。#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。#3.当想要取消一个正在进行的failover所需要的时间。#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，# slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了# 默认三分钟# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000# SCRIPTS EXECUTION#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。#对于脚本的运行结果有以下规则：#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），#将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信#息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配#置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。# 通知脚本# shell编程# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;sentinel notification-script mymaster /var/redis/notify.sh# 客户端重新配置主节点参数脚本# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。# 以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;# 目前&lt;state&gt;总是“failover”,# &lt;role&gt;是“leader”或者“observer”中的一个。# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配置！]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(十一)Redis缓存穿透和雪崩</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%8D%81%E4%B8%80)Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[Redis基础入门(十一)Redis缓存穿透和雪崩Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。

2. 缓存穿透（查不到）缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了——缓存穿透。

解决方案

布隆过滤器
  布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；
  

缓存空对象
  当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数  据将会从缓存中获取，保护了后端数据源；
  


  但是这种方法会存在两个问题：  1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多  的空值的键；  2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于  需要保持一致性的业务会有影响。


缓存击穿（量太大，缓存过期！）这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。

设置热点数据永不过期

从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。


加互斥锁

分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。

  


缓存雪崩缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。

其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。

解决方案
redis高可用
  这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）

限流降级
  这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

数据预热
  数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。




]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门(四)Redis 事务操作</title>
    <url>/Redis/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E5%9B%9B)Redis%20%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[Redis基础入门(四)Redis 事务操作1. 事务Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！一次性、顺序性、排他性！执行一些列的命令！
----- 队列 set set set 执行----—

Redis事务没有没有隔离级别的概念！所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！ExecRedis单条命令式保存原子性的，但是事务不保证原子性！

Redis的事务：

开启事务（multi）
命令入队（……）
执行事务（exec）


正常执行事务


127.0.0.1:6379&gt; multi # 开启事务OK# 命令入队127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; exec # 执行事务1) OK2) OK3) &quot;v2&quot;4) OK


放弃事务

127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; DISCARD # 取消事务OK127.0.0.1:6379&gt; get k4 # 事务队列中命令都不会被执行！(nil)


编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！

127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; getset k3 # 错误的命令(error) ERR wrong number of arguments for &#x27;getset&#x27; command127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; set k5 v5QUEUED127.0.0.1:6379&gt; exec # 执行事务报错！(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k5 # 所有的命令都不会被执行！(nil)


运行时异常（1&#x2F;0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！

127.0.0.1:6379&gt; set k1 &quot;v1&quot;OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1 # 会执行的时候失败！QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; get k3QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！2) OK3) OK4) &quot;v3&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt; get k3&quot;v3&quot;


监控！ Watch （面试常问！）

悲观锁：很悲观，认为什么时候都会出问题，无论做什么都会加锁！
乐观锁：


很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否有人修改过这个数据，
获取version
更新的时候比较 version


Redis测监视测试


127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch money # 监视 money 对象OK127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！OK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY out 20QUEUED**127.0.0.1:6379&gt; exec1) (integer) 802) (integer) 20


测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！

127.0.0.1:6379&gt; watch money # 监视 moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 10QUEUED127.0.0.1:6379&gt; INCRBY out 10QUEUED127.0.0.1:6379&gt; exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！(nil)


如果修改失败，获取最新的值就好

127.0.0.1:6379&gt; UNWATCHOK127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; DECRBY money 10QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 10QUEUED127.0.0.1:6379(TX)&gt; exec1) (integer) 702) (integer) 30


]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
</search>
